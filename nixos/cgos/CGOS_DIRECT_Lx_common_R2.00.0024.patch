diff --git a/99-cgos.rules b/99-cgos.rules
old mode 100755
new mode 100644
diff --git a/CgosBld.h b/CgosBld.h
old mode 100755
new mode 100644
index 29477d0..6de3394
--- a/CgosBld.h
+++ b/CgosBld.h
@@ -1,3 +1,3 @@
 #ifndef CGOS_BUILD_NUMBER
-#define CGOS_BUILD_NUMBER 21
+#define CGOS_BUILD_NUMBER 24
 #endif
diff --git a/CgosDrv/CGBC.h b/CgosDrv/CGBC.h
old mode 100755
new mode 100644
index ba50343..8cce5f5
--- a/CgosDrv/CGBC.h
+++ b/CgosDrv/CGBC.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2020, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -25,6 +25,42 @@
  *
  *                      R E V I S I O N   H I S T O R Y
  *
+ * MOD071: Added support for a 32-bit boot time/system up time meter with a 1ms
+ *         granularity.
+ * MOD070: Revised the definition and usage of standard data types to support
+ *         64-bit environments properly.
+ * MOD069: Added logical pin function for BRD_PWR_EN.
+ * MOD068: Added missing logical pin functions for SUSPWRDNACK, SLP_M#,
+ *         SLP_LAN# and SLP_WLAN#.
+ * MOD067: Added support for logging special system events such as eSPI events.
+ * MOD066: Added CGBC_POST_SEC_DISPLAY_DIS bit definition.
+ *
+ * MOD065: Added support for dedicated SPD SMBuses CGBC_I2C_BUS_DDR0 and
+ *         CGBC_I2C_BUS_DDR1.
+ * MOD064: Added support for a power control event logging group and for event
+ *         logging of virtual pins, eSPI virtual wires and HWM values.
+ * MOD063: Added support for general purpose SPI (GSPI).
+ *
+ * MOD062: Changed congatec board controller type name for the MEC170x based
+ *         congatec Board Controllers.
+ * MOD061: Added new CGBC API command CGBC_CMD_AVR_SPM_EXT.
+ * MOD060: Added support for the new pin function CGBC_PIN_FNC_SPD_SMB_MUX.
+ * MOD059: Added support for extended cBC I2C API.
+ * MOD058: Added the ui8Usage field in the HWM control unit configuration
+ *         parameters used to identify specific HWM control units.
+ * MOD057: Improved definitions of the HWM unit configuration parameter
+ *         structures
+ * MOD056: Added support for MCU GPIO pins being used as binary HWM sensors and
+ *         actuators.
+ * MOD055: Added support for UART_MUX_PCH pin.
+ * MOD054: Added support for a voltage tolerant open-drain output pin mode.
+ * MOD053: Added support for enabling/disabling DHCC.
+ * MOD052: Added support for COM-HPC (new I2C/SMBuses I2C1, IPMB, UPDB, new
+ *         pin functions CGBC_PIN_FNC_PMBUS_MUX, CGBC_PIN_FNC_TESTn,
+ *         CGBC_PIN_FNC_VIN_PWROK, CGBC_PIN_FNC_RAPID_SHUTDOWN
+ *         CGBC_PIN_FNC_UART_MUX_PCHn, CGBC_PIN_FNC_THRMn and
+ *         CGBC_PIN_FNC_PROCHOTn, new logical HWM sensor types.
+ *
  * MOD051: Changes to allow a clear identification of two DIMM temperature
  *         sensors on the top side of the PCB.
  *
@@ -48,20 +84,20 @@
  * 
  *    Rev 1.31   Mar 18 2019 13:07:34   ess
  * MOD044: Update to latest GEN5 cBC functionality
- * 
- *    Rev 1.30   Sep 18 2018 14:42:52   ess
- * MOD043: put CGBC_HWM_DATA type definition back in which had been commented
- *         out by mistake in rev 1.28 and rev 1.29
- * 
- *    Rev 1.29   Apr 03 2018 08:53:28   ess
- * MOD042: added support for MEC1705
  * 
- *    Rev 1.28   Sep 06 2016 15:45:56   congatec
- * Added BSD header.
+ *    Rev 1.30   Sep 18 2018 14:42:52   ess
+ * MOD043: put CGBC_HWM_DATA type definition back in which had been commented
+ *         out by mistake in rev 1.28 and rev 1.29
  * 
- *    Rev 1.27   Jun 03 2016 11:17:24   ess
- * MOD041: added new host commands for second LFP control, diagnostic output
- *         interface configuration and GPI IRQ support
+ *    Rev 1.29   Apr 03 2018 08:53:28   ess
+ * MOD042: added support for MEC1705
+ * 
+ *    Rev 1.28   Sep 06 2016 15:45:56   congatec
+ * Added BSD header.
+ * 
+ *    Rev 1.27   Jun 03 2016 11:17:24   ess
+ * MOD041: added new host commands for second LFP control, diagnostic output
+ *         interface configuration and GPI IRQ support
  * 
  *    Rev 1.26   Apr 05 2016 16:55:28   ess
  * MOD040: update for latest BC functionality including POST code redirection,
@@ -177,6 +213,8 @@
 #ifndef __AVR__                                                      //MOD013
 #pragma pack(1)                                                      //MOD001
 #endif //!__AVR__                                                    //MOD013
+
+#ifdef _MSC_VER                                                    /*MOD070 */
                                                                    /*MOD039v*/
 #ifndef  SINT16
 #define  SINT16 signed short
@@ -221,7 +259,17 @@
 #ifndef  int32_t
 #define  int32_t signed long
 #endif /*int32_t*/
+                                                                     /*MOD070v*/
+
+//MOD24 v not needed, typedef int wchar_t in DrvOsHdr.h
 
+// #else //#ifdef _MSC_VER
+
+//#include <stdint.h> 
+//MOD24 ^ 
+              
+#endif //#ifdef _MSC_VER
+                                                                   /*MOD070^*/ 
                                                                    /*MOD046v*/
 /*------------------------------------
  * congatec Board Controller families
@@ -375,6 +423,15 @@
 #define CGBC_CMD_WDOG_RD         0x98
 #define CGBC_CMD_GPIO_IRQ_TBL    0x99
                                                                      //MOD046^
+                                                                     //MOD059v
+#define CGBC_CMD_I2C_START_EXT   0x9A
+#define CGBC_CMD_I2C_STAT_EXT    0x9B
+#define CGBC_CMD_I2C_DATA_EXT    0x9C
+#define CGBC_CMD_I2C_SPEED_EXT   0x9D
+#define CGBC_CMD_I2C_COMBI_EXT   0x9E
+                                                                     //MOD059^
+#define CGBC_CMD_AVR_SPM_EXT     0x9F                                //MOD061
+#define CGBC_CMD_GSPI_CFG        0xA0                                //MOD063
 #define CGBC_CMD_SYNC            0xFE                                //MOD014
 
 
@@ -516,7 +573,7 @@ typedef struct CGBC_CMD_INFO_1_OUT_STRUCT
 #define CGBC_ATMEGA325P    5                                         //MOD015
 #define CGBC_STM32F100R8   6                                         //MOD018
 #define CGBC_TM4E1231H6ZRB 7                                         //MOD030
-#define CGBC_MEC1705QSZ    8                                         //MOD042
+#define CGBC_MEC170x       8                                  //MOD042 MOD062
 
 /* watchdog information */
 
@@ -570,11 +627,18 @@ typedef struct CGBC_CMD_INFO_1_OUT_STRUCT
 
 typedef struct CGBC_CMD_BOOT_TIME_OUT_STRUCT
    {
-    unsigned char  sts;                         /* command status           */
-    UINT16 systemUpTime;                /* system up time in ms     */
-    UINT16 lastBootTime;                /* last boot time in ms     */
+    unsigned char  sts;                    /* command status                */
+    uint16_t       systemUpTime;           /* system up time in 250ms units */ //MOD070
+    uint16_t       lastBootTime;           /* last boot time in 250ms units */ //MOD070
    } CGBC_CMD_BOOT_TIME_OUT, *P_CGBC_CMD_BOOT_TIME_OUT;
-
+                                                                     //MOD071v
+typedef struct CGBC_CMD_BOOT_TIME_OUT_32_STRUCT
+   {
+    unsigned char  sts;                      /* command status              */
+    uint32_t       systemUpTime;             /* system up time in 1ms units */
+    uint32_t       lastBootTime;             /* last boot time in 1ms units */
+   } CGBC_CMD_BOOT_TIME_OUT_32, *P_CGBC_CMD_BOOT_TIME_OUT_32;
+                                                                     //MOD071^
 #endif /*!__ASSEMBLER__*/
                                                                      //MOD014^
                                                                      
@@ -694,6 +758,7 @@ typedef struct CGBC_CMD_VID_CONTROL_OUT_STRUCT  // response packet structure
 #define CGBC_I2C_BUS_MSK      0x07  /* bus mask for CGBC commands           */
 #define CGBC_I2C_BUS_I2C0     0x00  /* primary I2C-bus 0                    */ //MOD044
 #define CGBC_I2C_BUS_EXTERNAL 0x00  /* physical 400kHz multi-master I2C bus */
+                                                                               //MOD052 MOD059
 #define CGBC_I2C_BUS_SMB1     0x01  /* secondary SMBus                      */ //MOD033
 #define CGBC_I2C_BUS_SMB0     0x02  /* primary SMBus                        */ //MOD033
 #define CGBC_I2C_BUS_SMB      0x02  /* system management bus                */
@@ -704,7 +769,14 @@ typedef struct CGBC_CMD_VID_CONTROL_OUT_STRUCT  // response packet structure
 #define CGBC_I2C_BUS_DDC      0x04  /* video DDC bus                        */
 #define CGBC_I2C_BUS_EPI      0x04  /* embedded panel interface bus         */ //MOD004
 #define CGBC_I2C_BUS_EOOB     0x05  /* eSPI OOB channel                     */ //MOD046
+#define CGBC_I2C_BUS_IPMB     0x06  /* intelligent platform management bus  */ //MOD052
+                                                                               //MOD052 MOD059
 #define CGBC_I2C_BUS_SMB2     0x07  /* auxiliary SMBus                      */ //MOD033
+#define CGBC_I2C_BUS_I2C1     0x08  /* secondary I2C-bus 1                  */ //MOD059
+#define CGBC_I2C_BUS_UPDB     0x09  /* USB PD controller bus                */ //MOD059
+#define CGBC_I2C_BUS_DDR0     0x0A  /* dedicated DDR SMBus 0                */ //MOD065
+#define CGBC_I2C_BUS_DDR1     0x0B  /* dedicated DDR SMBus 1                */ //MOD065
+#define CGBC_I2C_BUS_MAX      CGBC_I2C_BUS_DDR1                                //MOD065
                                                                      //MOD002^
 
 
@@ -788,6 +860,56 @@ typedef struct CGBC_CMD_I2C_SPEED_OUT_STRUCT
 #endif //!__ASSEMBLER__
                                                                      //MOD021^
 
+                                                                     //MOD059v
+/* -----------------------------------------------------------------------
+ * CGBC_CMD_I2C_START_EXT/CGBC_CMD_I2C_COMBINED_EXT command definitions
+ * -------------------------------------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_START_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                   unsigned char wrCnt;
+                   unsigned char rdCnt;
+                   unsigned char i2cData[35];
+                  } CGBC_CMD_I2C_START_EXT_IN,
+                 *P_CGBC_CMD_I2C_START_EXT_IN;
+
+/* --------------------------------------------
+ * CGBC_CMD_I2C_STAT_EXT command definitions
+ * ----------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_STAT_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                  } CGBC_CMD_I2C_STAT_EXT_IN,
+                 *P_CGBC_CMD_I2C_STAT_EXT_IN;
+
+/* --------------------------------------------
+ * CGBC_CMD_I2C_DATA_EXT command definitions
+ * ----------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_DATA_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                  } CGBC_CMD_I2C_DATA_EXT_IN,
+                 *P_CGBC_CMD_I2C_DATA_EXT_IN;
+
+/* -----------------------------------------
+ * CGBC_CMD_I2C_SPEED_EXT command definitions
+ * -------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_SPEED_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                   unsigned char speed;
+                  } CGBC_CMD_I2C_SPEED_EXT_IN,
+                 *P_CGBC_CMD_I2C_SPEED_EXT_IN;
+                                                                     //MOD059^
+
 
 /*--------------------
  * I2C device numbers
@@ -814,11 +936,11 @@ typedef struct CGBC_CMD_I2C_SPEED_OUT_STRUCT
 typedef struct CG_BC_EEP_STRUCT
    {
     unsigned char  i2cExtSpeed;       /* I2C-bus power-up default frequency */
-    UINT16 i2cExtTimeout;             /* I2C-bus power-up default timeout   */
+    uint16_t       i2cExtTimeout;     /* I2C-bus power-up default timeout   */ //MOD070
     unsigned char  i2cSmbSpeed;       /* ASM-bus power-up default frequency */
-    UINT16 i2cSmbTimeout;             /* ASM-bus power-up default timeout   */
+    uint16_t       i2cSmbTimeout;     /* ASM-bus power-up default timeout   */ //MOD070
     unsigned char  i2cDdcSpeed;       /* EPI-bus power-up default frequency */
-    UINT16 i2cDdcTimeout;             /* EPI-bus power-up default timeout   */
+    uint16_t       i2cDdcTimeout;     /* EPI-bus power-up default timeout   */ //MOD070
     unsigned char  s5eDelay250;       /* default S5e delay       */  //MOD044
                                                                      //MOD004v
     unsigned char  vidControl;        /* video control power-up default     */
@@ -894,13 +1016,13 @@ typedef struct CGBC_WD_PARMS_STRUCT
     unsigned char  wdInitCmd;                /* CGBC_CMD_WD_INIT             */
     unsigned char  wdMode;                   /* watchdog mode                */
     unsigned char  wdCtrl;                   /* watchdog control byte        */
-    UINT16 wdSt1TimL;                /* watchdog stage 1 time (msec) */ //MOD008
+    uint16_t       wdSt1TimL;                /* watchdog stage 1 time (msec) */ //MOD008 MOD070
     unsigned char  wdSt1TimH;
-    UINT16 wdSt2TimL;                /* watchdog stage 2 time (msec) */ //MOD008
+    uint16_t       wdSt2TimL;                /* watchdog stage 2 time (msec) */ //MOD008 MOD070
     unsigned char  wdSt2TimH;
-    UINT16 wdSt3TimL;                /* watchdog stage 3 time (msec) */ //MOD008
+    uint16_t       wdSt3TimL;                /* watchdog stage 3 time (msec) */ //MOD008 MOD070
     unsigned char  wdSt3TimH;
-    UINT16 wdDlyTimL;                /* watchdog delay time   (msec) */ //MOD008
+    uint16_t       wdDlyTimL;                /* watchdog delay time   (msec) */ //MOD008 MOD070
     unsigned char  wdDlyTimH;
    } CGBC_WD_PARMS, *P_CGBC_WD_PARMS;
                                                                      //MOD002^
@@ -1315,7 +1437,7 @@ typedef struct CGBC_CMD_FAN_CONTROL_IN_STRUCT   // command packet structure
 typedef struct CGBC_CMD_FAN_CONTROL_OUT_STRUCT  // response packet structure
    {
     unsigned char  sts;                         // command status
-    UINT16 speed;                       // current fan speed count
+    uint16_t       speed;                       // current fan speed count MOD070
    } CGBC_CMD_FAN_CONTROL_OUT, *P_CGBC_CMD_FAN_CONTROL_OUT;
 
 #endif //!__ASSEMBLER__
@@ -1360,7 +1482,7 @@ typedef struct CGBC_CMD_FAN_CONTROL_OUT_STRUCT  // response packet structure
 typedef struct CGBC_CMD_RTC_IN_STRUCT           // command packet structure
    {
     unsigned char  cmd;                         // CGBC_CMD_RTC
-    UINT16 year;                        // year to be set or 0
+    uint16_t       year;                        // year to be set or 0 MOD070
     unsigned char  month;                       // month to be set
     unsigned char  day;                         // day to be set
     unsigned char  hour;                        // hour to be set
@@ -1371,7 +1493,7 @@ typedef struct CGBC_CMD_RTC_IN_STRUCT           // command packet structure
 typedef struct CGBC_CMD_RTC_OUT_STRUCT          // response packet structure
    {
     unsigned char  sts;                         // command status
-    UINT16 yearSts;                     // current year and flags
+    uint16_t       yearSts;                     // current year and flags MOD070
     unsigned char  month;                       // current month
     unsigned char  day;                         // current day
     unsigned char  hour;                        // current hour
@@ -1482,7 +1604,7 @@ typedef struct CGBC_HWM_DATA_HDR_STRUCT
 typedef struct CGBC_HWM_SENSOR_STRUCT
     {
      uint8_t typ;                       /* hardware monitoring sensor type  */
-     SINT16  val;                       /* hardware monitoring sensor value */
+     int16_t val;                       /* hardware monitoring sensor value */ //MOD070
      uint8_t res;                       /* reserved                         */
     } CGBC_HWM_SENSOR, *P_CGBC_HWM_SENSOR;
 
@@ -1545,8 +1667,16 @@ typedef struct CGBC_HWM_DATA_STRUCT
  #define CGBC_TEMP_DIMM_TOP      0x09
  #define CGBC_TEMP_DIMM_TOP_0    0x09                              /* MOD051 v*/
  #define CGBC_TEMP_DIMM_BOTTOM   0x0A
+ #define CGBC_TEMP_DIMM_BOT_0    0x0A                              /* MOD052 */
  #define CGBC_TEMP_BOARD_ALT     0x0B                              /* MOD049 */
  #define CGBC_TEMP_DIMM_TOP_1    0x0C                              /* MOD051 ^*/
+ #define CGBC_TEMP_DIMM_TOP_2    0x0D                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_3    0x0E                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_4    0x0F                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_5    0x10                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_6    0x11                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_7    0x12                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_BOT_1    0x13                              /* MOD052 */
 
  #define CGBC_VOLTAGE_CPU        0x01
  #define CGBC_VOLTAGE_DC         0x02
@@ -1645,7 +1775,7 @@ CGBC_HWM_SENSOR_UNIT_CONFIG_STRUCT /* This is the structure of the config
   uint8_t   ui8PhyType;                   /* physical sensor type            */
   uint8_t   ui8BusNum;                    /* bus on which the sensor resides */
   uint8_t   ui8DevAddr;                   /* sensor device address           */
-  uint32_t ui32Reserved;                  /* reserved for future extensions  */
+  uint8_t  aui8Reserved[0];               /* reserved for extensions  MOD057 */
 }
 CGBC_HSU_CFG, *P_CGBC_HSU_CFG;
 
@@ -1676,7 +1806,7 @@ CGBC_HWM_ACTUATOR_UNIT_CONFIG_STRUCT /* This is the structure of the config
   uint16_t ui16SetMax;                  /* set point maximum                 */
   uint16_t ui16SetDflt;                 /* default set point                 */
   uint16_t ui16SetCur;                  /* current set point                 */
-  uint32_t ui32Reserved;                /* reserved for future extensions    */
+  uint8_t  aui8Reserved[0];             /* reserved for extensions    MOD057 */
 }
 CGBC_HAU_CFG, *P_CGBC_HAU_CFG;
 
@@ -1704,7 +1834,10 @@ CGBC_HWM_CONTROL_UNIT_CONFIG_STRUCT /* This is the structure of the config
   uint8_t   ui8SetLo;           /* set point when sensor below lower limit   */
   uint8_t   ui8SenSel;          /* HWM sensor selector                       */
   uint8_t   ui8ActSel;          /* HWM actuator selector                     */
-  uint32_t ui32Reserved;        /* reserved for future extensions            */
+  uint8_t   ui8SenPin;          /* pin number of MCU pin sensor       MOD056 */
+  uint8_t   ui8ActPin;          /* pin number of MCU pin actuator     MOD056 */
+  uint8_t   ui8Usage;           /* intended HWM control unit usage    MOD058 */
+  uint8_t  aui8Reserved[0];     /* reserved for future extensions     MOD057 */
 }
 CGBC_HCU_CFG, *P_CGBC_HCU_CFG;
 
@@ -1716,6 +1849,7 @@ CGBC_HWM_UNIT_CONFIG_UNION /* This is the overall union of config parameters
   CGBC_HSU_CFG xSen;           /* HWM sensor unit config parameters          */
   CGBC_HAU_CFG xAct;           /* HWM actuator unit config parameters        */
   CGBC_HCU_CFG xCtl;           /* HWM control unit config parameters         */
+  uint8_t aui8RawData[24];     /* maximum structure size              MOD057 */
 }
 CGBC_HWM_UNIT_CFG, *P_CGBC_HWM_UNIT_CFG;
 
@@ -1747,6 +1881,21 @@ CGBC_CMD_HWM_CFG_OUT_STRUCT /* response data structure for CGBC_CMD_HWM_CFG */
 
 #define CGBC_HUN_MASK     0x1F  /* HWM unit number */
                                                                      //MOD040^
+                                                                     //MOD056v
+/* Special HWM unit selectors */
+#define CGBC_HUS_RESERVED_1F  (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 0))
+#define CGBC_HUS_MCU_GPIL_SEN (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 1))
+#define CGBC_HUS_MCU_GPIH_SEN (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 2))
+#define CGBC_HUS_MCU_GPOL_ACT (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 3))
+#define CGBC_HUS_MCU_GPOH_ACT (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 4))
+                                                                     //MOD056^
+                                                                     //MOD058v
+/* intended HWM control unit usage codes */
+#define CGBC_HCU_USAGE_GENERAL  0x00               /* general purpose        */
+#define CGBC_HCU_USAGE_CPU_TEMP 0x01               /* CPU thermal control    */
+#define CGBC_HCU_USAGE_SYS_TEMP 0x02               /* system thermal control */
+#define CGBC_HCU_USAGE_CPU_THRT 0x03               /* CPU throttling control */
+                                                                     //MOD058^
                                                                      //MOD023v
 /*----------------------------------------
  * CGBC_CMD_PECI command/response packets
@@ -2093,6 +2242,11 @@ CGBC_CMD_POST_CFG_OUT_STRUCT                    /* response packet structure */
 #define  CGBC_POST_CH2_ADDR_1   0x0001      /*   - primary port address + 1  */
 #define  CGBC_POST_CH2_ADDR_2   0x0010      /*   - primary port address + 2  */
                                                                       //MOD044^
+                                                                      //MOD066v
+#define CGBC_POST_SEC_DISPLAY_DIS 0x0004 /* Actively disable the secondary POST
+                                          * code display which are the lower
+										  * two digits. */
+                                                                      //MOD066^
 
 
 /*-------------------------------
@@ -2153,15 +2307,19 @@ CGBC_CMD_DIAG_CFG_OUT_STRUCT                    /* response packet structure */
 #define CGBC_DIAG_CFG_UPDATE    0x80   /* current config update request      */
 #define CGBC_DIAG_EEP_UPDATE    0x40   /* EEPROM parameter update request    */
 
-#define CGBC_DIAG_RES_MSK    0x30        /* reserved / must be zero */ //MOD044
+#define CGBC_DIAG_UART_MUX_M    0x20     /* UART mux config bit     */ //MOD055
+#define  CGBC_DIAG_UART_MUX_cBC  0x00    /*  - cBC UART selected    */ //MOD055
+#define  CGBC_DIAG_UART_MUX_SoC  0x20    /*  - SoC UART selected    */ //MOD055
 
-#define CGBC_DIAG_IF_MSK     0x0F        /* diag console I/F select */ //MOD044
-#define  CGBC_DIAG_CON_OFF    0x00       /*   - diagnostic console disabled  */
-#define  CGBC_DIAG_CON_AUX    0x01       /*   - auxiliary serial port        */
-#define  CGBC_DIAG_CON_SER0   0x02       /*   - system serial port 0         */
-#define  CGBC_DIAG_CON_SER1   0x03       /*   - system serial port 1         */
-#define  CGBC_DIAG_CON_I2C0   0x08       /*   - primary I2C-bus     */ //MOD044
-#define  CGBC_DIAG_CON_SMB0   0x0A       /*   - primary SMBus       */ //MOD044
+#define CGBC_DIAG_DHCC_ENA      0x10     /* DHCC enable             */ //MOD053
+
+#define CGBC_DIAG_IF_MSK        0x0F     /* diag console I/F select */ //MOD044
+#define  CGBC_DIAG_CON_OFF       0x00    /*   - diagnostic console disabled  */
+#define  CGBC_DIAG_CON_AUX       0x01    /*   - auxiliary serial port        */
+#define  CGBC_DIAG_CON_SER0      0x02    /*   - system serial port 0         */
+#define  CGBC_DIAG_CON_SER1      0x03    /*   - system serial port 1         */
+#define  CGBC_DIAG_CON_I2C0      0x08    /*   - primary I2C-bus     */ //MOD044
+#define  CGBC_DIAG_CON_SMB0      0x0A    /*   - primary SMBus       */ //MOD044
                                                                    /*      ^ */
                                                                    /* MOD041 */
                                                                       //MOD045v
@@ -2200,7 +2358,7 @@ CGBC_CMD_PWROK_DELAY_OUT_STRUCT                 /* response packet structure */
 #define CGBC_LOG_TAG_HOST_EV0    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 0) /* no additional data */
 
 /* tags for events with one data byte */
-#define CGBC_LOG_TAG_HOST_EV1    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by event byte*/
+#define CGBC_LOG_TAG_HOST_EV1    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by event byte */
 #define CGBC_LOG_TAG_PIN_HI      (( 1 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by pin # */
 #define CGBC_LOG_TAG_PIN_LO      (( 2 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by pin # */
                                                                    /* MOD047 */
@@ -2210,15 +2368,29 @@ CGBC_CMD_PWROK_DELAY_OUT_STRUCT                 /* response packet structure */
 #define CGBC_LOG_TAG_POST_CH3    (( 5 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by POST code */
                                                                    /*      ^ */
                                                                    /* MOD047 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_VIR_HI      (( 6 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by logical pin function */
+#define CGBC_LOG_TAG_VIR_LO      (( 7 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by logical pin function */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
 /* tags for events with two data bytes */
 #define CGBC_LOG_TAG_HOST_EV2    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 2) /* followed by event word */
 #define CGBC_LOG_TAG_ANALOG      (( 1 << 5) | CGBC_LOG_TAG_NOTS | 2) /* followed by ADC channel/value */
-
+                                                                   /* MOD067 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_SYS_EV      (( 2 << 5) | CGBC_LOG_TAG_NOTS | 2) /* followed by group/event */
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
 /* tags for events with three data bytes */
 #define CGBC_LOG_TAG_HOST_EV3    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 3) /* followed by three event bytes */
-
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_HWM_EV      (( 1 << 5) | CGBC_LOG_TAG_NOTS | 3) /* followed by HWM log ID/value */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
 /* tags for events with four data bytes */
-#define CGBC_LOG_TAG_HOST_EV4    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 4) /* followed by event dword*/
+#define CGBC_LOG_TAG_HOST_EV4    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 4) /* followed by event dword */
 #define CGBC_LOG_TAG_HOST_EV0_ST (( 0 << 5) | CGBC_LOG_TAG_SYST | 4) /* followed by system time stamp */
 #define CGBC_LOG_TAG_HOST_EV0_LT (( 0 << 5) | CGBC_LOG_TAG_LOGT | 4) /* followed by logging time stamp */
 
@@ -2240,18 +2412,67 @@ CGBC_CMD_PWROK_DELAY_OUT_STRUCT                 /* response packet structure */
 #define CGBC_LOG_TAG_POST_CH3_LT (( 5 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by POST code and logging time stamp */
                                                                    /*      ^ */
                                                                    /* MOD047 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_VIR_HI_ST   (( 6 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by ogical pin function and system time stamp */
+#define CGBC_LOG_TAG_VIR_HI_LT   (( 6 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by ogical pin function and logging time stamp */
+#define CGBC_LOG_TAG_VIR_LO_ST   (( 7 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by ogical pin function and system time stamp */
+#define CGBC_LOG_TAG_VIR_LO_LT   (( 7 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by ogical pin function and logging time stamp */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
 /* tags for events with six data bytes */
 #define CGBC_LOG_TAG_HOST_EV6    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 6) /* followed by six event bytes */
 #define CGBC_LOG_TAG_HOST_EV2_ST (( 0 << 5) | CGBC_LOG_TAG_SYST | 6) /* followed by event word and system time stamp */
 #define CGBC_LOG_TAG_HOST_EV2_LT (( 0 << 5) | CGBC_LOG_TAG_LOGT | 6) /* followed by event word and logging time stamp */
 #define CGBC_LOG_TAG_ANALOG_ST   (( 1 << 5) | CGBC_LOG_TAG_SYST | 6) /* followed by ADC channel/value and system time stamp */
 #define CGBC_LOG_TAG_ANALOG_LT   (( 1 << 5) | CGBC_LOG_TAG_LOGT | 6) /* followed by ADC channel/value and logging time stamp */
-
+                                                                   /* MOD067 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_SYS_EV_ST   (( 2 << 5) | CGBC_LOG_TAG_SYST | 6) /* followed by group/event and logging time stamp */
+#define CGBC_LOG_TAG_SYS_EV_LT   (( 2 << 5) | CGBC_LOG_TAG_LOGT | 6) /* followed by group/event and logging time stamp */
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
 /* tags for events with seven data bytes */
 #define CGBC_LOG_TAG_HOST_EV7    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 7) /* followed by seven event bytes */
 #define CGBC_LOG_TAG_HOST_EV3_ST (( 0 << 5) | CGBC_LOG_TAG_SYST | 7) /* followed by three event bytes and system time stamp */
 #define CGBC_LOG_TAG_HOST_EV3_LT (( 0 << 5) | CGBC_LOG_TAG_LOGT | 7) /* followed by three event bytes and logging time stamp */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_HWM_EV_ST   (( 1 << 5) | CGBC_LOG_TAG_SYST | 7) /* followed by HWM log ID/value and system time stamp */
+#define CGBC_LOG_TAG_HWM_EV_LT   (( 1 << 5) | CGBC_LOG_TAG_LOGT | 7) /* followed by HWM log ID/value and logging time stamp */
 
+/* HWM log IDs */
+#define CGBC_LOG_HWM_VIN 0 /* voltage on the runtime power input rail */
+#define CGBC_LOG_HWM_VSB 1 /* voltage on the standby power input rail */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+                                                                   /* MOD067 */
+                                                                   /*      v */
+/* system event groups */
+#define CGBC_LOG_ESPI_EV 0
+
+/* eSPI events */
+#define CGBC_LOG_ESPI_RST_HI       0x00
+#define CGBC_LOG_ESPI_RST_LO       0x01
+#define CGBC_LOG_ESPI_VW_ON        0x02
+#define CGBC_LOG_ESPI_OOB_OFF      0x03
+#define CGBC_LOG_ESPI_OOB_ON       0x04
+#define CGBC_LOG_ESPI_FLS_OFF      0x05
+#define CGBC_LOG_ESPI_FLS_ON       0x06
+#define CGBC_LOG_ESPI_PC_OFF       0x07
+#define CGBC_LOG_ESPI_PC_ON        0x08
+#define CGBC_LOG_ESPI_OOBRSTWRN_HI 0x09
+#define CGBC_LOG_ESPI_OOBRSTWRN_LO 0x0A
+#define CGBC_LOG_ESPI_OOBRSTACK_HI 0x0B
+#define CGBC_LOG_ESPI_OOBRSTACK_LO 0x0C
+#define CGBC_LOG_ESPI_HSTRSTWRN_HI 0x0D
+#define CGBC_LOG_ESPI_HSTRSTWRN_LO 0x0E
+#define CGBC_LOG_ESPI_HSTRSTACK_HI 0x0F
+#define CGBC_LOG_ESPI_HSTRSTACK_LO 0x10
+#define CGBC_LOG_ESPI_LPCPDn_HI    0x11
+#define CGBC_LOG_ESPI_LPCPDn_LO    0x12
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
 /* log buffer entry structures */
 typedef struct
 CGBC_EVENT_B_STRUCT   { uint8_t   ui8Tag;
@@ -2259,6 +2480,20 @@ CGBC_EVENT_B_STRUCT   { uint8_t   ui8Tag;
 typedef struct
 CGBC_EVENT_W_STRUCT   { uint8_t   ui8Tag;
                         uint16_t ui16Dat;     } cgbc_event_w_t;
+                                                                   /* MOD067 */
+                                                                   /*      v */
+typedef struct
+CGBC_EVENT_B2_STRUCT  { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[2];  } cgbc_event_b2_t;
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+typedef struct
+CGBC_EVENT_B3_STRUCT  { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[3];  } cgbc_event_b3_t;
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
 typedef struct
 CGBC_EVENT_D_STRUCT   { uint8_t   ui8Tag; 
                         uint32_t ui32Dat;     } cgbc_event_d_t;
@@ -2273,6 +2508,14 @@ typedef struct
 CGBC_EVENT_WT_STRUCT  { uint8_t   ui8Tag;
                         uint16_t ui16Dat;
                         uint32_t ui32Tim;     } cgbc_event_wt_t;
+                                                                   /* MOD067 */
+                                                                   /*      v */
+typedef struct
+CGBC_EVENT_B2T_STRUCT { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[2];
+                        uint32_t ui32Tim;     } cgbc_event_b2t_t;
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
 typedef struct
 CGBC_EVENT_B3T_STRUCT { uint8_t   ui8Tag;
                         uint8_t  aui8Dat[3];
@@ -2344,8 +2587,14 @@ CGBC_CMD_LOG_CFG_OUT_STRUCT
 /* Event logging flag parameter bit mapping */
                                                                    /* MOD047 */
                                                                    /*      v */
-#define CGBC_LOG_FLG_RES_M   0xFFFF007C    /* reserved / must be zero        */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_FLG_RES_M   0xFF000030    /* reserved / must be zero        */
 
+#define CGBC_LOG_VIRT_SIG_M  0x00FF0000    /* specific virtual signal mask   */
+#define CGBC_LOG_VIRT_SIG_S  16            /* specific virt. signal shft cnt */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
 #define CGBC_LOG_POST_CODE_M 0x0000FF00    /* specific POST code mask        */
 #define CGBC_LOG_POST_CODE_S 8             /* specific POST code shift count */
 
@@ -2354,6 +2603,16 @@ CGBC_CMD_LOG_CFG_OUT_STRUCT
 #define CGBC_LOG_POST_SEL_ONE 0x00000080   /* select a specific POST code    */
                                                                    /*      ^ */
                                                                    /* MOD047 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_VIRT_SEL_M  0x00000040    /* virtual signal select mask     */
+#define CGBC_LOG_VIRT_SEL_ALL 0x00000000   /* select all virtual signals     */
+#define CGBC_LOG_VIRT_SEL_ONE 0x00000040   /* select a specific virt. signal */
+
+#define CGBC_LOG_VIRT_ENABLE 0x00000008    /* virtual signals logging enable */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+#define CGBC_LOG_PCTL_ENABLE 0x00000004    /* power control logging enable   */ /* MOD064 */
 #define CGBC_LOG_POST_ENABLE 0x00000002    /* POST code logging enable       */
 #define CGBC_LOG_GPIO_ENABLE 0x00000001    /* MCU pin logging enable         */
 
@@ -2570,7 +2829,11 @@ CGBC_CMD_PIN_FEAT_OUT_STRUCT
 #define CGBC_PIN_PUP_MSK 0x0800
 #define  CGBC_PIN_PUP_ENA 0x0800 /* pull-up enabled */
 #define  CGBC_PIN_PUP_DIS 0x0000 /* pull-up disabled */
-
+                                                                      //MOD054v
+#define CGBC_PIN_ODV_MSK 0x0800
+#define CGBC_PIN_ODV_FIX  0x0800 /* fixed voltage open-drain output pin */
+#define CGBC_PIN_ODV_TOL  0x0000 /* voltage tolerant open-drain output pin */
+                                                                      //MOD054^
 #define CGBC_PIN_MOD_MSK 0x0400
 #define  CGBC_PIN_MOD_OD  0x0400 /* open-drain mode */
 #define  CGBC_PIN_MOD_PP  0x0000 /* push-pull mode */
@@ -2712,8 +2975,38 @@ CGBC_CMD_PIN_FEAT_OUT_STRUCT
                                                                       //MOD048v
 #define  CGBC_PIN_FNC_V5A_CTL        0x77 /* V5A_CTL pin                     */
 #define  CGBC_PIN_FNC_HOST_RST_ACK   0x78 /* HOST_RST_ACK pin                */
-#define  CGBC_PIN_FNC_MAX            CGBC_PIN_FNC_HOST_RST_ACK
-                                                                      //MOD048^
+                                                                      //MOD052v
+#define  CGBC_PIN_FNC_I2C1_SDA       0x79 /* secondary I2C-bus 1 data        */
+#define  CGBC_PIN_FNC_I2C1_SCL       0x7A /* secondary I2C-bus 1 clock       */
+#define  CGBC_PIN_FNC_I2C1_ALERTn    0x7B /* secondary I2C-bus 1 alert       */
+#define  CGBC_PIN_FNC_IPMB_SDA       0x7C /* int. platform mgmt bus data     */
+#define  CGBC_PIN_FNC_IPMB_SCL       0x7D /* int. platform mgmt bus clock    */
+#define  CGBC_PIN_FNC_IPMB_ALERTn    0x7E /* int. platform mgmt bus alert    */
+#define  CGBC_PIN_FNC_UPDB_SDA       0x7F /* USB PD controller bus data      */
+#define  CGBC_PIN_FNC_UPDB_SCL       0x80 /* USB PD controller bus clock     */
+#define  CGBC_PIN_FNC_UPDB_ALERTn    0x81 /* USB PD controller bus alert     */
+#define  CGBC_PIN_FNC_PMBUS_MUX      0x82 /* PMBUS multiplexer control pin   */
+#define  CGBC_PIN_FNC_TESTn          0x83 /* system test mode pin            */
+#define  CGBC_PIN_FNC_VIN_PWROK      0x84 /* VIN power good pin              */
+#define  CGBC_PIN_FNC_RAPID_SHUTDOWN 0x85 /* rapid shutdown pin              */
+#define  CGBC_PIN_FNC_UART_MUX_PCHn  0x86 /* cBC/PCH UART mux control pin    */
+#define  CGBC_PIN_FNC_THRMn          0x87 /* THRM# pin                       */
+#define  CGBC_PIN_FNC_PROCHOTn       0x88 /* PROCHOT# pin                    */
+                                                                      //MOD060v
+#define  CGBC_PIN_FNC_SPD_SMB_MUX    0x89 /* SPD_SMB_MUX pin                 */
+                                                                      //MOD063v
+#define  CGBC_PIN_FNC_GSPI_INTn      0x8A /* GSPI client interrupt pin       */
+#define  CGBC_PIN_FNC_GSPI_DSEL      0x8B /* GSPI device selection pin       */
+                                                                      //MOD068v
+#define  CGBC_PIN_FNC_SUSPWRDNACK    0x8C /* SUSPWRDNACK pin                 */
+#define  CGBC_PIN_FNC_SLP_Mn         0x8D /* SLP_M# pin                      */
+#define  CGBC_PIN_FNC_SLP_LANn       0x8E /* SLP_LAN# pin                    */
+#define  CGBC_PIN_FNC_SLP_WLANn      0x8F /* SLP_WLAN# pin                   */
+                                                                      //MOD068^
+                                                                      //MOD069v
+#define  CGBC_PIN_FNC_BRD_PWR_EN     0x90 /* Board power enable pin          */
+#define  CGBC_PIN_FNC_MAX            CGBC_PIN_FNC_BRD_PWR_EN
+                                          //MOD048 MOD052 MOD060 MOD063 MOD069^
 /* reserved logical pin functions */
 #define  CGBC_PIN_FNC_RES0           0xE0 /* reserved logical pin function 0 */
 #define  CGBC_PIN_FNC_RES1           0xE1 /* reserved logical pin function 1 */
@@ -2747,19 +3040,103 @@ CGBC_CMD_PIN_FEAT_OUT_STRUCT
 #define  CGBC_PIN_NONE               0xFF /* unavailable pin                 */
                                                                       //MOD046^
 /* combined pin features */
-#define CGBC_PIN_PAD_MSK       (CGBC_PIN_TYP_MSK|CGBC_PIN_LOW_MSK|CGBC_PIN_PUP_MSK|CGBC_PIN_PDN_MSK|CGBC_PIN_DIR_MSK|CGBC_PIN_MOD_MSK|CGBC_PIN_LVL_MSK)
-#define CGBC_PIN_TRI           (CGBC_PIN_TYP_OFF|        0       |        0       |        0       |        0       |        0       |        0       )
-#define CGBC_PIN_ANA_INP       (CGBC_PIN_TYP_ANA|        0       |        0       |        0       |        0       |        0       |        0       )
-#define CGBC_PIN_DIG_INP_FLOAT (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_PUP_DIS|CGBC_PIN_PDN_DIS|CGBC_PIN_DIR_INP|        0       |        0       )
-#define CGBC_PIN_DIG_INP_PD    (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_PUP_DIS|CGBC_PIN_PDN_ENA|CGBC_PIN_DIR_INP|        0       |        0       )
-#define CGBC_PIN_DIG_INP_PU    (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_PUP_ENA|CGBC_PIN_PDN_DIS|CGBC_PIN_DIR_INP|        0       |        0       )
-#define CGBC_PIN_DIG_OUT_OD_HI (CGBC_PIN_TYP_DIG|CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_HI )
-#define CGBC_PIN_DIG_OUT_OD_LO (CGBC_PIN_TYP_DIG|CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_LO )
-#define CGBC_PIN_DIG_OUT_PP_HI (CGBC_PIN_TYP_DIG|CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_HI )
-#define CGBC_PIN_DIG_OUT_PP_LO (CGBC_PIN_TYP_DIG|CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_LO )
-#define CGBC_PIN_DIG_OUT_LZ_HI (CGBC_PIN_TYP_DIG|CGBC_PIN_LOW_DIS|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_HI )
-#define CGBC_PIN_DIG_OUT_LZ_LO (CGBC_PIN_TYP_DIG|CGBC_PIN_LOW_DIS|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_LO )
+                                                                      //MOD054v
+#define CGBC_PIN_PAD_MSK        (CGBC_PIN_TYP_MSK|CGBC_PIN_ODV_MSK|CGBC_PIN_LOW_MSK|CGBC_PIN_PUP_MSK|CGBC_PIN_PDN_MSK|CGBC_PIN_DIR_MSK|CGBC_PIN_MOD_MSK|CGBC_PIN_LVL_MSK)
+#define CGBC_PIN_TRI            (CGBC_PIN_TYP_OFF|        0       |        0       |        0       |        0       |        0       |        0       |        0       )
+#define CGBC_PIN_ANA_INP        (CGBC_PIN_TYP_ANA|        0       |        0       |        0       |        0       |        0       |        0       |        0       )
+#define CGBC_PIN_DIG_INP_FLOAT  (CGBC_PIN_TYP_DIG|        0       |        0       |CGBC_PIN_PUP_DIS|CGBC_PIN_PDN_DIS|CGBC_PIN_DIR_INP|        0       |        0       )
+#define CGBC_PIN_DIG_INP_PD     (CGBC_PIN_TYP_DIG|        0       |        0       |CGBC_PIN_PUP_DIS|CGBC_PIN_PDN_ENA|CGBC_PIN_DIR_INP|        0       |        0       )
+#define CGBC_PIN_DIG_INP_PU     (CGBC_PIN_TYP_DIG|        0       |        0       |CGBC_PIN_PUP_ENA|CGBC_PIN_PDN_DIS|CGBC_PIN_DIR_INP|        0       |        0       )
+#define CGBC_PIN_DIG_OUT_OD_HI  (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_FIX|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_OD_LO  (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_FIX|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_LO )
+#define CGBC_PIN_DIG_OUT_ODT_HI (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_TOL|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_ODT_LO (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_TOL|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_LO )
+#define CGBC_PIN_DIG_OUT_PP_HI  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_PP_LO  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_LO )
+#define CGBC_PIN_DIG_OUT_LZ_HI  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_DIS|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_LZ_LO  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_DIS|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_LO )
+                                                                      //MOD054^
+                                                                      //MOD063v
+/* ----------------------------------------
+ * CGBC_CMD_GSPI_CFG command definitions
+ * ------------------------------------- */
 
+/* command package structure */
+typedef struct
+CGBC_CMD_GSPI_CFG_IN_STRUCT
+{
+  uint8_t   ui8Cmd;         /* CGBC_CMD_GSPI_CFG                             */
+  uint8_t   ui8Cfg;         /* GSPI configuration byte. Including byte order,
+                             * operation mode, and duplex                    */
+  uint8_t   ui8SerIrqNum;   /* SERIRQ number which shall be allocated for the
+                             * GSPI transfer finished or GSPI client interrupt
+                             * SERIRQ to the host.                           */
+  uint32_t ui32Freq;        /* GSPI clock frequency to be configured. Any
+                             * frequency in Hz can be used. The configuration
+                             * routine automatically configures the next lowest
+                             * frequency which is supported by the controller*/
+  uint32_t ui32GspiSramBar;
+} CGBC_CMD_GSPI_CFG_IN, *P_CGBC_CMD_GSPI_CFG_IN;
+
+#define CGBC_GSPI_CFG_DUPLEX_POS                       0
+#define CGBC_GSPI_CFG_DUPLEX_MASK                   0x03
+#define CGBC_GSPI_CFG_DUPLEX_FULL                   0x00
+#define CGBC_GSPI_CFG_DUPLEX_HALF                   0x01
+#define CGBC_GSPI_CFG_DUPLEX_DUAL                   0x02
+
+#define CGBC_GSPI_GFG_MODE_POS                         2
+#define CGBC_GSPI_GFG_MODE_MASK                     0x0C
+#define CGBC_GSPI_CFG_MODE_00                       0x00
+#define CGBC_GSPI_CFG_MODE_01                       0x04
+#define CGBC_GSPI_CFG_MODE_10                       0x08
+#define CGBC_GSPI_CFG_MODE_11                       0x0C
+
+#define CGBC_GSPI_CFG_ENDIAN_POS                       4
+#define CGBC_GSPI_CFG_ENDIAN_MASK                   0x10
+#define CGBC_GSPI_CFG_ENDIAN_LIT                    0x00
+#define CGBC_GSPI_CFG_ENDIAN_BIG                    0x10
+
+#define CGBC_GSPI_CFG_UPD_POS                          5
+#define CGBC_GSPI_CFG_UPD_MASK                      0x20
+
+/* result package structure */
+typedef struct
+CGBC_CMD_GSPI_CFG_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;    /* CGBC status byte                              */
+  uint8_t   ui8Cfg;         /* Actually configured byte order, operation mode
+                             * and duplex in the GSPI controller             */
+  uint8_t   ui8SerIrqNum;   /* SERIRQ number allocated for the GSPI support  */
+  uint32_t ui32Freq;        /* Actually configured GSPI frequency in the GSPI
+                             * controller. It can deviate from the value in
+                             * the command because the controller only supports
+                             * certain frequencies. The configuration routine
+                             * will configure the next lowest frequency to the
+                             * desired one and returns iter_swap             */
+  uint32_t ui32GspiSramBar;
+} CGBC_CMD_GSPI_CFG_OUT, *P_CGBC_CMD_GSPI_CFG_OUT;
+
+#define CGBC_GSPI_CFG_MASK                          0x3F
+
+#define CGBC_GSPI_CLK_FREQ_MASK                     0x0F
+#define CGBC_GSPI_CLK_FREQ_15_9kHz                  0x00
+#define CGBC_GSPI_CLK_FREQ_333kHz                   0x01
+#define CGBC_GSPI_CLK_FREQ_500kHz                   0x02
+#define CGBC_GSPI_CLK_FREQ_1MHz                     0x03
+#define CGBC_GSPI_CLK_FREQ_381kHz                   0x04
+#define CGBC_GSPI_CLK_FREQ_6MHz                     0x05
+#define CGBC_GSPI_CLK_FREQ_12MHz                    0x06
+#define CGBC_GSPI_CLK_FREQ_24MHz                    0x07
+#define CGBC_GSPI_CLK_FREQ_48MHz                    0x08
+
+#define CGBC_GSPI_BYTE_ORDER_MASK                   0x10
+#define CGBC_GSPI_BYTE_ORDER_LITTLE_ENDIAN          0x00
+#define CGBC_GSPI_BYTE_ORDER_BIG_ENDIAN             0x10
+
+#define CGBC_GSPI_MODE_MASK                         0x20
+#define CGBC_GSPI_MODE_00                           0x00
+#define CGBC_GSPI_MODE_11                           0x20
+                                                                      //MOD063^
 /* -----------------------------------------
  * CGBC_CMD_DIAG_MODE command definitions
  * -------------------------------------- */
@@ -2904,6 +3281,89 @@ CGBC_CMD_GPIO_IRQ_TBL_OUT_STRUCT
 } CGBC_CMD_GPIO_IRQ_TBL_OUT, *P_CGBC_CMD_GPIO_IRQ_TBL_OUT;
                                                                       //MOD046^
 
+                                                                      //MOD061v
+/* ------------------------------------
+ * CGBC_CMD_AVR_SPM_EXT sub-commands
+ * --------------------------------- */
+
+#define CGBC_CMD_AVR_SPM_FLS_ADDR 0x00
+#define CGBC_CMD_AVR_SPM_FLS_STAT 0x01
+#define CGBC_CMD_AVR_SPM_FLS_RD32 0x02
+#define CGBC_CMD_AVR_SPM_FLS_WR32 0x03
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_ADDR command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_ADDR_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                             /* CGBC_CMD_AVR_SPM_EXT      */
+  uint8_t   ui8ExtCmd;                          /* CGBC_CMD_AVR_SPM_FLS_ADDR */
+  uint32_t ui32FlsAddr;                         /* target flash page address */
+} CGBC_CMD_AVR_SPM_FLS_ADDR_IN, *P_CGBC_CMD_AVR_SPM_FLS_ADDR_IN;
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_STAT command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_STAT_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                             /* CGBC_CMD_AVR_SPM_EXT      */
+  uint8_t   ui8ExtCmd;                          /* CGBC_CMD_AVR_SPM_FLS_STAT */
+} CGBC_CMD_AVR_SPM_FLS_STAT_IN, *P_CGBC_CMD_AVR_SPM_FLS_STAT_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_STAT_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                      /* CGBC status byte            */
+  uint8_t     ui8FlsCtlrSts;                  /* cBC flash controller status */
+  uint32_t   ui32FlsPageSiz;                  /* flash page size             */
+} CGBC_CMD_AVR_SPM_FLS_STAT_OUT, *P_CGBC_CMD_AVR_SPM_FLS_STAT_OUT;
+
+/* flash controller status definitions */
+#define CGBC_AVR_SPM_FLS_IDL 0x00      /* cBC flash controller is idle.      */
+#define CGBC_AVR_SPM_FLS_BSY 0x01      /* cBC flash controller is busy.      */
+#define CGBC_AVR_SPM_FLS_ERR 0x02      /* cBC flash controller has an error. */
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_RD32 command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_RD32_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                             /* CGBC_CMD_AVR_SPM_EXT      */
+  uint8_t   ui8ExtCmd;                          /* CGBC_CMD_AVR_SPM_FLS_RD32 */
+} CGBC_CMD_AVR_SPM_FLS_RD32_IN, *P_CGBC_CMD_AVR_SPM_FLS_RD32_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_RD32_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                                 /* CGBC status byte */
+  uint8_t    aui8RdDat[32];                              /* read data        */
+} CGBC_CMD_AVR_SPM_FLS_RD32_OUT, *P_CGBC_CMD_AVR_SPM_FLS_RD32_OUT;
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_WR32 command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_WR32_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                           /* CGBC_CMD_AVR_SPM_EXT        */
+  uint8_t   ui8ExtCmd;                        /* CGBC_CMD_AVR_SPM_FLS_WR32 */
+  uint8_t  aui8WrDat[32];                     /* write data                  */
+} CGBC_CMD_AVR_SPM_FLS_WR32_IN, *P_CGBC_CMD_AVR_SPM_FLS_WR32_IN;
+                                                                      //MOD061^
+																	  
 
 /*-------------------
  * SYNC return codes
@@ -2954,6 +3414,7 @@ typedef union CGBC_CMD_STRUCT
                 CGBC_CMD_TCNT_IN           tcntIn;                   //MOD021
                 CGBC_CMD_TCNT_OUT          tcntOut;                  //MOD021
                 CGBC_CMD_BOOT_TIME_OUT     btimOut;
+                CGBC_CMD_BOOT_TIME_OUT_32  btimOut32;                //MOD071
                 CGBC_CMD_DUMP_IN           dumpParms;
                 CGBC_CMD_RESET_INFO_OUT    resetOut;                 //MOD021
                 CGBC_CMD_POST_CODE_IN      postCodeIn;               //MOD040
@@ -3021,6 +3482,18 @@ typedef union CGBC_CMD_STRUCT
                 CGBC_CMD_WDOG_RD_IN        xWdogRdIn;                //MOD046
                 CGBC_CMD_GPIO_IRQ_TBL_IN   xGpioIrqTblIn;            //MOD046
                 CGBC_CMD_GPIO_IRQ_TBL_OUT  xGpioIrqTblOut;           //MOD046
+                CGBC_CMD_I2C_START_EXT_IN  xI2cStartExtIn;           //MOD059
+                CGBC_CMD_I2C_STAT_EXT_IN   xI2cStatExtIn;            //MOD059
+                CGBC_CMD_I2C_DATA_EXT_IN   xI2cDataExtIn;            //MOD059
+                CGBC_CMD_I2C_SPEED_EXT_IN  xI2cSpeedExtIn;           //MOD059
+                CGBC_CMD_AVR_SPM_FLS_ADDR_IN  xAvrSpmFlsAddr;        //MOD061
+                CGBC_CMD_AVR_SPM_FLS_STAT_IN  xAvrSpmFlsStatIn;      //MOD061
+                CGBC_CMD_AVR_SPM_FLS_STAT_OUT xAvrSpmFlsStatOut;     //MOD061
+                CGBC_CMD_AVR_SPM_FLS_RD32_IN  xAvrSpmFlsRd32In;      //MOD061
+                CGBC_CMD_AVR_SPM_FLS_RD32_OUT xAvrSpmFlsRd32Out;     //MOD061
+                CGBC_CMD_AVR_SPM_FLS_WR32_IN  xAvrSpmFlsWr32;        //MOD061
+                CGBC_CMD_GSPI_CFG_IN       xGspiCfgIn;               //MOD063
+                CGBC_CMD_GSPI_CFG_OUT      xGspiCfgOut;              //MOD063
                 CGBC_CMD_SYNC_OUT          sync;
                } CGBC_CMD, *P_CGBC_CMD;
 
@@ -3036,20 +3509,22 @@ typedef union CGBC_CMD_STRUCT
 
 typedef struct HIF_INFO_STRUCT
 {
-  UINT32      id;                  /* HIF_ID                                 */
-  UINT8       infoRev;             /* info structure revision                */
-  UINT8       infoSize;            /* structure size in bytes                */
-  UINT8       flags;               /* host interface control flags           */
-  UINT8       res7;                /* reserved (offset 0x07)                 */
-  UINT32      ctrlBase;            /* control block base address             */
-  UINT32      shBase;              /* shared command channel base address    */
-  UINT32      exBase;              /* exclusive command channel base address */
-  UINT8       shSize;              /* shared command channel size            */
-  UINT8       shIrq;               /* shared command channel IRQ control     */
-  UINT8       exSize;              /* exclusive command channel size         */
-  UINT8       exIrq;               /* exclusive command channel IRQ control  */
+                                                                     //MOD070v
+  uint32_t    id;                  /* HIF_ID                                 */
+  uint8_t     infoRev;             /* info structure revision                */
+  uint8_t     infoSize;            /* structure size in bytes                */
+  uint8_t     flags;               /* host interface control flags           */
+  uint8_t     res7;                /* reserved (offset 0x07)                 */
+  uint32_t    ctrlBase;            /* control block base address             */
+  uint32_t    shBase;              /* shared command channel base address    */
+  uint32_t    exBase;              /* exclusive command channel base address */
+  uint8_t     shSize;              /* shared command channel size            */
+  uint8_t     shIrq;               /* shared command channel IRQ control     */
+  uint8_t     exSize;              /* exclusive command channel size         */
+  uint8_t     exIrq;               /* exclusive command channel IRQ control  */
   CGBC_FW_REV fwRev;               /* CGBC firmware revision information     */
-  UINT32      res1C;               /* reserved (offset 0x1C)                 */
+  uint32_t    res1C;               /* reserved (offset 0x1C)                 */
+                                                                     //MOD070^
 } HIF_INFO, *P_HIF_INFO;
 
 #endif //!__ASSEMBLER__
diff --git a/CgosDrv/COPYING_GPL2 b/CgosDrv/COPYING_GPL2
old mode 100755
new mode 100644
diff --git a/CgosDrv/Cgeb.h b/CgosDrv/Cgeb.h
old mode 100755
new mode 100644
index c06c132..5565dbe
--- a/CgosDrv/Cgeb.h
+++ b/CgosDrv/Cgeb.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/CgebEmu.c b/CgosDrv/CgebEmu.c
old mode 100755
new mode 100644
index bfd51c3..94a2552
--- a/CgosDrv/CgebEmu.c
+++ b/CgosDrv/CgebEmu.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/CgebFct.h b/CgosDrv/CgebFct.h
old mode 100755
new mode 100644
index c9ec4d3..ec3fced
--- a/CgosDrv/CgebFct.h
+++ b/CgosDrv/CgebFct.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/CgebSda.h b/CgosDrv/CgebSda.h
old mode 100755
new mode 100644
index 639f95d..af34eb6
--- a/CgosDrv/CgebSda.h
+++ b/CgosDrv/CgebSda.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/CgosDef.h b/CgosDrv/CgosDef.h
old mode 100755
new mode 100644
index 0a820e7..06469c2
--- a/CgosDrv/CgosDef.h
+++ b/CgosDrv/CgosDef.h
@@ -1,3 +1,27 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
 // CgosDef.h
 // CGOS library header files
 // {G)U(2} 2005.06.22
diff --git a/CgosDrv/CgosDrv.c b/CgosDrv/CgosDrv.c
old mode 100755
new mode 100644
index 3065192..d75aae0
--- a/CgosDrv/CgosDrv.c
+++ b/CgosDrv/CgosDrv.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2020, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -35,7 +35,7 @@
 
 //***************************************************************************
 
-#define dbg_on
+//#define dbg_on
 
 #ifdef dbg_on
 	#define dbg(x) x
diff --git a/CgosDrv/CgosDrv.h b/CgosDrv/CgosDrv.h
old mode 100755
new mode 100644
index 4a9860e..b736330
--- a/CgosDrv/CgosDrv.h
+++ b/CgosDrv/CgosDrv.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -20,7 +20,7 @@
  * http://opensource.org/licenses/GPL-2.0
  *
  *---------------------------------------------------------------------------
- */ 
+ */
 
 //***************************************************************************
 
diff --git a/CgosDrv/DrvOsa.h b/CgosDrv/DrvOsa.h
old mode 100755
new mode 100644
index 342f741..9044f13
--- a/CgosDrv/DrvOsa.h
+++ b/CgosDrv/DrvOsa.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/DrvOsaM.c b/CgosDrv/DrvOsaM.c
old mode 100755
new mode 100644
index 1aad553..eda31a0
--- a/CgosDrv/DrvOsaM.c
+++ b/CgosDrv/DrvOsaM.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/DrvUla.h b/CgosDrv/DrvUla.h
old mode 100755
new mode 100644
index bfa8915..359fc5b
--- a/CgosDrv/DrvUla.h
+++ b/CgosDrv/DrvUla.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/DrvVars.h b/CgosDrv/DrvVars.h
old mode 100755
new mode 100644
index 8ded6c4..17d12c9
--- a/CgosDrv/DrvVars.h
+++ b/CgosDrv/DrvVars.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -40,9 +40,11 @@
 #define CGOS_DRV_FAN_MAX 16
 #define CGOS_DRV_I2C_TABLE_MAX 32
 
-#define BC_TYPE_GEN5 0x00
-#define BC_TYPE_BC4_BASE_E 0x01
-#define BC_TYPE_BC4_BASE_C 0x02
+//MOD24 v
+#define BC_TYPE_GEN5 0x01
+#define BC_TYPE_BC4_BASE_E 0x02
+#define BC_TYPE_BC4_BASE_C 0x03
+//MOD24 ^
 //***************************************************************************
 
 typedef struct {
diff --git a/CgosDrv/Lx/Config.in b/CgosDrv/Lx/Config.in
old mode 100755
new mode 100644
diff --git a/CgosDrv/Lx/DrvLx.c b/CgosDrv/Lx/DrvLx.c
old mode 100755
new mode 100644
index 654c4e2..8a0d88b
--- a/CgosDrv/Lx/DrvLx.c
+++ b/CgosDrv/Lx/DrvLx.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Lx/DrvOsHdr.h b/CgosDrv/Lx/DrvOsHdr.h
old mode 100755
new mode 100644
index 0bbd8f1..8ec603c
--- a/CgosDrv/Lx/DrvOsHdr.h
+++ b/CgosDrv/Lx/DrvOsHdr.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -32,7 +32,12 @@
 #define AMD64
 #endif
 
-#include <stddef.h>
+//MOD24 v 
+
+//#include <stddef.h> 
+typedef int wchar_t;
+
+//MOD24 ^
 
 //***************************************************************************
 
diff --git a/CgosDrv/Lx/DrvOsaLx.c b/CgosDrv/Lx/DrvOsaLx.c
old mode 100755
new mode 100644
index cf6a5a3..b774851
--- a/CgosDrv/Lx/DrvOsaLx.c
+++ b/CgosDrv/Lx/DrvOsaLx.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -49,7 +49,11 @@
 
 cgos_cdecl void OsaSleepms(void *ctx, unsigned int ms)
   {
+  #if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,9)
   current->state=TASK_INTERRUPTIBLE;
+  #else
+  set_current_state(TASK_INTERRUPTIBLE);
+  #endif
   schedule_timeout((ms*HZ+999)/1000);
   }
 
diff --git a/CgosDrv/Lx/Kconfig b/CgosDrv/Lx/Kconfig
old mode 100755
new mode 100644
diff --git a/CgosDrv/Lx/Makefile b/CgosDrv/Lx/Makefile
old mode 100755
new mode 100644
diff --git a/CgosDrv/Lx/built-in.a b/CgosDrv/Lx/built-in.a
old mode 100755
new mode 100644
diff --git a/CgosDrv/Lx/cgosdrv.mod b/CgosDrv/Lx/cgosdrv.mod
old mode 100755
new mode 100644
index 5ed0fea..680d3ce
--- a/CgosDrv/Lx/cgosdrv.mod
+++ b/CgosDrv/Lx/cgosdrv.mod
@@ -1,2 +1,2 @@
-/home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/DrvLx.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/DrvOsaLx.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../CgosDrv.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/BCModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/BoardModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/HWMModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/I2CModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/IOModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/StoModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/VgaModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/WDModule.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/IOSubModules/IOSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/IOSubModules/IOSubModule_CSAS.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/I2CSubModules/I2CSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/WDSubModules/WDSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/HWMSubModules/HWMSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/HWMSubModules/HWMSubModule_CSAS.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/VgaSubModules/VgaSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/StoSubModules/StoSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/BCSubModules/BCSubModule_BC4_BASE_C.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/BCSubModules/BCSubModule_BC4_BASE_E.o /home/congatec/Desktop/CGOS_DIRECT_0020_Linux_Release_Candidate/CgosDrv/Lx/../Modules/BCSubModules/BCSubModule_GEN5.o
+/home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/DrvLx.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/DrvOsaLx.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../CgosDrv.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/BCModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/BoardModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/HWMModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/I2CModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/IOModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/StoModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/VgaModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/WDModule.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/IOSubModules/IOSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/I2CSubModules/I2CSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/WDSubModules/WDSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/HWMSubModules/HWMSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/VgaSubModules/VgaSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/StoSubModules/StoSubModule_BC.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/BCSubModules/BCSubModule_BC4_BASE_C.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/BCSubModules/BCSubModule_BC4_BASE_E.o /home/congatec/Desktop/CGOS_DIRECT_Lx_common_R2.00.0023/CgosDrv/Lx/../Modules/BCSubModules/BCSubModule_GEN5.o
 
diff --git a/CgosDrv/Lx/readme b/CgosDrv/Lx/readme
old mode 100755
new mode 100644
diff --git a/CgosDrv/Modules.h b/CgosDrv/Modules.h
old mode 100755
new mode 100644
index f221cbc..42b4fe0
--- a/CgosDrv/Modules.h
+++ b/CgosDrv/Modules.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BCModule.c b/CgosDrv/Modules/BCModule.c
old mode 100755
new mode 100644
index 90844e7..10a3203
--- a/CgosDrv/Modules/BCModule.c
+++ b/CgosDrv/Modules/BCModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -38,7 +38,7 @@
 
 //***************************************************************************
 
-#define dbg_bc_on
+//#define dbg_bc_on
 
 #ifdef dbg_bc_on
 	#define dbgbc(x) x
@@ -331,23 +331,40 @@ unsigned int BCChangeSubModule(CGOS_DRV_VARS *cdv, unsigned char NewSubModule)
   unsigned int GetBoardControllerType(CGOS_DRV_VARS *cdv)
  {
  #ifdef __linux__
+	unsigned char Letter;
 	const char *value;
 	char Board[4] = {0};
 	int i;
 
 	//Get Project Code	
-	value = dmi_get_system_info(DMI_ENTRY_BASEBOARD);
+	value = dmi_get_system_info(DMI_BIOS_VERSION);
 	for(i = 0; i < 4; i++)
 	{
-		if((value + i) != NULL)
+		if ((value + i) != NULL)		//MOD23 v
 		{
-			Board[i] = *(value + i);
-			cdv->brd->BoardName[i] = *(value + i); //CGOSBOARDINFOs Project Code field (information from BC) could be used instead if smbios information
-		}
+			Letter = *(value + i);
+			if ((Letter >= 0x30) && (Letter <= 0x39)) //Letter is ASCII Number
+			{
+				Board[i] = Letter;
+				cdv->brd->BoardName[i] = Letter;
+			}
+			else if ((Letter >= 0) && (Letter <= 9)) //Letter is int Number
+			{
+				//convert to ASCII
+				Board[i] = Letter + 0x30; 
+				cdv->brd->BoardName[i] = Letter + 0x30; 
+			}
+			else //Letter is no number
+			{
+				Board[i] = *(value + i);
+				cdv->brd->BoardName[i] = *(value + i); //CGOSBOARDINFOs Project Code field (information from BC) could be used instead if smbios information
+			}
+		}								//MOD23 ^
 		else
 		{
 			return CGOS_ERROR;
 		}
+		
 	}
 	
 	//Check if BC4 Base E
@@ -407,27 +424,34 @@ unsigned int initBCModule(CGOS_DRV_VARS *cdv)
 	RegisterBCSubModule_BC4_BASE_C(BCRegisterSubModule,BC_SUBMODULE_BC4_BASE_C);
 	RegisterBCSubModule_GEN5(BCRegisterSubModule,BC_SUBMODULE_GEN5);
 
-	retSuccess = GetBoardControllerType(cdv);
-	
-	if(retSuccess == CGOS_SUCCESS)
-	{
+//MOD23 v
+#ifdef __linux__	
+	GetBoardControllerType(cdv);
+#else
+	//cdv->brd->BC_Type = BC_TYPE_BC4_BASE_C;
+	//cdv->brd->BC_Type = BC_TYPE_BC4_BASE_E;
+	cdv->brd->BC_Type = BC_TYPE_GEN5;
+#endif
+
 		switch(cdv->brd->BC_Type)
 		{
 			case BC_TYPE_BC4_BASE_C:	BCSetDefaultSubModule(BC_SUBMODULE_BC4_BASE_C);
 							break;
 			case BC_TYPE_BC4_BASE_E:	BCSetDefaultSubModule(BC_SUBMODULE_BC4_BASE_E);
 							break;
-			case BC_TYPE_GEN5:	//Assume that it's a GEN5 BC if no BC4 is found	
-			default: BCSetDefaultSubModule(BC_SUBMODULE_GEN5);
+			case BC_TYPE_GEN5:			BCSetDefaultSubModule(BC_SUBMODULE_GEN5);
+							break;
+			default:					cdv->brd->BC_Type = BC_TYPE_GEN5; //In case no BC Type was found, default to GEN5
+										BCSetDefaultSubModule(BC_SUBMODULE_GEN5);
 		}
-	}
-	
+//MOD23 ^
+
 	//Initialize active SubModule
 	if(retSuccess == CGOS_SUCCESS)
 	{
 		if(BCFirstListItem->Functions.initSubModule != NULL)
 		{
-			(BCFirstListItem->Functions.initSubModule)(cdv);
+			retSuccess = (BCFirstListItem->Functions.initSubModule)(cdv);
 		}
 	}
 
diff --git a/CgosDrv/Modules/BCModule.h b/CgosDrv/Modules/BCModule.h
old mode 100755
new mode 100644
index 768d4a4..ad3c2f9
--- a/CgosDrv/Modules/BCModule.h
+++ b/CgosDrv/Modules/BCModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BCModule_cfg.h b/CgosDrv/Modules/BCModule_cfg.h
old mode 100755
new mode 100644
index a9568b2..62bb40e
--- a/CgosDrv/Modules/BCModule_cfg.h
+++ b/CgosDrv/Modules/BCModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -107,7 +107,7 @@ BoardName BC4_BASE_C_LIST[BC4_BASE_C_COUNT] = {
 							{{'C','S','A','S'}}
 						};
 						
-#define GEN5_COUNT 27
+#define GEN5_COUNT 40
 
 BoardName GEN5_LIST[GEN5_COUNT] = {
 					{{'T','S','C','O'}},
@@ -120,6 +120,15 @@ BoardName GEN5_LIST[GEN5_COUNT] = {
 					{{'G','A','T','L'}},
 						{{'G','U','T','L'}},
 						{{'G','V','T','L'}},
+					{{'T','C','T','O'}},
+						{{'B','V','T','O'}},
+						{{'B','U','T','O'}},
+					{{'T','S','T','L'}},
+						{{'B','H','T','L'}},
+						{{'B','Q','T','L'}},
+					{{'G','B','T','L'}},
+						{{'G','Q','T','L'}},
+						{{'G','H','T','L'}},
 					{{'B','7','E','3'}},
 					{{'B','7','E','4'}},
 					{{'S','A','7','0'}},
@@ -136,6 +145,10 @@ BoardName GEN5_LIST[GEN5_COUNT] = {
 					{{'T','C','W','L'}},
 						{{'B','U','W','L'}},
 						{{'B','V','W','L'}},
-					{{'H','S','I','L'}}
+					{{'H','S','I','L'}},
+					{{'T','C','V','2'}},
+					{{'D','I','C','L'}},
+					{{'T','C','A','L'}},
+					{{'H','E','I','H'}}
 				   };									  
 #endif
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.c b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.c
old mode 100755
new mode 100644
index eb41e73..d193635
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.c
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -135,7 +135,7 @@ unsigned int RegisterBCSubModule_BC4_BASE_C(unsigned int (*RegisterSubModule)(	C
  ***********************************************************************/  
 unsigned int Probe_BC4_BASE_C(CGOS_DRV_VARS *cdv)
 {
-	unsigned int BASE = 0x0C38;
+	/*unsigned int BASE = 0x0C38;
 	unsigned char rbuf[136];
 	unsigned int i;
 	
@@ -151,7 +151,7 @@ unsigned int Probe_BC4_BASE_C(CGOS_DRV_VARS *cdv)
 	{
 		return CGOS_SUCCESS;
 	}
-	
+	*/
 	return CGOS_ERROR;
 }
 
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.h b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.h
old mode 100755
new mode 100644
index 4fce82b..139fa50
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.h
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_C.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.c b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.c
old mode 100755
new mode 100644
index 1096abd..c89cc9d
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.c
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -135,7 +135,7 @@ unsigned int RegisterBCSubModule_BC4_BASE_E(unsigned int (*RegisterSubModule)(	C
  ***********************************************************************/  
 unsigned int Probe_BC4_BASE_E(CGOS_DRV_VARS *cdv)
 {
-	unsigned int BASE = 0x0E38;
+	/*unsigned int BASE = 0x0E38;
 	unsigned char rbuf[136];
 	unsigned int i;
 	
@@ -151,7 +151,7 @@ unsigned int Probe_BC4_BASE_E(CGOS_DRV_VARS *cdv)
 	{
 		return CGOS_SUCCESS;
 	}
-	
+	*/
 	return CGOS_ERROR;
 }
 
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.h b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.h
old mode 100755
new mode 100644
index 35269e7..0274c71
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.h
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_BASE_E.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_cfg.h b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_cfg.h
old mode 100755
new mode 100644
index 62a73f1..5c5574f
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_cfg.h
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_BC4_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.c b/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.c
old mode 100755
new mode 100644
index 11b3b5f..d32b99e
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.c
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -109,22 +109,30 @@ unsigned int exitSubModule_GEN5(CGOS_DRV_VARS *cdv);
 //***************************************************************************
 //		Helper Functions for Gen5 bcCommand
 
-void OccupyGen5Hcnm(void)
+unsigned int OccupyGen5Hcnm(void) //MOD HMI
 {
+	unsigned int i = 0; //MOD HMI
 	dbgbc("OccupyGen5Hcnm called\n");
 	for (;;)
 	{
 		while (inw(gen5HcnmBaseAddr + GEN5_HCNM_STATUS) != GEN5_HCNM_FREE)
 		{
+			//MOD HMI v
+			if (i > 100000)
+			{
+				return CGOS_ERROR;
+			}
+			i++;
+			//MOD HMI ^
 			//bsy
 		}
 		if (inl(gen5HcnmBaseAddr + GEN5_HCNM_ACCESS) == GEN5_HCNM_GAINED)
 		{
-			return;
+			return CGOS_SUCCESS; //MOD HMI
 		}
 		else
 		{
-			//failed
+			return CGOS_ERROR; //MOD HMI
 		}
 	}
 }
@@ -144,18 +152,25 @@ unsigned int Gen5HcnmCommand(unsigned int ui8Cmd)
 	return (inb(gen5HcnmBaseAddr + GEN5_HCNM_DATA));
 }
 
-void ObtainGen5ClientNumber(void)
+unsigned int ObtainGen5ClientNumber(void)
 {
+	unsigned int retSuccess = CGOS_SUCCESS;	//MOD HMI
 	dbgbc("ObtainGen5ClientNumber called\n");
-	OccupyGen5Hcnm();
-	gen5ClientNum = OsaMemAlloc(sizeof(unsigned int));
-	*gen5ClientNum = Gen5HcnmCommand(GEN5_HCNM_REQUEST);
-	outw(GEN5_HCNM_FREE, gen5HcnmBaseAddr + GEN5_HCNM_STATUS);
+	retSuccess = OccupyGen5Hcnm();
 
-	if ((*gen5ClientNum < 0x02) || (*gen5ClientNum > 0xFE))
+	if (retSuccess == CGOS_SUCCESS)
 	{
-		dbgbc("CGBC_ERR: noHcnMsg\n");
+		gen5ClientNum = OsaMemAlloc(sizeof(unsigned int));
+		*gen5ClientNum = Gen5HcnmCommand(GEN5_HCNM_REQUEST);
+		outw(GEN5_HCNM_FREE, gen5HcnmBaseAddr + GEN5_HCNM_STATUS);
+
+		if ((*gen5ClientNum < 0x02) || (*gen5ClientNum > 0xFE))
+		{
+			dbgbc("CGBC_ERR: noHcnMsg\n");
+			retSuccess = CGOS_ERROR;	//MOD HMI
+		}
 	}
+	return retSuccess; //MOD HMI
 }
 
 void ReleaseGen5ClientNumber(void)
@@ -226,10 +241,11 @@ unsigned int RegisterBCSubModule_GEN5(unsigned int (*RegisterSubModule)(	CgosFun
  ***********************************************************************/
 unsigned int initSubModule_GEN5(CGOS_DRV_VARS *cdv)
 {
+	unsigned int retSuccess = CGOS_SUCCESS;
 	dbgbc("initBCSubModule_GEN5 called\n");
 
-	ObtainGen5ClientNumber();
-	return CGOS_SUCCESS;
+	retSuccess = ObtainGen5ClientNumber();
+	return retSuccess;
 }
 
 /***********************************************************************
@@ -434,7 +450,6 @@ unsigned int CgosCgbcGetInfo_GEN5(CGOS_DRV_VARS *cdv)
 	bcInfo.size = sizeof(CGOSBCINFO);
 
 	dbgbc("CgosCgbcGetInfo_GEN5 called\n");
-	printk("CgosCgbcGetInfo_GEN5 called\n");
 	OsaMemCpy(cdv->pout, &bcInfo, sizeof(CGOSBCINFO));
 	cdv->retcnt += sizeof(CGOSBCINFO); 
 
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.h b/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.h
old mode 100755
new mode 100644
index 8425073..5557187
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.h
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5_cfg.h b/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5_cfg.h
old mode 100755
new mode 100644
index 3364593..0243e66
--- a/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5_cfg.h
+++ b/CgosDrv/Modules/BCSubModules/BCSubModule_GEN5_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BoardModule.c b/CgosDrv/Modules/BoardModule.c
old mode 100755
new mode 100644
index 86b1310..af194e5
--- a/CgosDrv/Modules/BoardModule.c
+++ b/CgosDrv/Modules/BoardModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2020, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -49,7 +49,7 @@ DbgPrintEx(
 
 //***************************************************************************
 
-#define dbgbrd_on
+//#define dbgbrd_on
 
 #ifdef dbgbrd_on
 #ifdef __linux__
@@ -233,7 +233,7 @@ unsigned int getBoardInfoFromBC(CGOS_DRV_VARS *cdv)
 	
 #ifdef __linux__
 	//BIOS Revision
-	value = dmi_get_system_info(DMI_ENTRY_BASEBOARD);
+	value = dmi_get_system_info(DMI_BIOS_VERSION);
 	for(i = 0; i < 8; i++)
 	{
 		if((value + i) != NULL)
diff --git a/CgosDrv/Modules/BoardModule.h b/CgosDrv/Modules/BoardModule.h
old mode 100755
new mode 100644
index a796643..73a72cf
--- a/CgosDrv/Modules/BoardModule.h
+++ b/CgosDrv/Modules/BoardModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/BoardModule_cfg.h b/CgosDrv/Modules/BoardModule_cfg.h
old mode 100755
new mode 100644
index 43d33ae..cd5d6f3
--- a/CgosDrv/Modules/BoardModule_cfg.h
+++ b/CgosDrv/Modules/BoardModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/HWMModule.c b/CgosDrv/Modules/HWMModule.c
old mode 100755
new mode 100644
index 3b3dc54..eb5b25e
--- a/CgosDrv/Modules/HWMModule.c
+++ b/CgosDrv/Modules/HWMModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/HWMModule.h b/CgosDrv/Modules/HWMModule.h
old mode 100755
new mode 100644
index 4f0f2f5..b229643
--- a/CgosDrv/Modules/HWMModule.h
+++ b/CgosDrv/Modules/HWMModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/HWMModule_cfg.h b/CgosDrv/Modules/HWMModule_cfg.h
old mode 100755
new mode 100644
index 706b429..b7c6f51
--- a/CgosDrv/Modules/HWMModule_cfg.h
+++ b/CgosDrv/Modules/HWMModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.c b/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.c
old mode 100755
new mode 100644
index 732e5f6..4356bf9
--- a/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.c
+++ b/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -50,7 +50,7 @@ DbgPrintEx(
 
 //***************************************************************************
 
-#define dbg_hwm_sub_bc_on
+//#define dbg_hwm_sub_bc_on
 
 #ifdef dbg_hwm_sub_bc_on
 #ifdef __linux__
@@ -789,7 +789,7 @@ unsigned int CgosFanSetLimits_BC(CGOS_DRV_VARS *cdv)
 	OsaMemCpy(&fanInfo,(CGOSFANINFO*)cdv->pin,sizeof(CGOSFANINFO));
 	if(fanInfo.dwType == CGOS_FAN_CPU)
 	{	
-		if((fanInfo.dwOutMax >= 0) && (fanInfo.dwOutMax <= 100)) //check if percentage
+		if(fanInfo.dwOutMax <= 100) //check if percentage
 		{
 			wbuf[0] = CGBC_CMD_CPU_FAN_CONTROL;
 			wbuf[1] = CGBC_FAN_SET_PWM + fanInfo.dwOutMax;
diff --git a/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.h b/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.h
old mode 100755
new mode 100644
index 7cbf92f..f8cad2b
--- a/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.h
+++ b/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC_cfg.h b/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC_cfg.h
old mode 100755
new mode 100644
index 0046f21..27dd116
--- a/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC_cfg.h
+++ b/CgosDrv/Modules/HWMSubModules/HWMSubModule_BC_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/I2CModule.c b/CgosDrv/Modules/I2CModule.c
old mode 100755
new mode 100644
index 6892851..33b66cc
--- a/CgosDrv/Modules/I2CModule.c
+++ b/CgosDrv/Modules/I2CModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/I2CModule.h b/CgosDrv/Modules/I2CModule.h
old mode 100755
new mode 100644
index 19bf8b5..4bbf2e7
--- a/CgosDrv/Modules/I2CModule.h
+++ b/CgosDrv/Modules/I2CModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/I2CModule_cfg.h b/CgosDrv/Modules/I2CModule_cfg.h
old mode 100755
new mode 100644
index 6f940a6..b7b333a
--- a/CgosDrv/Modules/I2CModule_cfg.h
+++ b/CgosDrv/Modules/I2CModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.c b/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.c
old mode 100755
new mode 100644
index d409529..c4cbf49
--- a/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.c
+++ b/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -46,7 +46,10 @@ DbgPrintEx(
 );
 #endif
 #include "../BCModule.h"
+//MOD23 v
 #include "I2CSubModule_BC_cfg.h"
+#include "I2CSubModule_GEN5_BC_cfg.h"
+//MOD23 ^
 
 //***************************************************************************
 
@@ -140,15 +143,34 @@ unsigned int initI2CSubModule_BC(CGOS_DRV_VARS *cdv)
 {
 	unsigned int retSuccess = CGOS_SUCCESS;
     dbgi2c("initI2CModule called\n");
-    if(I2C_COUNT <= CGOS_DRV_I2C_TABLE_MAX)     //CGOS_DRV_I2C_TABLE_MAX defined in DrvVars.h
-    {
-        cdv->brd->i2cCount = I2C_COUNT;
-        OsaMemCpy(cdv->i2c, &I2C_TABLE, I2C_COUNT * sizeof(CGOS_DRV_I2C_ENTRY));    //May cause alignment problems
-    }
-    else
-    {
-        retSuccess = CGOS_ERROR;
-    }
+	if ((cdv->brd->BC_Type == BC_TYPE_BC4_BASE_C)||(cdv->brd->BC_Type == BC_TYPE_BC4_BASE_E))
+	{
+		if (I2C_COUNT <= CGOS_DRV_I2C_TABLE_MAX)     //CGOS_DRV_I2C_TABLE_MAX defined in DrvVars.h
+		{
+			cdv->brd->i2cCount = I2C_COUNT;
+			OsaMemCpy(cdv->i2c, &I2C_TABLE, I2C_COUNT * sizeof(CGOS_DRV_I2C_ENTRY));    //May cause alignment problems
+		}
+		else
+		{
+			retSuccess = CGOS_ERROR;
+		}
+	}
+	else if (cdv->brd->BC_Type == BC_TYPE_GEN5)
+	{
+		if (I2C_GEN5_COUNT <= CGOS_DRV_I2C_TABLE_MAX)     //CGOS_DRV_I2C_TABLE_MAX defined in DrvVars.h
+		{
+			cdv->brd->i2cCount = I2C_GEN5_COUNT;
+			OsaMemCpy(cdv->i2c, &I2C_GEN5_TABLE, I2C_GEN5_COUNT * sizeof(CGOS_DRV_I2C_ENTRY));    //May cause alignment problems
+		}
+		else
+		{
+			retSuccess = CGOS_ERROR;
+		}
+	}
+	else
+	{
+		retSuccess = CGOS_ERROR;
+	}
     return retSuccess;
 }
 
@@ -218,21 +240,21 @@ unsigned int CgosI2CIsAvailable_BC(CGOS_DRV_VARS *cdv)
  ***********************************************************************
  * Description: Gets status of the requested i2c bus.                   
  *                                                                      
- * Last Change: 05.12.2017 HMI                                          
+ * Last Change: 05-Apr-2022 HMI                                          
  *                                                                      
- * Modifications:                                                       
+ * Modifications: -MOD24: Removed one value array                                                       
  ***********************************************************************/ 
 unsigned int I2CBusGetStatus(unsigned char bus, unsigned char *pSts)
   {
-    unsigned char wbuf[1];
+    unsigned char wbuf; //MOD24
     dbgi2c("I2CBusGetStatus called\n");
     if( bus & ~CGBC_I2C_BUS_MSK )
     {
         // Invalid bus number
         return CGOS_ERROR;
     }
-    wbuf[0] = CGBC_CMD_I2C_STAT | bus; 
-    return ( bcCommand(&wbuf[0], 1, NULL, 0, pSts) );
+    wbuf = CGBC_CMD_I2C_STAT | bus; //MOD24
+    return bcCommand(&wbuf, 1, NULL, 0, pSts); //MOD24
   }
 
 /***********************************************************************
@@ -290,7 +312,7 @@ unsigned int CgosI2CType_BC(CGOS_DRV_VARS *cdv)
  ***********************************************************************
  * Description: Read dwLen bytes from bAddr at bus dwUnit.              
  *                                                                      
- * Last Change: 24.01.2018 HMI                                          
+ * Last Change: 10-Feb-2022 HMI                                          
  *                                                                      
  * Modifications:                                                       
  ***********************************************************************/ 
@@ -317,7 +339,7 @@ unsigned int CgosI2CRead_BC(CGOS_DRV_VARS *cdv)
         wbuf[0] = CGBC_CMD_I2C_START | bus;
         wbuf[1] = CGBC_I2C_SEND_START | 1;
         wbuf[2] = 0;
-        wbuf[3] = addr;
+        wbuf[3] = addr & 0xFE; //MOD23
         retSuccess = bcCommand( &wbuf[0], 4, NULL, 0, &sts );
         if(retSuccess == CGOS_SUCCESS)
         {
@@ -328,11 +350,28 @@ unsigned int CgosI2CRead_BC(CGOS_DRV_VARS *cdv)
                     
             if(sts  == CGBC_I2C_STAT_IDL)
             {
-                splitBlockSize = 32;
+                splitBlockSize = 31;
+                // Limitation due to CGBC Command Status Byte, 31 is the maximum read value the 
+                // Board Controller can return in RC[4:0].
+                //    ___________________________________
+                //   | 7   6  |  5  |  4   3   2   1   0 |
+                //   |________|_____|____________________|
+                //   |ST[1:0] | RES |      RC[4:0]       |
+                //   |________|_____|____________________|
+                // 
+                // ST[1:0]	command state: 00 = DATA
+                //                             01 = READY
+                //                             10 = BUSY
+                //                             11 = ERROR
+                // RES		reserved/normally return 0/maybe used as RC[5] with GEN5 cBC
+                // RC[4:0]	command return code command state is READY
+                //              data count when command state is DATA
+                //              error code when command state is ERROR
+                
 #ifdef __linux__
                 for(i = cnt; (retSuccess == CGOS_SUCCESS) && i; /*(unsigned char*)*/cdv->pout += splitBlockSize)
 #else
-				for (i = cnt; (retSuccess == CGOS_SUCCESS) && i; (unsigned char*)cdv->pout += splitBlockSize)
+		for (i = cnt; (retSuccess == CGOS_SUCCESS) && i; (unsigned char*)cdv->pout += splitBlockSize)
 #endif
                 {
                     wbuf[0] = CGBC_CMD_I2C_START | bus;
@@ -346,7 +385,7 @@ unsigned int CgosI2CRead_BC(CGOS_DRV_VARS *cdv)
                         wbuf[1] = 0;
                     }
                             
-                    if(i <= 32)
+                    if(i <= splitBlockSize) 
                     {
                         wbuf[1] |= CGBC_I2C_SEND_STOP;
                         wbuf[2] = i;
@@ -371,7 +410,6 @@ unsigned int CgosI2CRead_BC(CGOS_DRV_VARS *cdv)
                                 if(sts == (wbuf[2] & 0x3F))
                                 {
                                     i -= wbuf[2] & 0x3F;
-                                    splitBlockSize = 32;
                                 }
                                 else
                                 {
@@ -409,45 +447,61 @@ unsigned int CgosI2CRead_BC(CGOS_DRV_VARS *cdv)
  ***********************************************************************
  * Description: Write dwLen bytes to bAddr at dwUnit.                   
  *                                                                      
- * Last Change: 06.12.2017 HMI                                          
+ * Last Change: 10-Feb-2022 HMI                                          
  *                                                                      
  * Modifications:                                                       
  ***********************************************************************/ 
 unsigned int CgosI2CWrite_BC(CGOS_DRV_VARS *cdv)
   {
     unsigned char wbuf[4+32];
+    unsigned char inputBuf[900] = {0};
+    unsigned int  index=0;
     unsigned char sts;
     unsigned char retSuccess = CGOS_SUCCESS;
+    unsigned char splitBlockSize;
     unsigned char thisCnt;
-    unsigned char i;
+    unsigned char i,j;
+    unsigned char len = cdv->lin;
 
     dbgi2c("CgosI2CWrite_BC called\n");
-        
     if(cdv->cin->type >= cdv->brd->i2cCount)
     {
         retSuccess = CGOS_ERROR;
     }
     else
     {
-        if( cdv->lin <= 32 )
+    	splitBlockSize = 32;	//MOD24
+        if( len <= splitBlockSize )
         {
-            thisCnt = (cdv->lin);
+            thisCnt = len;
         }
         else
         {
-            thisCnt = 32;
+            thisCnt = splitBlockSize;
         }
         wbuf[0] = CGBC_CMD_I2C_START | cdv->i2c[cdv->cin->type].cgbctype;
         wbuf[1] = CGBC_I2C_SEND_START | (1 + thisCnt);
-        if( thisCnt == cdv->lin)
+        if( thisCnt == len)
         {
             wbuf[1] |= CGBC_I2C_SEND_STOP;
         }
         wbuf[2] = 0;
         wbuf[3] = cdv->cin->pars[0];
     
-        OsaMemCpy( &wbuf[4], cdv->pin, thisCnt );
+    	//v MOD24
+    	if(len > 900)
+    	{
+    		return CGOS_ERROR;
+    	}
+    	OsaMemCpy(&inputBuf[0],cdv->pin,len);
+        for (i=0;i<thisCnt;i++)
+        {
+        	wbuf[4+i]=inputBuf[i];
+        }
+        //^ MOD24
+        
         retSuccess = bcCommand( &wbuf[0], (unsigned char)(4+thisCnt), NULL, 0, &sts );
+
         if( retSuccess==CGOS_SUCCESS )
         {
             do
@@ -457,26 +511,27 @@ unsigned int CgosI2CWrite_BC(CGOS_DRV_VARS *cdv)
 
             if( sts == CGBC_I2C_STAT_IDL )
             {
-#ifdef __linux__
-                /*(unsigned char*)*/cdv->pout += thisCnt;
-				for (i = (cdv->lin) - thisCnt; (retSuccess == CGOS_SUCCESS) && i; /*(unsigned char*)*/cdv->pin += 32)
-#else
-				(unsigned char*)cdv->pout += thisCnt;
-				for (i = (cdv->lin) - thisCnt; (retSuccess == CGOS_SUCCESS) && i; (unsigned char*)cdv->pin += 32)
-#endif
+                index += thisCnt; //MOD24
+		for (i = (cdv->lin) - thisCnt; (retSuccess == CGOS_SUCCESS) && i; index += splitBlockSize) //MOD24
                 {
-                    if( i > 32 )
+                    if( i > splitBlockSize )
                     {
-                        thisCnt = 32;
-                        wbuf[1] = 32;
+                        thisCnt = splitBlockSize;
+                        wbuf[1] = splitBlockSize;
                     }
                     else
                     {
                         thisCnt = i;
                         wbuf[1] = i | CGBC_I2C_SEND_STOP;
                     }
-                    OsaMemCpy( &wbuf[3], (unsigned char*)cdv->pin, thisCnt );
-                    retSuccess = bcCommand( &wbuf[0], (unsigned char)(3+thisCnt), NULL, 0, &sts );
+                    //v MOD24
+                    for(j = 0 ; j < thisCnt; j++)
+                    {
+                    	wbuf[3+j]=inputBuf[index+j];
+                    }
+                    //^ MOD24
+
+                    retSuccess = bcCommand( &wbuf[0], (unsigned char)(3+thisCnt), NULL, 0, &sts ); 
                     if( retSuccess==CGOS_SUCCESS )
                     {
                         do
@@ -747,10 +802,10 @@ unsigned int CgosI2CWriteRegister_BC(CGOS_DRV_VARS *cdv)
     {
         wbuf[0] = CGBC_CMD_I2C_START | cdv->i2c[cdv->cin->type].cgbctype;
         wbuf[1] = CGBC_I2C_SEND_START | CGBC_I2C_SEND_STOP | 3; 
-		wbuf[2] = 0;
+        wbuf[2] = 0;
         wbuf[3] = cdv->cin->pars[0];
         wbuf[4] = cdv->cin->pars[1];
-		wbuf[5] = cdv->cin->pars[2];
+        wbuf[5] = cdv->cin->pars[2];
         retSuccess = bcCommand( &wbuf[0], 6, NULL, 0, &sts );
     }
     return retSuccess;
@@ -770,7 +825,7 @@ unsigned int CgosI2CWriteRegister_BC(CGOS_DRV_VARS *cdv)
  * Inputs:                                                             
  * dwUnit       <->     cdv->cin->type                                  
  * bAddr        <->     cdv->cin->pars[0]                               
- * pBytesWrite  <->     cdv->lin                                        
+ * pBytesWrite  <->     cdv->pin                                        
  * dwLenWrite   <->     cdv->lin                                        
  * dwLenRead    <->     cdv->lout                                      
  *                                                                      
@@ -780,44 +835,228 @@ unsigned int CgosI2CWriteRegister_BC(CGOS_DRV_VARS *cdv)
  ***********************************************************************
  * Description: Execute a combined write and read action.               
  *                                                                      
- * Last Change: 06.12.2017 HMI                                          
+ * Last Change: 05-Apr-2022 HMI                                          
  *                                                                      
- * Modifications:                                                       
+ * Modifications: - MOD24: Instead of using cBC WriteReadCombined command
+ *                         which was limited to 34 Bytes write and 32 
+ *                         Bytes read this function now uses the 
+ *                         implementation of CgosI2CWrite without stop 
+ *                         condition, followed by CgosI2CRead.                                              
  ***********************************************************************/  
 unsigned int CgosI2CWriteReadCombined_BC(CGOS_DRV_VARS *cdv)
   { 
-    unsigned char wbuf[4+31];
+    unsigned char wbuf[4+32];
+    unsigned char inputBuf[900] = {0};
+    unsigned int  index=0;
     unsigned char sts;
     unsigned char retSuccess = CGOS_SUCCESS;
-    
+    unsigned char splitBlockSize;
+    unsigned char thisCnt;
+    unsigned char i,j;
+    unsigned char len = cdv->lin;
+    unsigned char rbuf[5];
+    unsigned char cnt = cdv->lout;
+    unsigned char addr = cdv->cin->pars[0];
+    unsigned char bus;
+
     dbgi2c("CgosI2CWriteReadCombined_BC called\n");
-    
+    //Write Part
+    if(len != 0) //In case 0 Bytes are written, go directly to read part
+    {	   
+   	    if(cdv->cin->type >= cdv->brd->i2cCount)
+    	{
+        	retSuccess = CGOS_ERROR;
+    	}
+    	else
+    	{
+        	bus = cdv->i2c[cdv->cin->type].cgbctype;
+    		splitBlockSize = 32;	
+        	if( len <= splitBlockSize )
+        	{
+        	    thisCnt = len;
+        	}
+        	else
+        	{
+        	    thisCnt = splitBlockSize;
+        	}
+        	wbuf[0] = CGBC_CMD_I2C_START | bus;
+        	wbuf[1] = CGBC_I2C_SEND_START | (1 + thisCnt);
+        	if( (thisCnt == len) && (cnt == 0)) //In case 0 Bytes are going to be read a stop condition has to be added here
+        	{
+        		wbuf[1] |= CGBC_I2C_SEND_STOP;
+        	}
+        	wbuf[2] = 0;
+        	wbuf[3] = addr & 0xFE;
+    	
+    		if(len > 900)
+    		{
+    			return CGOS_ERROR;
+    		}
+    		OsaMemCpy(&inputBuf[0],cdv->pin,len);
+        	for (i=0;i<thisCnt;i++)
+        	{
+        		wbuf[4+i]=inputBuf[i];
+        	}
+        	
+        	retSuccess = bcCommand( &wbuf[0], (unsigned char)(4+thisCnt), NULL, 0, &sts );
+        	if( retSuccess==CGOS_SUCCESS )
+        	{
+        	    do
+        	    {
+        	        retSuccess = I2CBusGetStatus( cdv->i2c[cdv->cin->type].cgbctype, &sts );
+        	    } while( (retSuccess == CGOS_SUCCESS) && (sts == CGBC_I2C_STAT_BSY) );
+        	    if( sts == CGBC_I2C_STAT_IDL )
+        	    {
+        	        index += thisCnt;
+			for (i = (cdv->lin) - thisCnt; (retSuccess == CGOS_SUCCESS) && i; index += splitBlockSize) 
+        	        {
+        	            if( i > splitBlockSize )
+        	            {
+        	                thisCnt = splitBlockSize;
+        	                wbuf[1] = splitBlockSize;
+        	            }
+        	            else
+        	            {
+        	                thisCnt = i;
+        	                if( cnt == 0) //In case 0 Bytes are going to be read a stop condition has to be added here
+        	                {
+        	                	wbuf[1] = i | CGBC_I2C_SEND_STOP;
+        	                }
+        	                else
+        	                {
+        	                	wbuf[1] = i;
+        	            	}
+        	            }
+        	            for(j = 0 ; j < thisCnt; j++)
+        	            {
+        	            	wbuf[3+j]=inputBuf[index+j];
+        	            }
+	
+        	            retSuccess = bcCommand( &wbuf[0], (unsigned char)(3+thisCnt), NULL, 0, &sts ); 
+        	            if( retSuccess==CGOS_SUCCESS )
+        	            {
+        	                do
+        	                {
+        	                    retSuccess = I2CBusGetStatus( cdv->i2c[cdv->cin->type].cgbctype, &sts );
+        	                } while( (retSuccess == CGOS_SUCCESS) && (sts == CGBC_I2C_STAT_BSY) );
+        	                if( sts == CGBC_I2C_STAT_IDL )
+        	                {
+        	                    i = i - thisCnt;
+        	                    retSuccess = CGOS_SUCCESS;
+        	                }
+        	                else
+        	                {
+        	                    retSuccess = CGOS_ERROR;
+        	                }
+        	            }
+        	        }
+        	    }
+        	    else
+        	    {
+        	        retSuccess =  CGOS_ERROR;
+        	    }
+        	} 
+        }
+    }	
+//Read Part
+
     if(cdv->cin->type >= cdv->brd->i2cCount)
     {
         retSuccess = CGOS_ERROR;
     }
     else
     {
-        wbuf[0] = CGBC_CMD_I2C_COMBINED | cdv->i2c[cdv->cin->type].cgbctype;
-        wbuf[1] = (1 + cdv->lin);
-        wbuf[2] = cdv->lout;
-        wbuf[3] = cdv->cin->pars[0];
-    
-        OsaMemCpy( &wbuf[4], cdv->pin, cdv->lin );
-        retSuccess = bcCommand( &wbuf[0], (unsigned char)(4+cdv->lin), NULL, 0, &sts );
-        if( retSuccess==CGOS_SUCCESS )
+    	if(len == 0) //In case 0 Bytes are written, this has to be called first
+    	{
+    		wbuf[0] = CGBC_CMD_I2C_START | bus;
+        	wbuf[1] = CGBC_I2C_SEND_START | 1;
+        	wbuf[2] = 0;
+        	wbuf[3] = addr & 0xFE; //MOD23
+        	retSuccess = bcCommand( &wbuf[0], 4, NULL, 0, &sts );
+    	} 
+    	  
+        if(retSuccess == CGOS_SUCCESS)
         {
             do
+            {   
+                retSuccess = I2CBusGetStatus(bus, &sts );
+            }while((retSuccess == CGOS_SUCCESS) && (sts == CGBC_I2C_STAT_BSY));
+                    
+            if(sts  == CGBC_I2C_STAT_IDL)
             {
-                retSuccess = I2CBusGetStatus( cdv->i2c[cdv->cin->type].cgbctype, &sts );
-            } while( (retSuccess == CGOS_SUCCESS) && (sts == CGBC_I2C_STAT_BSY) );
-            if( sts == CGBC_I2C_STAT_DAT )
-            {
-                wbuf[0] = CGBC_CMD_I2C_DATA | cdv->i2c[cdv->cin->type].cgbctype;
-                retSuccess = bcCommand( &wbuf[0], 1, (unsigned char*)cdv->pout, cdv->lout, &sts ); 
-            }
+                splitBlockSize = 31;
+                // Limitation due to CGBC Command Status Byte, 31 is the maximum read value the 
+                // Board Controller can return in RC[4:0].
+                //    ___________________________________
+                //   | 7   6  |  5  |  4   3   2   1   0 |
+                //   |________|_____|____________________|
+                //   |ST[1:0] | RES |      RC[4:0]       |
+                //   |________|_____|____________________|
+                // 
+                // ST[1:0]	command state: 00 = DATA
+                //                             01 = READY
+                //                             10 = BUSY
+                //                             11 = ERROR
+                // RES		reserved/normally return 0/maybe used as RC[5] with GEN5 cBC
+                // RC[4:0]	command return code command state is READY
+                //              data count when command state is DATA
+                //              error code when command state is ERROR
+                
+#ifdef __linux__
+                for(i = cnt; (retSuccess == CGOS_SUCCESS) && i; /*(unsigned char*)*/cdv->pout += splitBlockSize)
+#else
+		for (i = cnt; (retSuccess == CGOS_SUCCESS) && i; (unsigned char*)cdv->pout += splitBlockSize)
+#endif
+                {
+                    rbuf[0] = CGBC_CMD_I2C_START | bus;
+                    if(i == cnt)
+                    {
+                        rbuf[1] = CGBC_I2C_SEND_START | 1;
+                        rbuf[3] = addr | 0x01;
+                    }
+                    else
+                    {
+                        rbuf[1] = 0;
+                    }
+                            
+                    if(i <= splitBlockSize) 
+                    {
+                        rbuf[1] |= CGBC_I2C_SEND_STOP;
+                        rbuf[2] = i;
+                    }
+                    else
+                    {
+                        rbuf[2] = CGBC_I2C_SEND_LAST_ACK | splitBlockSize;
+                    }
+                    retSuccess = bcCommand(&rbuf[0], (unsigned char)((cnt == i)?4:3), NULL, 0, &sts);
+                    
+                    if(retSuccess == CGOS_SUCCESS)
+                    {
+                        do
+                        {
+                            retSuccess = I2CBusGetStatus( bus, &sts );
+                        } while( (retSuccess == CGOS_SUCCESS) && (sts == CGBC_I2C_STAT_BSY) );
+                        if( sts == CGBC_I2C_STAT_DAT )
+                        {
+                            rbuf[0] = CGBC_CMD_I2C_DATA | bus;
+                            retSuccess = bcCommand(&rbuf[0], 1, cdv->pout, (unsigned char)(rbuf[2] & 0x3F), &sts);
+                            if(retSuccess == CGOS_SUCCESS)
+                            {
+                                if(sts == (rbuf[2] & 0x3F))
+                                {
+                                    i -= rbuf[2] & 0x3F;
+                                }
+                                else
+                                {
+                                    retSuccess = CGOS_ERROR;
+                                }
+                            }
+                        }
+                    }
+                }
+            }       
         }
-        cdv->retcnt += cdv->lout;
+    cdv->retcnt += cdv->lout;
     }
     return retSuccess;
   }
@@ -838,48 +1077,79 @@ unsigned int CgosI2CWriteReadCombined_BC(CGOS_DRV_VARS *cdv)
  ***********************************************************************
  * Description: Gets the maximum i2c frequency.                         
  *                                                                      
- * Last Change: 06.12.2017 HMI                                          
+ * Last Change: 05-Apr-2022 HMI                                          
  *                                                                      
- * Modifications:                                                       
+ * Modifications: - MOD24: Added additional capabilities                                                       
  ***********************************************************************/  
 unsigned int CgosI2CGetMaxFrequency_BC(CGOS_DRV_VARS *cdv)
   {
     unsigned char stat;
     unsigned char unit;
+    unsigned char bus;
     unsigned char value;
     unsigned char writeBuf;
     unsigned char readBuf[14];
     unsigned int retSuccess = CGOS_SUCCESS;
-    writeBuf = CGBC_CMD_INFO_1;
-    dbgi2c("CgosI2CGetMaxFrequency_BC called\n");
-    if(!bcCommand(&writeBuf,sizeof(writeBuf),&readBuf[0],sizeof(readBuf),&stat))
+    
+    dbgi2c("CgosI2CGetMaxFrequency_BC called\n");    
+    //MOD24 v
+    if(cdv->cin->type >= cdv->brd->i2cCount)
     {
-        unit = readBuf[3] & CGBC_I2C_FREQ_UNIT_MASK;
-        value = readBuf[3] & CGBC_I2C_FREQ_VALUE_MSK;
-        if(unit == CGBC_I2C_FREQ_UNIT_100KHZ)
-        {
-            cdv->cout->rets[0] = value * 100000;
-        }
-        else if(unit == CGBC_I2C_FREQ_UNIT_10KHZ)
-        {
-            cdv->cout->rets[0] = value * 10000;
-        }
-        else if(unit == CGBC_I2C_FREQ_UNIT_1KHZ)
-        {
-            cdv->cout->rets[0] = value * 1000;
-        }
-        else if(unit == CGBC_I2C_FREQ_UNIT_100HZ)
-        {
-            cdv->cout->rets[0] = value * 100;
-        }
-        else
-        {
-            cdv->cout->rets[0] = value;
-        }
+        retSuccess = CGOS_ERROR;
     }
     else
     {
-        retSuccess = CGOS_ERROR;
+    	bus = cdv->i2c[cdv->cin->type].cgbctype; //MOD24 ^
+    	writeBuf = CGBC_CMD_INFO_1;
+
+    	if(!bcCommand(&writeBuf,sizeof(writeBuf),&readBuf[0],sizeof(readBuf),&stat)) //Get Info from cBC
+    	{
+    		//MOD24 v
+    		if(bus == CGBC_I2C_BUS_EXTERNAL)
+    		{
+       			unit = readBuf[3] & CGBC_I2C_FREQ_UNIT_MASK;
+       			value = readBuf[3] & CGBC_I2C_FREQ_VALUE_MSK;
+       		}
+       		else if((bus == CGBC_I2C_BUS_SMB0) || (bus == CGBC_I2C_BUS_SMB1) || (bus == CGBC_I2C_BUS_SMB2))
+       		{
+       			unit = readBuf[4] & CGBC_I2C_FREQ_UNIT_MASK;
+       			value = readBuf[4] & CGBC_I2C_FREQ_VALUE_MSK;
+       		}
+       		else if(bus == CGBC_I2C_BUS_EPI)
+       		{
+       		        unit = readBuf[5] & CGBC_I2C_FREQ_UNIT_MASK;
+       			value = readBuf[5] & CGBC_I2C_FREQ_VALUE_MSK;
+       		}
+       		else
+       		{
+       			return CGOS_ERROR;
+       		}
+       		//MOD24 ^
+       		if(unit == CGBC_I2C_FREQ_UNIT_100KHZ)
+       		{
+       		    cdv->cout->rets[0] = value * 100000;
+       		}
+       		else if(unit == CGBC_I2C_FREQ_UNIT_10KHZ)
+       		{
+       		    cdv->cout->rets[0] = value * 10000;
+       		}
+       		else if(unit == CGBC_I2C_FREQ_UNIT_1KHZ)
+       		{
+       		    cdv->cout->rets[0] = value * 1000;
+       		}
+       		else if(unit == CGBC_I2C_FREQ_UNIT_100HZ)
+       		{
+       		    cdv->cout->rets[0] = value * 100;
+       		}
+       		else
+       		{
+       		    cdv->cout->rets[0] = value;
+       		}
+    	}	
+    	else
+    	{
+        	retSuccess = CGOS_ERROR;
+    	}
     }
     return retSuccess;
   }
@@ -900,56 +1170,67 @@ unsigned int CgosI2CGetMaxFrequency_BC(CGOS_DRV_VARS *cdv)
  ***********************************************************************
  * Description: Get the current i2c frequency.                          
  *                                                                      
- * Last Change: 06.12.2017 HMI                                          
+ * Last Change: 05-Apr-2022 HMI                                          
  *                                                                      
- * Modifications:                                                       
+ * Modifications: -MOD24:  Fixed error in bcCommand function call                                                      
  ***********************************************************************/  
 unsigned int CgosI2CGetFrequency_BC(CGOS_DRV_VARS *cdv)               
   {
     unsigned char stat;
     unsigned char erg;
-    unsigned char unit;
+    unsigned char unit; 
+    unsigned char  bus;
     unsigned char value;
     unsigned char writeBuf[2];
     unsigned int retSuccess = CGOS_SUCCESS;
+    
     dbgi2c("CgosI2CGetFrequency_BC called\n");
+    
     if(cdv->cin->type >= cdv->brd->i2cCount)
     {
         retSuccess = CGOS_ERROR;
     }
     else
     {
-        writeBuf[0] = CGBC_CMD_I2C_SPEED | cdv->i2c[cdv->cin->type].cgbctype;
-        writeBuf[1] = 0x00;
-        if(!bcCommand(&writeBuf[0],sizeof(writeBuf), &erg, cdv->lout,&stat))
-        {
-            unit = erg & CGBC_I2C_FREQ_UNIT_MASK;
-            value = erg & CGBC_I2C_FREQ_VALUE_MSK;
-            if(unit == CGBC_I2C_FREQ_UNIT_100KHZ)
-            {
-                cdv->cout->rets[0] = value * 100000;
-            }
-            else if(unit == CGBC_I2C_FREQ_UNIT_10KHZ)
-            {
-                cdv->cout->rets[0] = value * 10000;
-            }
-            else if(unit == CGBC_I2C_FREQ_UNIT_1KHZ)
-            {
-                cdv->cout->rets[0] = value * 1000;
-            }
-            else if(unit == CGBC_I2C_FREQ_UNIT_100HZ)
-            {
-                cdv->cout->rets[0] = value * 100;
-            }
-            else
-            {
-                cdv->cout->rets[0] = value;
-            }
-        }
-        else 
-        {
-            retSuccess = CGOS_ERROR;
-        } 
+    	bus = cdv->i2c[cdv->cin->type].cgbctype;
+    	if(cdv->cin->type >= cdv->brd->i2cCount)
+    	{
+        	retSuccess = CGOS_ERROR;
+    	}
+    	else
+    	{
+        	writeBuf[0] = CGBC_CMD_I2C_SPEED | bus;
+        	writeBuf[1] = 0x00;
+        	if(!bcCommand(&writeBuf[0],2, &erg, 1,&stat))	//MOD24
+        	{
+        	    unit = erg & CGBC_I2C_FREQ_UNIT_MASK;
+        	    value = erg & CGBC_I2C_FREQ_VALUE_MSK;
+        	    if(unit == CGBC_I2C_FREQ_UNIT_100KHZ)
+        	    {
+        	        cdv->cout->rets[0] = value * 100000;
+        	    }
+        	    else if(unit == CGBC_I2C_FREQ_UNIT_10KHZ)
+        	    {
+        	        cdv->cout->rets[0] = value * 10000;
+        	    }
+        	    else if(unit == CGBC_I2C_FREQ_UNIT_1KHZ)
+        	    {
+        	        cdv->cout->rets[0] = value * 1000;
+        	    }
+        	    else if(unit == CGBC_I2C_FREQ_UNIT_100HZ)
+        	    {
+        	        cdv->cout->rets[0] = value * 100;
+        	    }
+        	    else
+        	    {
+        	        cdv->cout->rets[0] = value;
+        	    }
+        	}
+        	else 
+        	{
+        	    retSuccess = CGOS_ERROR;
+        	} 
+    	}
     }
     return retSuccess;
   }
@@ -971,57 +1252,78 @@ unsigned int CgosI2CGetFrequency_BC(CGOS_DRV_VARS *cdv)
  ***********************************************************************
  * Description: Set i2c frequency to pdwSetting.                       
  *                                                                      
- * Last Change: 06.12.2017 HMI                                          
+ * Last Change: 05-Apr-2022 HMI                                          
  *                                                                      
- * Modifications:                                                       
+ * Modifications: -MOD24: +Fixed error in bcCommand function call
+ *                        +Added 6100000 as maximum frequency value, the
+ *                         board controller command can't send a higher
+ *                         value.                                                 
  ***********************************************************************/  
 unsigned int CgosI2CSetFrequency_BC(CGOS_DRV_VARS *cdv)                   
   {
     unsigned char stat;
+    unsigned char bus;
     unsigned char ret = 0;
     unsigned int value = cdv->cin->pars[0];
     unsigned char dataByte = 0x00;
     unsigned char writeBuf[2];
     unsigned int retSuccess = CGOS_SUCCESS;
+    
     dbgi2c("CgosI2CSetFrequency_BC called\n");
+    
     if(cdv->cin->type >= cdv->brd->i2cCount)
     {
         retSuccess = CGOS_ERROR;
     }
     else
     {
-        writeBuf[0] = CGBC_CMD_I2C_SPEED |cdv->i2c[cdv->cin->type].cgbctype;
-        //works as long as i2c frequency is < 10,000,000 Hz
-        if(value >= 100000)
-        {
-            dataByte |= CGBC_I2C_FREQ_UNIT_100KHZ;
-            value /= 100000;
-        }
-        if(value >= 10000)
-        {
-            dataByte |= CGBC_I2C_FREQ_UNIT_10KHZ;
-            value /= 10000;
-        }
-        if(value >= 1000)
-        {
-            dataByte |= CGBC_I2C_FREQ_UNIT_1KHZ;
-            value /= 1000;
-        }
-        if(value >= 100)
-        {
-            dataByte |= CGBC_I2C_FREQ_UNIT_100HZ;
-            value /= 100;
-        }
-        writeBuf[1] = dataByte | (CGBC_I2C_FREQ_VALUE_MSK & value);
-        if(!bcCommand(&writeBuf[0],sizeof(writeBuf), &ret, cdv->lout,&stat))
-        {   
-            cdv->cout->rets[0] = ret;
-            retSuccess = CGOS_SUCCESS;
-        } 
-        else
-        {
-            retSuccess = CGOS_ERROR;
-        }
+    	bus = cdv->i2c[cdv->cin->type].cgbctype;
+    	if(cdv->cin->type >= cdv->brd->i2cCount)
+    	{
+        	retSuccess = CGOS_ERROR;
+    	}
+    	else
+    	{
+        	writeBuf[0] = CGBC_CMD_I2C_SPEED | bus;        
+        	if((value >= 100000)&&(value <= 6100000))	//MOD24
+        	{
+        		dataByte |= CGBC_I2C_FREQ_UNIT_100KHZ;
+        		value /= 100000;
+        	}
+        	else if((value >= 10000)&&(value < 100000))
+        	{
+        		dataByte |= CGBC_I2C_FREQ_UNIT_10KHZ;
+       			value /= 10000;
+        	}
+        	else if((value >= 1000)&&(value < 10000))
+        	{
+        		dataByte |= CGBC_I2C_FREQ_UNIT_1KHZ;
+        		value /= 1000;
+        	}
+        	else if((value >= 100)&&(value < 1000))
+        	{
+        		dataByte |= CGBC_I2C_FREQ_UNIT_100HZ;
+        		value /= 100;
+        	}
+        	else
+        	{
+        		retSuccess = CGOS_ERROR;
+        	}
+        	
+        	if(retSuccess == CGOS_SUCCESS)
+        	{
+        		writeBuf[1] = dataByte | (CGBC_I2C_FREQ_VALUE_MSK & value);
+        		if(!bcCommand(&writeBuf[0],2, &ret, 1,&stat))	//MOD24
+        		{   
+        	    		cdv->cout->rets[0] = ret;
+        	    		retSuccess = CGOS_SUCCESS;
+        		} 
+        		else
+        		{
+        	    		retSuccess = CGOS_ERROR;
+        		}
+    		}
+    	}
     }
     return retSuccess;
   }
diff --git a/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.h b/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.h
old mode 100755
new mode 100644
index 0cc249d..fd9e82c
--- a/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.h
+++ b/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC_cfg.h b/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC_cfg.h
old mode 100755
new mode 100644
index b97b2a9..aab10ad
--- a/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC_cfg.h
+++ b/CgosDrv/Modules/I2CSubModules/I2CSubModule_BC_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/I2CSubModules/I2CSubModule_GEN5_BC_cfg.h b/CgosDrv/Modules/I2CSubModules/I2CSubModule_GEN5_BC_cfg.h
new file mode 100644
index 0000000..d992803
--- /dev/null
+++ b/CgosDrv/Modules/I2CSubModules/I2CSubModule_GEN5_BC_cfg.h
@@ -0,0 +1,36 @@
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+ 
+#ifndef _I2CSUBMOD_GEN5_BC_CFG_H_
+#define _I2CSUBMOD_GEN5_BC_CFG_H_
+
+#define I2C_GEN5_COUNT 6
+
+CGOS_DRV_I2C_ENTRY I2C_GEN5_TABLE[I2C_GEN5_COUNT] = {	{CGOS_I2C_TYPE_PRIMARY,	CGBC_I2C_BUS_EXTERNAL},
+													{CGOS_I2C_TYPE_SMB, 	CGBC_I2C_BUS_SMB0},
+													{CGOS_I2C_TYPE_DDC,  	CGBC_I2C_BUS_EPI},
+													{0x00040000, 			CGBC_I2C_BUS_INTERNAL},
+													{CGOS_I2C_TYPE_SMB,  	CGBC_I2C_BUS_SMB1},
+													{0x00050000,  			CGBC_I2C_BUS_SMB2}};
+#endif
diff --git a/CgosDrv/Modules/IOModule.c b/CgosDrv/Modules/IOModule.c
old mode 100755
new mode 100644
index b073a61..1697993
--- a/CgosDrv/Modules/IOModule.c
+++ b/CgosDrv/Modules/IOModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/IOModule.h b/CgosDrv/Modules/IOModule.h
old mode 100755
new mode 100644
index 201b3ac..d607f2a
--- a/CgosDrv/Modules/IOModule.h
+++ b/CgosDrv/Modules/IOModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/IOModule_cfg.h b/CgosDrv/Modules/IOModule_cfg.h
old mode 100755
new mode 100644
index a9df339..d38a821
--- a/CgosDrv/Modules/IOModule_cfg.h
+++ b/CgosDrv/Modules/IOModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/IOSubModules/IOSubModule_BC.c b/CgosDrv/Modules/IOSubModules/IOSubModule_BC.c
old mode 100755
new mode 100644
index 27206d5..16c6556
--- a/CgosDrv/Modules/IOSubModules/IOSubModule_BC.c
+++ b/CgosDrv/Modules/IOSubModules/IOSubModule_BC.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -49,7 +49,7 @@ DbgPrintEx(
 #include "IOSubModule_BC_cfg.h"
 
 //***************************************************************************
-#define dbg_io_sub_bc_on
+//#define dbg_io_sub_bc_on
 
 #ifdef dbg_io_sub_bc_on
 #ifdef __linux__
diff --git a/CgosDrv/Modules/IOSubModules/IOSubModule_BC.h b/CgosDrv/Modules/IOSubModules/IOSubModule_BC.h
old mode 100755
new mode 100644
index a46fa9f..c95bf30
--- a/CgosDrv/Modules/IOSubModules/IOSubModule_BC.h
+++ b/CgosDrv/Modules/IOSubModules/IOSubModule_BC.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/IOSubModules/IOSubModule_BC_cfg.h b/CgosDrv/Modules/IOSubModules/IOSubModule_BC_cfg.h
old mode 100755
new mode 100644
index 9aa1a35..e9926ea
--- a/CgosDrv/Modules/IOSubModules/IOSubModule_BC_cfg.h
+++ b/CgosDrv/Modules/IOSubModules/IOSubModule_BC_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/StoModule.c b/CgosDrv/Modules/StoModule.c
old mode 100755
new mode 100644
index 63155b4..cef32eb
--- a/CgosDrv/Modules/StoModule.c
+++ b/CgosDrv/Modules/StoModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/StoModule.h b/CgosDrv/Modules/StoModule.h
old mode 100755
new mode 100644
index 496b3f8..f4a43ee
--- a/CgosDrv/Modules/StoModule.h
+++ b/CgosDrv/Modules/StoModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/StoModule_cfg.h b/CgosDrv/Modules/StoModule_cfg.h
old mode 100755
new mode 100644
index 8c835a7..cec52c3
--- a/CgosDrv/Modules/StoModule_cfg.h
+++ b/CgosDrv/Modules/StoModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/StoSubModules/StoSubModule_BC.c b/CgosDrv/Modules/StoSubModules/StoSubModule_BC.c
old mode 100755
new mode 100644
index 0ea53ec..0370d02
--- a/CgosDrv/Modules/StoSubModules/StoSubModule_BC.c
+++ b/CgosDrv/Modules/StoSubModules/StoSubModule_BC.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2020, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -31,6 +31,7 @@
 #include "CGBC.h"
 #include "../I2CSubModules/I2CSubModule_BC.h"
 #ifdef _WIN64
+#include <windows.h>
 #undef UINT8
 #undef UINT16
 #define DPFLTR_INFO_LEVEL 3
@@ -51,7 +52,7 @@ DbgPrintEx(
 
 //***************************************************************************
 
-#define dbg_sto_sub_bc_on
+//#define dbg_sto_sub_bc_on
 
 #ifdef dbg_sto_sub_bc_on
 #ifdef __linux__
@@ -94,6 +95,11 @@ unsigned int power(unsigned int x, unsigned int y)
 	}
 }
 
+#ifndef __linux__
+void msleep(int ms)
+{
+}
+#endif
 
 //***************************************************************************
 
diff --git a/CgosDrv/Modules/StoSubModules/StoSubModule_BC.h b/CgosDrv/Modules/StoSubModules/StoSubModule_BC.h
old mode 100755
new mode 100644
index ae888a8..4ab8785
--- a/CgosDrv/Modules/StoSubModules/StoSubModule_BC.h
+++ b/CgosDrv/Modules/StoSubModules/StoSubModule_BC.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/StoSubModules/StoSubModule_BC_cfg.h b/CgosDrv/Modules/StoSubModules/StoSubModule_BC_cfg.h
old mode 100755
new mode 100644
index 6424148..ffeae78
--- a/CgosDrv/Modules/StoSubModules/StoSubModule_BC_cfg.h
+++ b/CgosDrv/Modules/StoSubModules/StoSubModule_BC_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+  * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/VgaModule.c b/CgosDrv/Modules/VgaModule.c
old mode 100755
new mode 100644
index 4b9bc32..4d7b9f2
--- a/CgosDrv/Modules/VgaModule.c
+++ b/CgosDrv/Modules/VgaModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/VgaModule.h b/CgosDrv/Modules/VgaModule.h
old mode 100755
new mode 100644
index 13d31b0..ee134f0
--- a/CgosDrv/Modules/VgaModule.h
+++ b/CgosDrv/Modules/VgaModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/VgaModule_cfg.h b/CgosDrv/Modules/VgaModule_cfg.h
old mode 100755
new mode 100644
index ffb737e..002240d
--- a/CgosDrv/Modules/VgaModule_cfg.h
+++ b/CgosDrv/Modules/VgaModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.c b/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.c
old mode 100755
new mode 100644
index 3b7e9b2..a16560d
--- a/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.c
+++ b/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
@@ -49,7 +49,7 @@ DbgPrintEx(
 
 //***************************************************************************
 
-#define dbg_vga_sub_bc_on
+//#define dbg_vga_sub_bc_on
 
 #ifdef dbg_vga_sub_bc_on
 #ifdef __linux__
diff --git a/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.h b/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.h
old mode 100755
new mode 100644
index 1fb2274..c510966
--- a/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.h
+++ b/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC_cfg.h b/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC_cfg.h
old mode 100755
new mode 100644
index 947e976..dd4ecc3
--- a/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC_cfg.h
+++ b/CgosDrv/Modules/VgaSubModules/VgaSubModule_BC_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/WDModule.c b/CgosDrv/Modules/WDModule.c
old mode 100755
new mode 100644
index b1aad92..0a31bde
--- a/CgosDrv/Modules/WDModule.c
+++ b/CgosDrv/Modules/WDModule.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/WDModule.h b/CgosDrv/Modules/WDModule.h
old mode 100755
new mode 100644
index 6544f36..de5d823
--- a/CgosDrv/Modules/WDModule.h
+++ b/CgosDrv/Modules/WDModule.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/WDModule_cfg.h b/CgosDrv/Modules/WDModule_cfg.h
old mode 100755
new mode 100644
index 1cd324b..03bea58
--- a/CgosDrv/Modules/WDModule_cfg.h
+++ b/CgosDrv/Modules/WDModule_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/WDSubModules/WDSubModule_BC.c b/CgosDrv/Modules/WDSubModules/WDSubModule_BC.c
old mode 100755
new mode 100644
index 3fd985a..8affd0a
--- a/CgosDrv/Modules/WDSubModules/WDSubModule_BC.c
+++ b/CgosDrv/Modules/WDSubModules/WDSubModule_BC.c
@@ -1,34 +1,34 @@
-/*---------------------------------------------------------------------------
- *
- * Copyright (c) 2017, congatec AG. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as 
- * published by the Free Software Foundation; either version 2 of 
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
- * See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation, 
- * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * The full text of the license may also be found at:        
- * http://opensource.org/licenses/GPL-2.0
- *
- *---------------------------------------------------------------------------
- */ 
-
-#ifdef __linux__
-#include <linux/printk.h> 
-#include <linux/module.h> 
-#endif
-
-#include "CgosDrv.h"
-#include "CGBC.h"
+/*---------------------------------------------------------------------------
+ *
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as 
+ * published by the Free Software Foundation; either version 2 of 
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation, 
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * The full text of the license may also be found at:        
+ * http://opensource.org/licenses/GPL-2.0
+ *
+ *---------------------------------------------------------------------------
+ */ 
+
+#ifdef __linux__
+#include <linux/printk.h> 
+#include <linux/module.h> 
+#endif
+
+#include "CgosDrv.h"
+#include "CGBC.h"
 #ifdef _WIN64
 #undef UINT8
 #undef UINT16
@@ -44,14 +44,14 @@ DbgPrintEx(
 	_In_z_ _Printf_format_string_ PCSTR Format,
 	...
 );
-#endif
-#include "../BCModule.h"
-#include "WDSubModule_BC_cfg.h"
-
-//***************************************************************************
-
-#define dbg_wd_sub_bc_on
-
+#endif
+#include "../BCModule.h"
+#include "WDSubModule_BC_cfg.h"
+
+//***************************************************************************
+
+//#define dbg_wd_sub_bc_on
+
 #ifdef dbg_wd_sub_bc_on
 #ifdef __linux__
 #define dbgwd(x) printk(x)
@@ -62,471 +62,471 @@ DbgPrintEx(
 #endif
 #else
 #define dbgwd(x)
-#endif
-
-//***************************************************************************
-// Function prototypes for register function
-
-unsigned int initWDSubModule_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogGetInfo_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogCount_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogIsAvailable_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogTrigger_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogGetConfigStruct_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogSetConfigStruct_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogSetConfig_BC(CGOS_DRV_VARS *cdv);
-unsigned int CgosWDogDisable_BC(CGOS_DRV_VARS *cdv);
-unsigned int exitWDSubModule_BC(CGOS_DRV_VARS *cdv);
-
-//***************************************************************************
-
-/***********************************************************************
- * unsigned int RegisterWDSubModule_BC									
- * 																		
- ***********************************************************************
- * Description: This function uses the RegisterSubModule callback to	
- * 			  	register the SubModule functions.						
- * 																		
- * Last Change: 20.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int RegisterWDSubModule_BC(unsigned int (*RegisterSubModule)(	CgosFunctionPointer initSubModule,
-																		CgosFunctionPointer GetInfo,
-																		CgosFunctionPointer Count,
-																		CgosFunctionPointer IsAvailable,
-																		CgosFunctionPointer Trigger,
-																		CgosFunctionPointer GetTriggerCount,
-																		CgosFunctionPointer SetTriggerCount,
-																		CgosFunctionPointer GetConfigStruct,
-																		CgosFunctionPointer SetConfigStruct,
-																		CgosFunctionPointer SetConfig,
-																		CgosFunctionPointer Disable,
-																		CgosFunctionPointer exitSubModule,
-																		unsigned char ModuleNumber),
-								    unsigned char Number)
-{
-	return RegisterSubModule(	initWDSubModule_BC,
-								CgosWDogGetInfo_BC,
-								CgosWDogCount_BC,
-								CgosWDogIsAvailable_BC,
-								CgosWDogTrigger_BC,
-								NULL,		//Get Trigger Count
-								NULL,		//Set Trigger Count
-								CgosWDogGetConfigStruct_BC,
-								CgosWDogSetConfigStruct_BC,
-								CgosWDogSetConfig_BC,
-								CgosWDogDisable_BC,
-								exitWDSubModule_BC,
-								Number);
-}
-
-/***********************************************************************
- * unsigned int initWDModule_BC(CGOS_DRV_VARS *cdv) 					    
- * 																		
- ***********************************************************************
- * Description: This function is called to copy information from		
- * 				WDModule_cfg.h into the cdv struct.						
- * 																		
- * Last Change: 12.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int initWDSubModule_BC(CGOS_DRV_VARS *cdv)
-  {
-	int i = 0;	
-	unsigned int retSuccess = CGOS_SUCCESS;
-	dbgwd("initWDSubModule_BC called\n");	
-	if(WD_COUNT <= CGOS_DRV_WDOG_MAX)		//CGOS_DRV_WDOG_MAX defined in DrvVars.h
-	{
-		cdv->brd->wdogCount = WD_COUNT;
-	
-		for(i = 0; i < WD_COUNT; i++)
-		{
-			OsaMemCpy(&cdv->wdog[i].config,&WD_CONFIG[i],sizeof(CGOSWDCONFIG));
-			OsaMemCpy(&cdv->wdog[i].info,&WD_INFO[i],sizeof(CGOSWDINFO));
-		}
-	}
-	else
-	{
-		retSuccess = CGOS_ERROR;
-	}
-	return retSuccess;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogGetInfo_BC(CGOS_DRV_VARS *cdv)			  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogGetInfo(HCGOS hCgos, 						    
- * 								  unsigned long dwUnit,				    
- * 								  CGOSWDINFO *pInfo)				    
- * Inputs:															    
- *   dwUnit <->		cdv->cin->type					    			    
- * 																	    
- * Outputs:															    
- *   pInfo 	<-> 	cdv->pout										    
- * 																		
- ***********************************************************************
- * Description: Get the info struct of the watchdog.					
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogGetInfo_BC(CGOS_DRV_VARS *cdv)
-  {
-	dbgwd("CgosWDogGetInfo_BC called\n");
-	if(cdv->cin->type < cdv->brd->wdogCount)
-	{
-		OsaMemCpy(cdv->pout,&cdv->wdog[cdv->cin->type].info,sizeof(CGOSWDINFO));
-	}
-	else
-	{
-		return CGOS_ERROR;
-	}
-	cdv->retcnt += sizeof(CGOSWDINFO);
-	return CGOS_SUCCESS;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogCount_BC(CGOS_DRV_VARS *cdv)				  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogCount(HCGOS hCgos) 						    
- * 																	    
- * Inputs:															    
- *   -												    			    
- * 																	    
- * Outputs:															    
- *   cdv->cout->rets[0]												    
- * 																		
- ***********************************************************************
- * Description: Get the number of available watchdogs.					
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogCount_BC(CGOS_DRV_VARS *cdv)
-  {
-	cdv->cout->rets[0] = cdv->brd->wdogCount;						
-	dbgwd("CgosWDogCount_BC called\n");
-	return CGOS_SUCCESS;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogIsAvailable_BC(CGOS_DRV_VARS *cdv)				
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogIsAvailable(HCGOS hCgos, 					    
- * 									  unsigned int dwUnit)			    
- * Inputs:															    
- *   -												    			    
- * 																	    
- * Outputs:															    
- *   cdv->cout->rets[0]												    
- * 																		
- ***********************************************************************
- * Description: Check if watchdog with number dwUnit is available.		
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogIsAvailable_BC(CGOS_DRV_VARS *cdv)
-  {
-	dbgwd("CgosWDogIsAvailable_BC called\n");
-	cdv->cout->rets[0]=cdv->cin->type<cdv->brd->wdogCount;
-	return CGOS_SUCCESS;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogTrigger_BC(CGOS_DRV_VARS *cdv)			  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogTrigger(HCGOS hCgos, 						    
- * 								  unsigned long dwUnit)				    
- * Inputs:															    
- *   -												    			    
- * 																	    
- * Outputs:															    
- *   -																    
- * 																		
- ***********************************************************************
- * Description: Triggers the watchdog dwUnit. Only BC watchdog			
- * 				implemented at the moment.								
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogTrigger_BC(CGOS_DRV_VARS *cdv)
-  {
-	unsigned char command = CGBC_CMD_WD_TRIGGER;
-	unsigned char sts = 0;
-	dbgwd("CgosWDogTrigger_BC called\n");
-	bcCommand(&command, 1, NULL, 0, &sts); 
-	return CGOS_SUCCESS;
-  }
-  
-/***********************************************************************
- * unsigned int CgosWDogGetTriggerCount_BC(CGOS_DRV_VARS *cdv)	  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogGetTriggerCount(HCGOS hCgos, 				    
- * 								  		  unsigned long dwUnit)		    
- *																	    
- ***********************************************************************
- * Description: Not implemented											
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogGetTriggerCount_BC(CGOS_DRV_VARS *cdv)
-  {
-    dbgwd("CgosWDogGetTriggerCount_BC called\n");
-	return CGOS_SUCCESS;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogSetTriggerCount_BC(CGOS_DRV_VARS *cdv)			
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogSetTriggerCount(HCGOS hCgos, 				    
- * 								  		  unsigned long dwUnit)		    	
- * 										  unsigned int cnt   		    
- * 																		
- ***********************************************************************
- * Description: Not implemented											
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogSetTriggerCount_BC(CGOS_DRV_VARS *cdv)
-  {
-    dbgwd("CgosWDogSetTriggerCount_BC called\n");
-	return CGOS_SUCCESS;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogGetConfigStruct_BC(CGOS_DRV_VARS *cdv)	  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogGetConfigStruct(HCGOS hCgos, 				    
- * 										  unsigned long dwUnit,		    
- * 										  CGOSWDCONFIG *pConfig)	    
- * Inputs:															    
- *   dwUnit <->		cdv->cin->type					    			    
- * 																	    
- * Outputs:															    
- * pConfig 	<-> 	cdv->pout;						 				    
- * 																		
- ***********************************************************************
- * Description: Get the config struct of watchdog number dwUnit.		
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogGetConfigStruct_BC(CGOS_DRV_VARS *cdv)
-  {
-	dbgwd("CgosWDogGetConfigStruct_BC called\n");
-	if(cdv->cin->type < cdv->brd->wdogCount)
-	{
-		OsaMemCpy(cdv->pout,&cdv->wdog[cdv->cin->type].config,sizeof(CGOSWDCONFIG));
-	}
-	else
-	{
-		return CGOS_ERROR;
-	}
-	cdv->retcnt += sizeof(CGOSWDCONFIG); 
-	return CGOS_SUCCESS;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogSetConfigStruct_BC(CGOS_DRV_VARS *cdv)	  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogSetConfigStruct(HCGOS hCgos, 				    
- * 										  unsigned long dwUnit,		    
- * 										  CGOSWDCONFIG *pConfig)	    
- * Inputs:															    
- * pConfig 	<-> 	(CGOSWDCONFIG*)cdv->pin;						    
- * dwUnit	<->		cdv->cin->type					    			    
- * 																	    
- * Outputs:															    
- *   -																    
- * 																		
- ***********************************************************************
- * Description: Overwrite the config struct of watchdog number dwUnit
- * 				and send the new config struct to the board controller.	
- * 				Only the BC watchdog is implemented at the moment.		
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int CgosWDogSetConfigStruct_BC(CGOS_DRV_VARS *cdv)
-  {
-	unsigned char wbuf[15];
-	unsigned char sts = 0;
-	unsigned int unit = cdv->cin->type;
-	int i = 0;
-	if(unit < cdv->brd->wdogCount)
-	{
-		OsaMemCpy(&cdv->wdog[unit].config,(CGOSWDCONFIG*)cdv->pin,sizeof(CGOSWDCONFIG));  
-		dbgwd("CgosWDogSetConfigStruct_BC called\n");	
-
-		wbuf[0]  = CGBC_CMD_WD_INIT;
-		wbuf[1]  = cdv->wdog[unit].config.dwOpMode; 	//wd mode
-
-		wbuf[2]  = cdv->wdog[unit].config.dwStageCount;	//wd control byte
-		for(i = 0; i < cdv->wdog[unit].config.dwStageCount; i++)
-		{
-			wbuf[2] |= (cdv->wdog[unit].config.stStages[i].dwEvent << (2*i+2)); 
-		}
-
-		if(cdv->wdog[unit].config.dwMode != CGOS_WDOG_MODE_STAGED)
-		{
-			wbuf[3]  =  cdv->wdog[unit].config.dwTimeout & 0xFF; 			 //stage 1 timeout low byte
-			wbuf[4]  = (cdv->wdog[unit].config.dwTimeout & 0xFF00)	>>  8;   //stage 1 timeout middle byte
-			wbuf[5]  = (cdv->wdog[unit].config.dwTimeout & 0xFF0000) >> 16;  //stage 1 timeout high byte
-		}
-		else if(cdv->wdog[unit].config.dwMode == CGOS_WDOG_MODE_STAGED)
-		{
-			for(i = 0; i < cdv->wdog[unit].config.dwStageCount; i++)
-			{
-				wbuf[3+i*3]  =  cdv->wdog[unit].config.stStages[i].dwTimeout & 0xFF;			 //stage i+1 timeout low byte
-				wbuf[4+i*3]  = (cdv->wdog[unit].config.stStages[i].dwTimeout & 0xFF00) 	>>  8;   //stage i+1 timeout middle byte
-				wbuf[5+i*3]  = (cdv->wdog[unit].config.stStages[i].dwTimeout & 0xFF0000) >> 16;	 //stage i+1 timeout high byte
-			}
-		}
-		wbuf[12] =  cdv->wdog[unit].config.dwDelay & 0xFF; 				//wd delay low byte
-		wbuf[13] = (cdv->wdog[unit].config.dwDelay & 0xFF00)   >>  8;	//wd delay middle byte
-		wbuf[14] = (cdv->wdog[unit].config.dwDelay & 0xFF0000) >> 16; 	//wd delay high byte
-
-		bcCommand(&wbuf[0],15,NULL,0,&sts);
-	}
-	else
-	{
-		return CGOS_ERROR;
-	}
-	return CGOS_SUCCESS;
-  }
-
-
-
-/***********************************************************************
- * unsigned int CgosWDogSetConfig_BC(CGOS_DRV_VARS *cdv)			  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogSetConfig(HCGOS hCgos, 					    
- * 									unsigned long dwUnit,			    
- * 									unsigned long timeout,	 		    
- * 									unsigned long delay,			    
- * 									unsigned long mode)				    
- * Inputs:															    
- * timeout 	<-> 	cdv->cin->pars[0];								    
- * delay 	<-> 	cdv->cin->pars[1];								   
- * mode 	<-> 	cdv->cin->pars[2];								    
- * 																	    
- * Outputs:															    
- * 	-																    
- * 																		
- ***********************************************************************
- * Description: Short form of CgosWDogSetConfigStruct, the information	
- * 				isn't stored in the cdv struct and sent to the BC 		
- * 				immediately.											
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/  
-unsigned int CgosWDogSetConfig_BC(CGOS_DRV_VARS *cdv)
-  {
-	unsigned char wbuf[15];
-	unsigned char sts = 0;
-	unsigned int retSuccess = CGOS_SUCCESS;
-	
-	dbgwd("CgosWDogSetConfig_BC called\n");
-	
-	wbuf[0]  = CGBC_CMD_WD_INIT;
-	wbuf[1]  = cdv->cin->pars[2];
-	if(cdv->cin->pars[2] == CGOS_WDOG_MODE_REBOOT_PC)
-	{
-		wbuf[2]  = 1 | (CGBC_WD_EVENT_RST << 2);
-	}
-	else if(cdv->cin->pars[2] == CGOS_WDOG_MODE_RESTART_OS)
-	{
-		wbuf[2]  = 1 | (CGBC_WD_EVENT_BTN << 2);
-	}
-	else
-	{
-		retSuccess = CGOS_ERROR;
-	}
-	
-	wbuf[3]  =  cdv->cin->pars[0] & 0xFF; 				//stage 1 timeout low byte
-	wbuf[4]  = (cdv->cin->pars[0] & 0xFF00)	  >>  8;	//stage 1 timeout middle byte
-	wbuf[5]  = (cdv->cin->pars[0] & 0xFF0000) >> 16; 	//stage 1 timeout high byte
-	
-	wbuf[12] =  cdv->cin->pars[1] & 0xFF; 				//wd delay low byte
-	wbuf[13] = (cdv->cin->pars[1] & 0xFF00)   >>  8;	//wd delay middle byte
-	wbuf[14] = (cdv->cin->pars[1] & 0xFF0000) >> 16; 	//wd delay high byte
-	
-	bcCommand(&wbuf[0],15,NULL,0,&sts);
-	
-	return retSuccess;
-  }
-
-/***********************************************************************
- * unsigned int CgosWDogDisable_BC(CGOS_DRV_VARS *cdv)			  		
- * 																		
- ***********************************************************************
- * Cgos Function: CgosWDogDisable(HCGOS hCgos, 						    
- * 								  unsigned long dwUnit)				   
- * 																	    
- * Inputs:															    
- * 	 -																    
- * Outputs:															    
- *   -																    
- * 																		
- ***********************************************************************
- * Description: Disables the BC watchdog.								
- * 																		
- * Last Change: 06.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/  
-unsigned int CgosWDogDisable_BC(CGOS_DRV_VARS *cdv)
-  { 
-	unsigned char wbuf[15];
-	unsigned char sts = 0;
-	
-	dbgwd("CgosWDogDisable_BC called\n");
-	
-	wbuf[0] = CGBC_CMD_WD_INIT;
-	wbuf[1] = CGBC_WD_DISABLED;
-	
-	bcCommand(&wbuf[0],15,NULL,0,&sts);
-	
-	return CGOS_SUCCESS;
-  }
-
-/***********************************************************************
- * unsigned int exitWDSubModule_BC(CGOS_DRV_VARS *cdv)					
- * 																		
- ***********************************************************************
- * Description: This function exits this SubModule.						
- * 																		
- * Last Change: 20.12.2017 HMI											
- * 																		
- * Modifications:														
- ***********************************************************************/
-unsigned int exitWDSubModule_BC(CGOS_DRV_VARS *cdv)
-{
-	dbgwd("exitWDSubModule_BC called\n");
-	return CGOS_SUCCESS;
-}
+#endif
+
+//***************************************************************************
+// Function prototypes for register function
+
+unsigned int initWDSubModule_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogGetInfo_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogCount_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogIsAvailable_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogTrigger_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogGetConfigStruct_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogSetConfigStruct_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogSetConfig_BC(CGOS_DRV_VARS *cdv);
+unsigned int CgosWDogDisable_BC(CGOS_DRV_VARS *cdv);
+unsigned int exitWDSubModule_BC(CGOS_DRV_VARS *cdv);
+
+//***************************************************************************
+
+/***********************************************************************
+ * unsigned int RegisterWDSubModule_BC									
+ * 																		
+ ***********************************************************************
+ * Description: This function uses the RegisterSubModule callback to	
+ * 			  	register the SubModule functions.						
+ * 																		
+ * Last Change: 20.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int RegisterWDSubModule_BC(unsigned int (*RegisterSubModule)(	CgosFunctionPointer initSubModule,
+																		CgosFunctionPointer GetInfo,
+																		CgosFunctionPointer Count,
+																		CgosFunctionPointer IsAvailable,
+																		CgosFunctionPointer Trigger,
+																		CgosFunctionPointer GetTriggerCount,
+																		CgosFunctionPointer SetTriggerCount,
+																		CgosFunctionPointer GetConfigStruct,
+																		CgosFunctionPointer SetConfigStruct,
+																		CgosFunctionPointer SetConfig,
+																		CgosFunctionPointer Disable,
+																		CgosFunctionPointer exitSubModule,
+																		unsigned char ModuleNumber),
+								    unsigned char Number)
+{
+	return RegisterSubModule(	initWDSubModule_BC,
+								CgosWDogGetInfo_BC,
+								CgosWDogCount_BC,
+								CgosWDogIsAvailable_BC,
+								CgosWDogTrigger_BC,
+								NULL,		//Get Trigger Count
+								NULL,		//Set Trigger Count
+								CgosWDogGetConfigStruct_BC,
+								CgosWDogSetConfigStruct_BC,
+								CgosWDogSetConfig_BC,
+								CgosWDogDisable_BC,
+								exitWDSubModule_BC,
+								Number);
+}
+
+/***********************************************************************
+ * unsigned int initWDModule_BC(CGOS_DRV_VARS *cdv) 					    
+ * 																		
+ ***********************************************************************
+ * Description: This function is called to copy information from		
+ * 				WDModule_cfg.h into the cdv struct.						
+ * 																		
+ * Last Change: 12.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int initWDSubModule_BC(CGOS_DRV_VARS *cdv)
+  {
+	int i = 0;	
+	unsigned int retSuccess = CGOS_SUCCESS;
+	dbgwd("initWDSubModule_BC called\n");	
+	if(WD_COUNT <= CGOS_DRV_WDOG_MAX)		//CGOS_DRV_WDOG_MAX defined in DrvVars.h
+	{
+		cdv->brd->wdogCount = WD_COUNT;
+	
+		for(i = 0; i < WD_COUNT; i++)
+		{
+			OsaMemCpy(&cdv->wdog[i].config,&WD_CONFIG[i],sizeof(CGOSWDCONFIG));
+			OsaMemCpy(&cdv->wdog[i].info,&WD_INFO[i],sizeof(CGOSWDINFO));
+		}
+	}
+	else
+	{
+		retSuccess = CGOS_ERROR;
+	}
+	return retSuccess;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogGetInfo_BC(CGOS_DRV_VARS *cdv)			  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogGetInfo(HCGOS hCgos, 						    
+ * 								  unsigned long dwUnit,				    
+ * 								  CGOSWDINFO *pInfo)				    
+ * Inputs:															    
+ *   dwUnit <->		cdv->cin->type					    			    
+ * 																	    
+ * Outputs:															    
+ *   pInfo 	<-> 	cdv->pout										    
+ * 																		
+ ***********************************************************************
+ * Description: Get the info struct of the watchdog.					
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogGetInfo_BC(CGOS_DRV_VARS *cdv)
+  {
+	dbgwd("CgosWDogGetInfo_BC called\n");
+	if(cdv->cin->type < cdv->brd->wdogCount)
+	{
+		OsaMemCpy(cdv->pout,&cdv->wdog[cdv->cin->type].info,sizeof(CGOSWDINFO));
+	}
+	else
+	{
+		return CGOS_ERROR;
+	}
+	cdv->retcnt += sizeof(CGOSWDINFO);
+	return CGOS_SUCCESS;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogCount_BC(CGOS_DRV_VARS *cdv)				  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogCount(HCGOS hCgos) 						    
+ * 																	    
+ * Inputs:															    
+ *   -												    			    
+ * 																	    
+ * Outputs:															    
+ *   cdv->cout->rets[0]												    
+ * 																		
+ ***********************************************************************
+ * Description: Get the number of available watchdogs.					
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogCount_BC(CGOS_DRV_VARS *cdv)
+  {
+	cdv->cout->rets[0] = cdv->brd->wdogCount;						
+	dbgwd("CgosWDogCount_BC called\n");
+	return CGOS_SUCCESS;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogIsAvailable_BC(CGOS_DRV_VARS *cdv)				
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogIsAvailable(HCGOS hCgos, 					    
+ * 									  unsigned int dwUnit)			    
+ * Inputs:															    
+ *   -												    			    
+ * 																	    
+ * Outputs:															    
+ *   cdv->cout->rets[0]												    
+ * 																		
+ ***********************************************************************
+ * Description: Check if watchdog with number dwUnit is available.		
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogIsAvailable_BC(CGOS_DRV_VARS *cdv)
+  {
+	dbgwd("CgosWDogIsAvailable_BC called\n");
+	cdv->cout->rets[0]=cdv->cin->type<cdv->brd->wdogCount;
+	return CGOS_SUCCESS;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogTrigger_BC(CGOS_DRV_VARS *cdv)			  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogTrigger(HCGOS hCgos, 						    
+ * 								  unsigned long dwUnit)				    
+ * Inputs:															    
+ *   -												    			    
+ * 																	    
+ * Outputs:															    
+ *   -																    
+ * 																		
+ ***********************************************************************
+ * Description: Triggers the watchdog dwUnit. Only BC watchdog			
+ * 				implemented at the moment.								
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogTrigger_BC(CGOS_DRV_VARS *cdv)
+  {
+	unsigned char command = CGBC_CMD_WD_TRIGGER;
+	unsigned char sts = 0;
+	dbgwd("CgosWDogTrigger_BC called\n");
+	bcCommand(&command, 1, NULL, 0, &sts); 
+	return CGOS_SUCCESS;
+  }
+  
+/***********************************************************************
+ * unsigned int CgosWDogGetTriggerCount_BC(CGOS_DRV_VARS *cdv)	  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogGetTriggerCount(HCGOS hCgos, 				    
+ * 								  		  unsigned long dwUnit)		    
+ *																	    
+ ***********************************************************************
+ * Description: Not implemented											
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogGetTriggerCount_BC(CGOS_DRV_VARS *cdv)
+  {
+    dbgwd("CgosWDogGetTriggerCount_BC called\n");
+	return CGOS_SUCCESS;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogSetTriggerCount_BC(CGOS_DRV_VARS *cdv)			
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogSetTriggerCount(HCGOS hCgos, 				    
+ * 								  		  unsigned long dwUnit)		    	
+ * 										  unsigned int cnt   		    
+ * 																		
+ ***********************************************************************
+ * Description: Not implemented											
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogSetTriggerCount_BC(CGOS_DRV_VARS *cdv)
+  {
+    dbgwd("CgosWDogSetTriggerCount_BC called\n");
+	return CGOS_SUCCESS;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogGetConfigStruct_BC(CGOS_DRV_VARS *cdv)	  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogGetConfigStruct(HCGOS hCgos, 				    
+ * 										  unsigned long dwUnit,		    
+ * 										  CGOSWDCONFIG *pConfig)	    
+ * Inputs:															    
+ *   dwUnit <->		cdv->cin->type					    			    
+ * 																	    
+ * Outputs:															    
+ * pConfig 	<-> 	cdv->pout;						 				    
+ * 																		
+ ***********************************************************************
+ * Description: Get the config struct of watchdog number dwUnit.		
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogGetConfigStruct_BC(CGOS_DRV_VARS *cdv)
+  {
+	dbgwd("CgosWDogGetConfigStruct_BC called\n");
+	if(cdv->cin->type < cdv->brd->wdogCount)
+	{
+		OsaMemCpy(cdv->pout,&cdv->wdog[cdv->cin->type].config,sizeof(CGOSWDCONFIG));
+	}
+	else
+	{
+		return CGOS_ERROR;
+	}
+	cdv->retcnt += sizeof(CGOSWDCONFIG); 
+	return CGOS_SUCCESS;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogSetConfigStruct_BC(CGOS_DRV_VARS *cdv)	  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogSetConfigStruct(HCGOS hCgos, 				    
+ * 										  unsigned long dwUnit,		    
+ * 										  CGOSWDCONFIG *pConfig)	    
+ * Inputs:															    
+ * pConfig 	<-> 	(CGOSWDCONFIG*)cdv->pin;						    
+ * dwUnit	<->		cdv->cin->type					    			    
+ * 																	    
+ * Outputs:															    
+ *   -																    
+ * 																		
+ ***********************************************************************
+ * Description: Overwrite the config struct of watchdog number dwUnit
+ * 				and send the new config struct to the board controller.	
+ * 				Only the BC watchdog is implemented at the moment.		
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int CgosWDogSetConfigStruct_BC(CGOS_DRV_VARS *cdv)
+  {
+	unsigned char wbuf[15];
+	unsigned char sts = 0;
+	unsigned int unit = cdv->cin->type;
+	int i = 0;
+	if(unit < cdv->brd->wdogCount)
+	{
+		OsaMemCpy(&cdv->wdog[unit].config,(CGOSWDCONFIG*)cdv->pin,sizeof(CGOSWDCONFIG));  
+		dbgwd("CgosWDogSetConfigStruct_BC called\n");	
+
+		wbuf[0]  = CGBC_CMD_WD_INIT;
+		wbuf[1]  = cdv->wdog[unit].config.dwOpMode; 	//wd mode
+
+		wbuf[2]  = cdv->wdog[unit].config.dwStageCount;	//wd control byte
+		for(i = 0; i < cdv->wdog[unit].config.dwStageCount; i++)
+		{
+			wbuf[2] |= (cdv->wdog[unit].config.stStages[i].dwEvent << (2*i+2)); 
+		}
+
+		if(cdv->wdog[unit].config.dwMode != CGOS_WDOG_MODE_STAGED)
+		{
+			wbuf[3]  =  cdv->wdog[unit].config.dwTimeout & 0xFF; 			 //stage 1 timeout low byte
+			wbuf[4]  = (cdv->wdog[unit].config.dwTimeout & 0xFF00)	>>  8;   //stage 1 timeout middle byte
+			wbuf[5]  = (cdv->wdog[unit].config.dwTimeout & 0xFF0000) >> 16;  //stage 1 timeout high byte
+		}
+		else if(cdv->wdog[unit].config.dwMode == CGOS_WDOG_MODE_STAGED)
+		{
+			for(i = 0; i < cdv->wdog[unit].config.dwStageCount; i++)
+			{
+				wbuf[3+i*3]  =  cdv->wdog[unit].config.stStages[i].dwTimeout & 0xFF;			 //stage i+1 timeout low byte
+				wbuf[4+i*3]  = (cdv->wdog[unit].config.stStages[i].dwTimeout & 0xFF00) 	>>  8;   //stage i+1 timeout middle byte
+				wbuf[5+i*3]  = (cdv->wdog[unit].config.stStages[i].dwTimeout & 0xFF0000) >> 16;	 //stage i+1 timeout high byte
+			}
+		}
+		wbuf[12] =  cdv->wdog[unit].config.dwDelay & 0xFF; 				//wd delay low byte
+		wbuf[13] = (cdv->wdog[unit].config.dwDelay & 0xFF00)   >>  8;	//wd delay middle byte
+		wbuf[14] = (cdv->wdog[unit].config.dwDelay & 0xFF0000) >> 16; 	//wd delay high byte
+
+		bcCommand(&wbuf[0],15,NULL,0,&sts);
+	}
+	else
+	{
+		return CGOS_ERROR;
+	}
+	return CGOS_SUCCESS;
+  }
+
+
+
+/***********************************************************************
+ * unsigned int CgosWDogSetConfig_BC(CGOS_DRV_VARS *cdv)			  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogSetConfig(HCGOS hCgos, 					    
+ * 									unsigned long dwUnit,			    
+ * 									unsigned long timeout,	 		    
+ * 									unsigned long delay,			    
+ * 									unsigned long mode)				    
+ * Inputs:															    
+ * timeout 	<-> 	cdv->cin->pars[0];								    
+ * delay 	<-> 	cdv->cin->pars[1];								   
+ * mode 	<-> 	cdv->cin->pars[2];								    
+ * 																	    
+ * Outputs:															    
+ * 	-																    
+ * 																		
+ ***********************************************************************
+ * Description: Short form of CgosWDogSetConfigStruct, the information	
+ * 				isn't stored in the cdv struct and sent to the BC 		
+ * 				immediately.											
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/  
+unsigned int CgosWDogSetConfig_BC(CGOS_DRV_VARS *cdv)
+  {
+	unsigned char wbuf[15];
+	unsigned char sts = 0;
+	unsigned int retSuccess = CGOS_SUCCESS;
+	
+	dbgwd("CgosWDogSetConfig_BC called\n");
+	
+	wbuf[0]  = CGBC_CMD_WD_INIT;
+	wbuf[1]  = cdv->cin->pars[2];
+	if(cdv->cin->pars[2] == CGOS_WDOG_MODE_REBOOT_PC)
+	{
+		wbuf[2]  = 1 | (CGBC_WD_EVENT_RST << 2);
+	}
+	else if(cdv->cin->pars[2] == CGOS_WDOG_MODE_RESTART_OS)
+	{
+		wbuf[2]  = 1 | (CGBC_WD_EVENT_BTN << 2);
+	}
+	else
+	{
+		retSuccess = CGOS_ERROR;
+	}
+	
+	wbuf[3]  =  cdv->cin->pars[0] & 0xFF; 				//stage 1 timeout low byte
+	wbuf[4]  = (cdv->cin->pars[0] & 0xFF00)	  >>  8;	//stage 1 timeout middle byte
+	wbuf[5]  = (cdv->cin->pars[0] & 0xFF0000) >> 16; 	//stage 1 timeout high byte
+	
+	wbuf[12] =  cdv->cin->pars[1] & 0xFF; 				//wd delay low byte
+	wbuf[13] = (cdv->cin->pars[1] & 0xFF00)   >>  8;	//wd delay middle byte
+	wbuf[14] = (cdv->cin->pars[1] & 0xFF0000) >> 16; 	//wd delay high byte
+	
+	bcCommand(&wbuf[0],15,NULL,0,&sts);
+	
+	return retSuccess;
+  }
+
+/***********************************************************************
+ * unsigned int CgosWDogDisable_BC(CGOS_DRV_VARS *cdv)			  		
+ * 																		
+ ***********************************************************************
+ * Cgos Function: CgosWDogDisable(HCGOS hCgos, 						    
+ * 								  unsigned long dwUnit)				   
+ * 																	    
+ * Inputs:															    
+ * 	 -																    
+ * Outputs:															    
+ *   -																    
+ * 																		
+ ***********************************************************************
+ * Description: Disables the BC watchdog.								
+ * 																		
+ * Last Change: 06.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/  
+unsigned int CgosWDogDisable_BC(CGOS_DRV_VARS *cdv)
+  { 
+	unsigned char wbuf[15];
+	unsigned char sts = 0;
+	
+	dbgwd("CgosWDogDisable_BC called\n");
+	
+	wbuf[0] = CGBC_CMD_WD_INIT;
+	wbuf[1] = CGBC_WD_DISABLED;
+	
+	bcCommand(&wbuf[0],15,NULL,0,&sts);
+	
+	return CGOS_SUCCESS;
+  }
+
+/***********************************************************************
+ * unsigned int exitWDSubModule_BC(CGOS_DRV_VARS *cdv)					
+ * 																		
+ ***********************************************************************
+ * Description: This function exits this SubModule.						
+ * 																		
+ * Last Change: 20.12.2017 HMI											
+ * 																		
+ * Modifications:														
+ ***********************************************************************/
+unsigned int exitWDSubModule_BC(CGOS_DRV_VARS *cdv)
+{
+	dbgwd("exitWDSubModule_BC called\n");
+	return CGOS_SUCCESS;
+}
diff --git a/CgosDrv/Modules/WDSubModules/WDSubModule_BC.h b/CgosDrv/Modules/WDSubModules/WDSubModule_BC.h
old mode 100755
new mode 100644
index 7a79b20..42cf545
--- a/CgosDrv/Modules/WDSubModules/WDSubModule_BC.h
+++ b/CgosDrv/Modules/WDSubModules/WDSubModule_BC.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDrv/Modules/WDSubModules/WDSubModule_BC_cfg.h b/CgosDrv/Modules/WDSubModules/WDSubModule_BC_cfg.h
old mode 100755
new mode 100644
index bc4b0ae..cc52661
--- a/CgosDrv/Modules/WDSubModules/WDSubModule_BC_cfg.h
+++ b/CgosDrv/Modules/WDSubModules/WDSubModule_BC_cfg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2017, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as 
diff --git a/CgosDump/COPYING_BSD2 b/CgosDump/COPYING_BSD2
old mode 100755
new mode 100644
diff --git a/CgosDump/CgosDump.c b/CgosDump/CgosDump.c
old mode 100755
new mode 100644
index 9d4a4fb..8b30981
--- a/CgosDump/CgosDump.c
+++ b/CgosDump/CgosDump.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosDump/CgosRprt.c b/CgosDump/CgosRprt.c
old mode 100755
new mode 100644
index c167ac3..7d179ff
--- a/CgosDump/CgosRprt.c
+++ b/CgosDump/CgosRprt.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosDump/Lx/Makefile b/CgosDump/Lx/Makefile
old mode 100755
new mode 100644
diff --git a/CgosLib/COPYING_BSD2 b/CgosLib/COPYING_BSD2
old mode 100755
new mode 100644
diff --git a/CgosLib/Cgos.c b/CgosLib/Cgos.c
old mode 100755
new mode 100644
index aae4e8c..34b7806
--- a/CgosLib/Cgos.c
+++ b/CgosLib/Cgos.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/Cgos.h b/CgosLib/Cgos.h
old mode 100755
new mode 100644
index 27ab4e2..ef7b491
--- a/CgosLib/Cgos.h
+++ b/CgosLib/Cgos.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -16,9 +16,19 @@
  *
  *---------------------------------------------------------------------------
  */
-#ifndef __linux__
-#include <Windows.h> //HMI
-#endif
+
+//MOD24 v 
+
+//#ifndef __linux__
+//#include <Windows.h> //HMI
+//#endif
+
+#ifdef _MSC_VER
+#include <Windows.h>
+#endif 
+
+//MOD24 ^
+
 //***************************************************************************
 
 #ifndef _CGOS_H_
diff --git a/CgosLib/CgosDef.h b/CgosLib/CgosDef.h
old mode 100755
new mode 100644
index 8c22e7b..0866e26
--- a/CgosLib/CgosDef.h
+++ b/CgosLib/CgosDef.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/CgosIobd.h b/CgosLib/CgosIobd.h
old mode 100755
new mode 100644
index abc342f..11dfcee
--- a/CgosLib/CgosIobd.h
+++ b/CgosLib/CgosIobd.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/CgosIoct.h b/CgosLib/CgosIoct.h
old mode 100755
new mode 100644
index 2f66496..cbc493a
--- a/CgosLib/CgosIoct.h
+++ b/CgosLib/CgosIoct.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -24,7 +24,7 @@
 
 //***************************************************************************
 
-#define CGOS_DRIVER_MAJOR 2
+#define CGOS_DRIVER_MAJOR 1
 
 //***************************************************************************
 
diff --git a/CgosLib/CgosLib.h b/CgosLib/CgosLib.h
old mode 100755
new mode 100644
index 48ef56b..91731b7
--- a/CgosLib/CgosLib.h
+++ b/CgosLib/CgosLib.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/CgosPriv.h b/CgosLib/CgosPriv.h
old mode 100755
new mode 100644
index 8c5f066..45e190b
--- a/CgosLib/CgosPriv.h
+++ b/CgosLib/CgosPriv.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/LibOsa.h b/CgosLib/LibOsa.h
old mode 100755
new mode 100644
index d6fd79f..9322595
--- a/CgosLib/LibOsa.h
+++ b/CgosLib/LibOsa.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/LibOsaM.c b/CgosLib/LibOsaM.c
old mode 100755
new mode 100644
index 89b4642..e8b9608
--- a/CgosLib/LibOsaM.c
+++ b/CgosLib/LibOsaM.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/Lx/LibOsHdr.h b/CgosLib/Lx/LibOsHdr.h
old mode 100755
new mode 100644
index 3405fd0..1748ab7
--- a/CgosLib/Lx/LibOsHdr.h
+++ b/CgosLib/Lx/LibOsHdr.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -24,7 +24,19 @@
 
 //***************************************************************************
 
-#include <stddef.h>
+//MOD24 v
+
+//#include <linux/version.h> //KARIN 
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(5,16,2)
+//#include <stddef.h>
+//#else
+//#include <linux/stddef.h>
+//#endif
+
+typedef int wchar_t;
+
+//MOD24 ^
+
 #include <string.h>
 
 //***************************************************************************
diff --git a/CgosLib/Lx/LibOsaLx.c b/CgosLib/Lx/LibOsaLx.c
old mode 100755
new mode 100644
index 8dfc1d9..b3fcd5d
--- a/CgosLib/Lx/LibOsaLx.c
+++ b/CgosLib/Lx/LibOsaLx.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosLib/Lx/Makefile b/CgosLib/Lx/Makefile
old mode 100755
new mode 100644
diff --git a/CgosMon/COPYING_BSD2 b/CgosMon/COPYING_BSD2
old mode 100755
new mode 100644
diff --git a/CgosMon/CgosMon.c b/CgosMon/CgosMon.c
old mode 100755
new mode 100644
index 5cd37b9..7475e33
--- a/CgosMon/CgosMon.c
+++ b/CgosMon/CgosMon.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosMon/Lx/Makefile b/CgosMon/Lx/Makefile
old mode 100755
new mode 100644
diff --git a/CgosMon/OsAL.h b/CgosMon/OsAL.h
old mode 100755
new mode 100644
index 6bc135d..da5a312
--- a/CgosMon/OsAL.h
+++ b/CgosMon/OsAL.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosMon/readme.txt b/CgosMon/readme.txt
old mode 100755
new mode 100644
diff --git a/CgosTest/COPYING_BSD2 b/CgosTest/COPYING_BSD2
old mode 100755
new mode 100644
diff --git a/CgosTest/Lx/Makefile b/CgosTest/Lx/Makefile
old mode 100755
new mode 100644
diff --git a/CgosTest/OsAL.h b/CgosTest/OsAL.h
old mode 100755
new mode 100644
index 2549028..5f9d2e1
--- a/CgosTest/OsAL.h
+++ b/CgosTest/OsAL.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosTest/cgostest.c b/CgosTest/cgostest.c
old mode 100755
new mode 100644
index 34f1919..a397603
--- a/CgosTest/cgostest.c
+++ b/CgosTest/cgostest.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -57,6 +57,11 @@ void HandleMonitor(int argc, _TCHAR* argv[]);
 void HandleSupported(int argc, _TCHAR* argv[]);
 void HandleGPIO(int argc, _TCHAR* argv[]);
 
+//MOD23 v moved here from generic.h
+/* temporary buffer */
+char logBuffer[512];
+//MOD23 ^
+
 #define EEP_SIZE 128
 
 /*-------------------------
diff --git a/CgosTest/cgostest.h b/CgosTest/cgostest.h
old mode 100755
new mode 100644
index c7d56f9..268d09c
--- a/CgosTest/cgostest.h
+++ b/CgosTest/cgostest.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosTest/generic.c b/CgosTest/generic.c
old mode 100755
new mode 100644
index 68128d7..83513d7
--- a/CgosTest/generic.c
+++ b/CgosTest/generic.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/CgosTest/generic.h b/CgosTest/generic.h
old mode 100755
new mode 100644
index e67011b..887fa3a
--- a/CgosTest/generic.h
+++ b/CgosTest/generic.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2019, congatec AG. All rights reserved.
+ * Copyright (c) 2022, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -17,13 +17,13 @@
  *---------------------------------------------------------------------------
  */
 
+#ifndef _GENERIC_H_	//MOD23
+#define _GENERIC_H_
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
-/* temporary buffer */
-char logBuffer[512];
-
 /* logfile */
 
 void report(char *pBuf);
@@ -33,3 +33,5 @@ void LogClose();
 void LogBuf(char *pBuf);
 unsigned char LogFlushReopen(char *);
 wchar_t *A2W(wchar_t *d, const char *s, unsigned int cnt);
+
+#endif
diff --git a/Makefile b/Makefile
old mode 100755
new mode 100644
diff --git a/Readme.txt b/Readme.txt
old mode 100755
new mode 100644
diff --git a/cgos.conf b/cgos.conf
old mode 100755
new mode 100644
