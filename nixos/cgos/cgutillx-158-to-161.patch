From 97a78cc7c3e6ec262a7605a0d312f3529a5ca864 Mon Sep 17 00:00:00 2001
From: Jan Janson <jan.janson@congatec.com>
Date: Mon, 10 Oct 2022 12:24:48 +0200
Subject: [PATCH] update cgutil v158 to v161

---
 COPYING_BSD2                   |    4 +-
 cgutlcmd/bcprgcmd.c            |   48 +-
 cgutlcmd/biosmodules.c         |    2 +-
 cgutlcmd/biosupdate.c          |    5 +-
 cgutlcmd/boardinfo.c           |    2 +-
 cgutlcmd/cgutil.h              |    2 +-
 cgutlcmd/cgutlcmd.c            |    6 +-
 cgutlcmd/firmwareupdate.c      |    2 +-
 cgutlcmn/atmelavr.h            |    2 +-
 cgutlcmn/bcprg.h               |   29 +-
 cgutlcmn/bcprgcmn.c            |  660 +++++++++++-
 cgutlcmn/biosflsh.c            |  315 +++++-
 cgutlcmn/biosflsh.h            |   32 +-
 cgutlcmn/cgbc.h                | 1860 ++++++++++++++++++++++++++++----
 cgutlcmn/cgbinfo.h             |    2 +-
 cgutlcmn/cgbmod.h              |    2 +-
 cgutlcmn/cgepi.c               |    2 +-
 cgutlcmn/cginfo.c              |    8 +-
 cgutlcmn/cginfo.h              |    2 +-
 cgutlcmn/cgmpfa.c              |    2 +-
 cgutlcmn/cgmpfa.h              |    2 +-
 cgutlcmn/cgmpnv.h              |    2 +-
 cgutlcmn/cgos.h                |    2 +-
 cgutlcmn/cgospriv.h            |    2 +-
 cgutlcmn/cgpanel.h             |    2 +-
 cgutlcmn/cgutlcmn.c            |   18 +-
 cgutlcmn/cgutlcmn.h            |    4 +-
 cgutlcmn/dmstobin.c            |    2 +-
 cgutlcmn/dmstobin.h            |    2 +-
 cgutlcmn/history.txt           |   63 ++
 cgutlcmn/mc17avr.h             |  196 +++-
 cgutlcmn/stm32avr.h            |    2 +-
 cgutlcmn/tivaavr.h             |    2 +-
 congatec_oem_smbios_sample.dms |   62 +-
 version.txt                    |   51 +
 35 files changed, 3010 insertions(+), 389 deletions(-)

diff --git a/COPYING_BSD2 b/COPYING_BSD2
index 3f6c903..b3a6390 100644
--- a/COPYING_BSD2
+++ b/COPYING_BSD2
@@ -1,4 +1,4 @@
-Copyright (c) 2018 congatec AG. All rights reserved.
+Copyright (c) 2021 congatec GmbH. All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
@@ -22,4 +22,4 @@ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
-OF SUCH DAMAGE.
\ No newline at end of file
+OF SUCH DAMAGE.
diff --git a/cgutlcmd/bcprgcmd.c b/cgutlcmd/bcprgcmd.c
index e01025d..29544d1 100644
--- a/cgutlcmd/bcprgcmd.c
+++ b/cgutlcmd/bcprgcmd.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -18,8 +18,6 @@
  */
 
 /*---------------------------------------------------------------------------
- *
- * $Header:   S:/CG/archives/CGTOOLS/CGUTIL/W32DOSX/CGUTLCMD/BCPRGCMD.C-arc   1.14   Sep 06 2016 16:23:42   congatec  $
  *
  * Contents: Board controller firmware update command line module.
  *
@@ -27,7 +25,15 @@
  *
  *                      R E V I S I O N   H I S T O R Y
  *
- * $Log:   S:/CG/archives/CGTOOLS/CGUTIL/W32DOSX/CGUTLCMD/BCPRGCMD.C-arc  $
+ * MOD014: Added support for all MEC170x variants in the 144 pin WFBGA package.
+ *
+ * MOD013: added support for the /!cidoverride switch.
+ *
+ * MOD012: added support for MEC1706
+ *
+ * MOD011: Revised PrintMessage().
+ *
+ * MOD010: added support for MEC1705
  * 
  *    Rev 1.14   Sep 06 2016 16:23:42   congatec
  * Added BSD header.
@@ -176,7 +182,21 @@ static _TCHAR *messages[] = {
  _T("ATmega325P\n"),                                 // BCPRG_FOUND_ATMEGA325P //MOD005
  _T("STM32F100R8\n"),                                // BCPRG_FOUND_STM32F100R8 //MOD008
  _T("TM4E1231H6ZRB\n"),                              // BCPRG_FOUND_TM4E1231H6ZRB //MOD009
+ _T("MEC1701HSZ\n"),                                 // BCPRG_FOUND_MEC1701HSZ //MOD014
+ _T("MEC1701KSZ\n"),                                 // BCPRG_FOUND_MEC1701KSZ //MOD014
+ _T("MEC1701QSZ\n"),                                 // BCPRG_FOUND_MEC1701QSZ //MOD014
+ _T("MEC1703HSZ\n"),                                 // BCPRG_FOUND_MEC1703HSZ //MOD014
+ _T("MEC1703KSZ\n"),                                 // BCPRG_FOUND_MEC1703KSZ //MOD014
+ _T("MEC1703QSZ\n"),                                 // BCPRG_FOUND_MEC1703QSZ //MOD014
+ _T("MEC1704HSZ\n"),                                 // BCPRG_FOUND_MEC1704HSZ //MOD014
+ _T("MEC1704KSZ\n"),                                 // BCPRG_FOUND_MEC1704KSZ //MOD014
+ _T("MEC1704QSZ\n"),                                 // BCPRG_FOUND_MEC1704QSZ //MOD014
+ _T("MEC1705HSZ\n"),                                 // BCPRG_FOUND_MEC1705HSZ //MOD014
+ _T("MEC1705KSZ\n"),                                 // BCPRG_FOUND_MEC1705KSZ //MOD014
  _T("MEC1705QSZ\n"),                                 // BCPRG_FOUND_MEC1705QSZ //MOD010
+ _T("MEC1706HSZ\n"),                                 // BCPRG_FOUND_MEC1706HSZ //MOD014
+ _T("MEC1706KSZ\n"),                                 // BCPRG_FOUND_MEC1706KSZ //MOD014
+ _T("MEC1706QSZ\n"),                                 // BCPRG_FOUND_MEC1706QSZ //MOD012
  _T("Checking locks and fuses. . . . "),             // BCPRG_CHECK_FUSES_BEFORE
  _T("EEPROM is unprotected"),                        // BCPRG_BAD_FUSES_ERROR
  passedMes,                                          // BCPRG_CHECK_FUSES_AFTER
@@ -324,6 +344,12 @@ static void ParseArguments( INT32 argc, _TCHAR **argv )
                          flags |= BCPRG_NFP_SWITCH;
                         }
                                                                       //MOD002^
+                                                                      //MOD013v  
+                      if( !STRCMP( &argv[i][2], _T("cidoverride") ) )
+                        {
+                         flags |= BCPRG_CID_OVR_SWITCH;
+                        }
+                                                                      //MOD013^
                       break;
 
           default:
@@ -518,7 +544,21 @@ static void (*errHandlerTbl[])() = {
                                     NULL,      // BCPRG_FOUND_ATMEGA325P //MOD006
                                     NULL,      // BCPRG_FOUND_STM32F100R8 //MOD008
                                     NULL,      // BCPRG_FOUND_TM4E1231H6ZRB //MOD009
+                                    NULL,      // BCPRG_FOUND_MEC1701HSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1701KSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1701QSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1703HSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1703KSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1703QSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1704HSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1704KSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1704QSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1705HSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1705KSZ //MOD014
                                     NULL,      // BCPRG_FOUND_MEC1705QSZ //MOD010
+                                    NULL,      // BCPRG_FOUND_MEC1706HSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1706KSZ //MOD014
+                                    NULL,      // BCPRG_FOUND_MEC1706QSZ //MOD012
                                     NULL,      // BCPRG_CHECK_FUSES_BEFORE
                                     StdErr,    // BCPRG_BAD_FUSES_ERROR
                                     NULL,      // BCPRG_CHECK_FUSES_AFTER
diff --git a/cgutlcmd/biosmodules.c b/cgutlcmd/biosmodules.c
index 49e8860..effaf1f 100644
--- a/cgutlcmd/biosmodules.c
+++ b/cgutlcmd/biosmodules.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmd/biosupdate.c b/cgutlcmd/biosupdate.c
index 4133767..1e890d1 100644
--- a/cgutlcmd/biosupdate.c
+++ b/cgutlcmd/biosupdate.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -139,8 +139,7 @@ static void ShowUsage(void)
 		PRINTF(_T("/C       - Invalidate CMOS.\n"));														
         PRINTF(_T("/NOC     - Do not invalidate CMOS (DEFAULT).\n"));
 		PRINTF(_T("/P       - Preserve BIOS password.\n"));											//MOD007	
-        PRINTF(_T("/LAN     - Restore LAN area(s) when running an extended update.\n"));			//MOD008	
-				
+		PRINTF(_T("/LAN     - Restore LAN area(s) when running an extended update.\n"));         	//MOD008	
 		PRINTF(_T("/AOO     - Perform immediate/automatic off-on cycle to unlock extended\n"));				
 		PRINTF(_T("           BIOS area if necessary. (Default for DOS and UEFI)\n"));
 		PRINTF(_T("/NAOO    - Do NOT perform immediate/automatic off-on cycle to unlock extended\n"));				
diff --git a/cgutlcmd/boardinfo.c b/cgutlcmd/boardinfo.c
index aec26a1..fc7b800 100644
--- a/cgutlcmd/boardinfo.c
+++ b/cgutlcmd/boardinfo.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmd/cgutil.h b/cgutlcmd/cgutil.h
index 3826b55..96a11ae 100644
--- a/cgutlcmd/cgutil.h
+++ b/cgutlcmd/cgutil.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmd/cgutlcmd.c b/cgutlcmd/cgutlcmd.c
index 9f53f2f..007fcce 100644
--- a/cgutlcmd/cgutlcmd.c
+++ b/cgutlcmd/cgutlcmd.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2015, congatec AG. All rights reserved.
+ * Copyright (c) 2015, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -112,7 +112,7 @@ extern void HandleInfo(INT32 argc, _TCHAR* argv[]);
  * Local definitions
  *--------------------
  */
-#define BUILD_NUMBER            8
+#define BUILD_NUMBER            1
 
 #define CGEVAL                  0
 // Major and minor version number are defined in cgutlcmn.h
@@ -130,7 +130,7 @@ typedef struct
  */
 static _TCHAR signonMes[] = "\n"
                             "congatec System Configuration Utility ---  Version %d.%d.%d\n"                            
-                            "(C) Copyright 2005-2018 congatec AG\n\n"; 
+                            "(C) Copyright 2005-2021 congatec GmbH\n\n"; 
 
 static CG_UTIL_MODULE moduleList[] =   {
                                 {"BCPROG", "Board Controller Firmware Update Module", HandleFirmwareUpdate},
diff --git a/cgutlcmd/firmwareupdate.c b/cgutlcmd/firmwareupdate.c
index 3757f97..78f2af6 100644
--- a/cgutlcmd/firmwareupdate.c
+++ b/cgutlcmd/firmwareupdate.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/atmelavr.h b/cgutlcmn/atmelavr.h
index 7c7c2d1..108b95f 100644
--- a/cgutlcmn/atmelavr.h
+++ b/cgutlcmn/atmelavr.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/bcprg.h b/cgutlcmn/bcprg.h
index 267b3b1..4dc02a4 100644
--- a/cgutlcmn/bcprg.h
+++ b/cgutlcmn/bcprg.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -18,8 +18,6 @@
  */
 
 /*---------------------------------------------------------------------------
- *
- * $Header:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/BCPRG.H-arc   1.9   Sep 06 2016 15:18:12   congatec  $
  *
  * Contents: Board controller firmware update common module definitions.
  *
@@ -27,7 +25,14 @@
  *
  *                      R E V I S I O N   H I S T O R Y
  *
- * $Log:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/BCPRG.H-arc  $
+ * MOD012: Added support for all MEC170x variants in the 144 pin WFBGA package.
+ *
+ * MOD011: added support for the /!cidoverride switch and the AVR SPM extension
+ *         commands.
+ *
+ * MOD010: added support for MEC1706
+ *
+ * MOD009: added support for MEC1705
  * 
  *    Rev 1.9   Sep 06 2016 15:18:12   congatec
  * Updated BSD header.
@@ -103,6 +108,8 @@ extern "C" {
 #define  BCPRG_BB_BOTTOM        0x400000                             //MOD007
 #define  BCPRG_EEEP_SUPPORT     0x800000                             //MOD007
 #define  BCPRG_AVR_DISABLE_CMD 0x1000000                             //MOD009
+#define  BCPRG_CID_OVR_SWITCH  0x2000000                             //MOD011
+#define  BCPRG_SPM_EXT_SUPPORT 0x4000000                             //MOD011
 
 
 /*--------------------------
@@ -152,7 +159,21 @@ enum  {
        BCPRG_FOUND_ATMEGA325P,                                       //MOD004
        BCPRG_FOUND_STM32F100R8,                                      //MOD006
        BCPRG_FOUND_TM4E1231H6ZRB,                                    //MOD008
+       BCPRG_FOUND_MEC1701HSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1701KSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1701QSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1703HSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1703KSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1703QSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1704HSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1704KSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1704QSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1705HSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1705KSZ,                                       //MOD012
        BCPRG_FOUND_MEC1705QSZ,                                       //MOD009
+       BCPRG_FOUND_MEC1706HSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1706KSZ,                                       //MOD012
+       BCPRG_FOUND_MEC1706QSZ,                                       //MOD010
        BCPRG_CHECK_FUSES_BEFORE,
        BCPRG_BAD_FUSES_ERROR,
        BCPRG_CHECK_FUSES_AFTER,
diff --git a/cgutlcmn/bcprgcmn.c b/cgutlcmn/bcprgcmn.c
index 34802a7..76d9c33 100644
--- a/cgutlcmn/bcprgcmn.c
+++ b/cgutlcmn/bcprgcmn.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -18,8 +18,6 @@
  */
 
 /*---------------------------------------------------------------------------
- *
- * $Header:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/BCPRGCMN.C-arc   1.16   Sep 07 2016 12:24:56   congatec  $
  *
  * Contents: Board controller firmware update common implementation module.
  *
@@ -27,7 +25,19 @@
  *
  *                      R E V I S I O N   H I S T O R Y
  *
- * $Log:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/BCPRGCMN.C-arc  $
+ * MOD024: Added support for all MEC170x variants in the 144 pin WFBGA package.
+ *
+ * MOD023: added support for the /!cidoverride switch.
+ *
+ * MOD022: added support for MEC1706
+ * 
+ * MOD021: changes for a better flash read/write performance during a firmware
+ *         update on GEN5 cBC based designs
+ *
+ * MOD020: changes to skip verifying 0xFF data bytes by default in case of the
+ *         GEN5 cBC family
+ *
+ * MOD019: added support for the GEN5 cBC family
  * 
  *    Rev 1.16   Sep 07 2016 12:24:56   congatec
  * Fixed type conversion warnings.
@@ -193,6 +203,8 @@ static char nlNl[]             = "\n\n";
 #endif //_CONSOLE
 
 static char verifyInfoPat8[]   = _T("offset: %04Xh  expected: %02Xh  found: %02Xh");
+static char verifyInfoPat8L[]  = _T("offset: %08Xh  expected: %02Xh  found: %02Xh"); //MOD021
+static char flashReadErrMsg[]  = _T("flash page read error");                        //MOD021
 static char verifyInfoPat16[]  = _T("offset: %04Xh  expected: %04Xh  found: %04Xh");
 static char verifyInfoPatF[]   = _T("fuses: %c  expected: %02Xh  found: %02Xh");
 static char verifyInfoPatL[]   = _T("expected: %02Xh  found: %02Xh");
@@ -552,7 +564,23 @@ static INT32 HandleHexData( char *pDat, UINT32 adr,
 }
 
 
+                                                                      //MOD021v
+static int iCheckFF16( UINT32 idx )
+{
+  UINT32 i;
+
+  for( i = 0; i < 16; i = i + 1 )
+    {
+      if( pFlsBuf[idx+i] != 0xFF )
+        {
+          return( 0 );
+        }
+    }
+  return( 1 );
+}
+                                                                      //MOD021^
 
+                                                                      
 static INT32 ReadDatFile( void )
 {
  P_HEX_REC pRec;
@@ -613,11 +641,23 @@ static INT32 ReadDatFile( void )
           BCPRG_VERBOSE_PRINTF( flsTag, NULL, NULL );
           for( i=0; i<MAX_FLS_SIZ; i++ )
             {
+                                                                      //MOD021v
              if( !(i % 16) )
                {
-                BCPRG_VERBOSE_PRINTF( "\n%04X: ", i, NULL );
+                while( (iCheckFF16( i ) != 0) && (i < MAX_FLS_SIZ) )
+                  {
+                   i = i + 16;
+                  }
                }
-             BCPRG_VERBOSE_PRINTF( "%02X ", pFlsBuf[i], NULL );
+             if( i < MAX_FLS_SIZ )
+               {
+                                                                      //MOD021^
+                if( !(i % 16) )
+                  {
+                   BCPRG_VERBOSE_PRINTF( "\n%04X: ", i, NULL );
+                  }
+                BCPRG_VERBOSE_PRINTF( "%02X ", pFlsBuf[i], NULL );
+               }                                                      //MOD021
             }
           BCPRG_VERBOSE_PRINTF( "\n", NULL, NULL );
           BCPRG_VERBOSE_PRINTF( eepTag, NULL, NULL );
@@ -1199,6 +1239,216 @@ static INT32 CheckDeviceType( void )
                                            BCPRG_EEEP_SUPPORT;
                                   break;
                                                                      //MOD015^
+                                                                     //MOD024v
+    case MEC1701HSZ_SIGNATURE:
+                                  flsSiz = MEC1701HSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1701HSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1701HSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1701HSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1701KSZ_SIGNATURE:
+                                  flsSiz = MEC1701KSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1701KSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1701KSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1701KSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1701QSZ_SIGNATURE:
+                                  flsSiz = MEC1701QSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1701QSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1701QSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1701QSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1703HSZ_SIGNATURE:
+                                  flsSiz = MEC1703HSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1703HSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1703HSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1703HSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1703KSZ_SIGNATURE:
+                                  flsSiz = MEC1703KSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1703KSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1703KSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1703KSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1703QSZ_SIGNATURE:
+                                  flsSiz = MEC1703QSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1703QSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1703QSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1703QSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1704HSZ_SIGNATURE:
+                                  flsSiz = MEC1704HSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1704HSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1704HSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1704HSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1704KSZ_SIGNATURE:
+                                  flsSiz = MEC1704KSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1704KSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1704KSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1704KSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1704QSZ_SIGNATURE:
+                                  flsSiz = MEC1704QSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1704QSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1704QSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1704QSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1705HSZ_SIGNATURE:
+                                  flsSiz = MEC1705HSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1705HSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1705HSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1705HSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1705KSZ_SIGNATURE:
+                                  flsSiz = MEC1705KSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1705KSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1705KSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1705KSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+                                                                     //MOD024^
                                                                      //MOD019v
     case MEC1705QSZ_SIGNATURE:
                                   flsSiz = MEC1705QSZ_FLASH_SIZE;
@@ -1215,9 +1465,69 @@ static INT32 CheckDeviceType( void )
                                   lbModeProgDisabled = 0;
                                   mfgStart = 0;
                                   flags |= BCPRG_AVR_DISABLE_CMD;
-                                  flags |= BCPRG_SKIP_VERIFY_FF; //MOD020
+                                  flags |= BCPRG_SKIP_VERIFY_FF;     //MOD020
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;    //MOD021
                                   break;
                                                                      //MOD019^
+                                                                     //MOD024v
+    case MEC1706HSZ_SIGNATURE:
+                                  flsSiz = MEC1706HSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1706HSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1706HSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1706HSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+
+    case MEC1706KSZ_SIGNATURE:
+                                  flsSiz = MEC1706KSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1706KSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1706KSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1706KSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+                                                                     //MOD024^
+                                                                     //MOD022v
+    case MEC1706QSZ_SIGNATURE:
+                                  flsSiz = MEC1706QSZ_FLASH_SIZE;
+                                  flsPageSiz = MEC1706QSZ_FLASH_PAGE_SIZE;
+                                  eepSiz = MEC1706QSZ_EEPROM_SIZE;
+                                  BcprgShowProgress( BCPRG_FOUND_MEC1706QSZ );
+                                  pEesave = &curFusesH;
+                                  eesaveMsk = MC17_FUSE_EESAVE;
+                                  pSpien = NULL;
+                                  pRstdisbl = NULL;
+                                  pCksel = NULL;
+                                  lbModeMsk = 0;
+                                  lbModeProgEnabled = 0;
+                                  lbModeProgDisabled = 0;
+                                  mfgStart = 0;
+                                  flags |= BCPRG_AVR_DISABLE_CMD;
+                                  flags |= BCPRG_SKIP_VERIFY_FF;
+                                  flags |= BCPRG_SPM_EXT_SUPPORT;
+                                  break;
+                                                                     //MOD022^
     default:                                       
                                   return( BCPRG_UNKNOWN_DEVICE_ERROR );
    }
@@ -1800,6 +2110,218 @@ static INT32 AvrSpmProgramFlsPage( UINT32 adr, unsigned char *pBuf,
 }
 
 
+                                                                     //MOD021v
+static uint32_t ui32Gen5PgSize;
+
+static int iSkipFlsPage( uint32_t ui32PageIdx )
+{
+  uint32_t *pui32Blk;
+  uint32_t   ui32Idx;
+
+  if( (flags & BCPRG_SKIP_VERIFY_FF) == 0 )
+    {
+      return( 0 );
+    }
+
+  pui32Blk = (uint32_t *)(&pFlsBuf[ui32PageIdx]);
+  for( ui32Idx = 0; ui32Idx < (ui32Gen5PgSize/4); ui32Idx = ui32Idx + 1 )
+    {
+      if( pui32Blk[ui32Idx] != 0xFFFFFFFF )
+        {
+          return( 0 );
+        }
+    }
+  return( 1 );
+}
+
+cgosret_bool Gen5SetFlashPageAddr( uint32_t ui32FlashPageAddress )
+{
+  unsigned char wbuf[6];
+  cgosret_bool  cgosRet;
+  UINT32        sts;
+
+  wbuf[0] = CGBC_CMD_AVR_SPM_EXT;
+  wbuf[1] = CGBC_CMD_AVR_SPM_FLS_ADDR;
+  wbuf[2] = (uint8_t)(ui32FlashPageAddress >>  0);
+  wbuf[3] = (uint8_t)(ui32FlashPageAddress >>  8);
+  wbuf[4] = (uint8_t)(ui32FlashPageAddress >> 16);
+  wbuf[5] = (uint8_t)(ui32FlashPageAddress >> 24);
+  cgosRet = CgosCgbcHandleCommand( hCgos, &wbuf[0], 6, NULL, 0, &sts );
+  if( cgosRet != 0 )
+    {
+      if( (sts & CGBC_STAT_MSK) != CGBC_RDY_STAT )
+        {
+          cgosRet = 0;
+        }
+    }
+  return( cgosRet );
+}
+
+
+
+uint8_t Gen5GetFlashCtlrSts( uint32_t *pui32FlsPageSize )
+{
+  unsigned char wbuf[2];
+  unsigned char rbuf[5];
+  UINT32        sts;
+
+  wbuf[0] = CGBC_CMD_AVR_SPM_EXT;
+  wbuf[1] = CGBC_CMD_AVR_SPM_FLS_STAT;
+  if( CgosCgbcHandleCommand( hCgos, &wbuf[0], 2, &rbuf[0], 5, &sts ) != 0 )
+    {
+      if( ((sts & CGBC_STAT_MSK   ) == CGBC_RDY_STAT )  &&
+          ((sts & CGBC_DAT_PENDING) != 0             )  &&
+          ((sts & CGBC_DAT_CNT_MSK) == (5-1)         )     )
+        {
+          if( pui32FlsPageSize != NULL )
+            {
+              *pui32FlsPageSize = *((uint32_t *)(&(rbuf[1])));
+            }
+          return( rbuf[0] );
+        }
+    }
+  return( CGBC_AVR_SPM_FLS_ERR );
+}
+
+
+
+cgosret_bool Gen5WriteFlashPage( uint8_t *pui8WrDat )
+{
+  unsigned char wbuf[34];
+  cgosret_bool  cgosRet;
+  UINT32        sts;
+  uint32_t  ui32Idx;
+
+  for( cgosRet = 1,
+       ui32Idx = 0; (   (cgosRet != 0             )
+                     && (ui32Idx <  ui32Gen5PgSize)); ui32Idx = ui32Idx + 32 )
+    {
+      wbuf[0] = CGBC_CMD_AVR_SPM_EXT;
+      wbuf[1] = CGBC_CMD_AVR_SPM_FLS_WR32;
+      memcpy( &wbuf[2], &pui8WrDat[ui32Idx], 32 );
+      cgosRet = CgosCgbcHandleCommand( hCgos, &wbuf[0], 34, NULL, 0, &sts );
+      if( cgosRet != 0 )
+        {
+          if( (sts & CGBC_STAT_MSK) != CGBC_RDY_STAT )
+            {
+              cgosRet = 0;
+            }
+        }
+    }
+  return( cgosRet );    
+}
+
+
+
+cgosret_bool Gen5ReadFlashPage( uint8_t *pui8RdDat )
+{
+  unsigned char wbuf[2];
+  cgosret_bool  cgosRet;
+  UINT32        sts;
+  uint32_t  ui32Idx;
+
+  for( cgosRet = 1,
+       ui32Idx = 0; (   (cgosRet != 0             )
+                     && (ui32Idx <  ui32Gen5PgSize)); ui32Idx = ui32Idx + 32 )
+    {
+      wbuf[0] = CGBC_CMD_AVR_SPM_EXT;
+      wbuf[1] = CGBC_CMD_AVR_SPM_FLS_RD32;
+      cgosRet = CgosCgbcHandleCommand( hCgos, &wbuf[0],       2,
+                                              &pui8RdDat[ui32Idx], 32, &sts );
+      if( cgosRet != 0 )
+        {
+          if( ((sts & CGBC_STAT_MSK   ) != CGBC_RDY_STAT )  ||
+              ((sts & CGBC_DAT_PENDING) == 0             )  ||
+              ((sts & CGBC_DAT_CNT_MSK) != (32-1)        )     )
+            {
+              cgosRet = 0;
+            }
+        }
+    }
+  return( cgosRet );    
+}
+
+
+
+static INT32 Gen5ProgramFls( void )
+{
+  UINT32 i, j;
+  INT32  ret;
+  int    iSkipped;
+
+  BcprgShowProgress( BCPRG_PROGRAM_FLS_BEFORE );
+
+  BCPRG_VERBOSE_OPEN
+  BCPRG_VERBOSE_PRINTF( nl, NULL, NULL );
+  BCPRG_VERBOSE_PRINTF( verboseStartMes, NULL, NULL );
+  BCPRG_VERBOSE_CLOSE
+
+  ret = BCPRG_PASSED;
+  iSkipped = 1;
+  for( i = 0; (   (i   <  codeSiz     )
+               && (ret == BCPRG_PASSED)); i = i + ui32Gen5PgSize )
+    {
+      while( (iSkipFlsPage( i ) != 0) && (i < codeSiz) )
+        {
+          iSkipped = 1;
+          i = i + ui32Gen5PgSize;
+        }
+      if( i < codeSiz )
+        {
+          if( iSkipped != 0 )
+            {
+              if( Gen5SetFlashPageAddr( i ) == 0 )
+                {
+                  ret = BCPRG_PROGRAM_FLS_ERROR;
+                }
+              iSkipped = 0;
+            }
+          if( ret == BCPRG_PASSED )
+            {
+              BCPRG_VERBOSE_OPEN
+              for( j = 0; j < ui32Gen5PgSize; j++ )
+                {
+                  if( (j & 0x0F) == 0 )
+                    {
+                     BCPRG_VERBOSE_PRINTF( "%08X:", i+j, NULL );
+                    }
+                  if( (j & 0x0F) == 8 )
+                    {
+                     BCPRG_VERBOSE_PRINTF( "-%02X", pFlsBuf[i+j], NULL );
+                    }
+                  else
+                    {
+                     BCPRG_VERBOSE_PRINTF( " %02X", pFlsBuf[i+j], NULL );
+                    }
+                  if( (j & 0x0F) == 15 )
+                    {
+                     BCPRG_VERBOSE_PRINTF( nl, NULL, NULL );
+                    }
+                }
+              BCPRG_VERBOSE_CLOSE
+    
+              if( Gen5WriteFlashPage( &pFlsBuf[i] ) == 0 )
+                {
+                 ret = BCPRG_PROGRAM_FLS_ERROR;
+                }
+            }
+        }
+    }
+
+  while( Gen5GetFlashCtlrSts( NULL ) == CGBC_AVR_SPM_FLS_BSY );
+
+  BCPRG_VERBOSE_OPEN
+  BCPRG_VERBOSE_PRINTF( verboseEndMes, NULL, NULL );
+  BCPRG_VERBOSE_CLOSE
+
+  if( ret == BCPRG_PASSED )
+    {
+      BcprgShowProgress( BCPRG_PROGRAM_FLS_AFTER );
+    }
+ return( ret );
+}
+                                                                     //MOD021^
+
 
 static INT32 ProgramFls( void )
 {
@@ -1821,7 +2343,22 @@ static INT32 ProgramFls( void )
        return( BCPRG_CHECK_FLS_SPACE_ERROR );
       }
     BcprgShowProgress( BCPRG_CHECK_FLS_SPACE_AFTER );
-
+                                                                     //MOD021v
+    /* When the design supports the extended AVR SPM commands then a faster
+     * programming procedure can be used.  Note!  The Tiva cBC bootblock
+     * firmware hangs as soon as it receives any other cBC command than the
+     * standard AVR SPM commands.  Therefore the check whether the extended AVR
+     * SPM commands are supported cannot be done by just executing one of them.
+     * Instead the BCPRG_SPM_EXT_SUPPORT flag is used first to see whether the
+     * running cBC can support them at all. */
+    if( (flags & BCPRG_SPM_EXT_SUPPORT) != 0 )
+      {
+        if( Gen5GetFlashCtlrSts( &ui32Gen5PgSize ) != CGBC_AVR_SPM_FLS_ERR )
+          {
+            return( Gen5ProgramFls() );
+          }
+      }
+                                                                     //MOD021^
     BcprgShowProgress( BCPRG_PROGRAM_FLS_BEFORE );
 
     BCPRG_VERBOSE_OPEN
@@ -2299,6 +2836,82 @@ static void DetermineVerificationArea( UINT32 *pOffsetStart,
 }
                                                               //MOD006 MOD012^
 
+                                                                     //MOD021v
+static INT32 Gen5VerifyFls( void )
+{
+  UINT32       i, j;
+  INT32        ret;
+  int         iSkipped;
+  UINT32       verEnd;
+  UINT32       verStart;
+  uint8_t *pui8PgBuf;
+
+  BcprgShowProgress( BCPRG_VERIFY_FLS_BEFORE );
+
+  pui8PgBuf = malloc( ui32Gen5PgSize );
+  if( pui8PgBuf == NULL )
+    {
+     return( BCPRG_MALLOC_ERROR );
+    }
+
+  DetermineVerificationArea( &verStart, &verEnd );
+
+  ret = BCPRG_PASSED;
+  iSkipped = 1;
+  for( i = verStart; (   (i   <  verEnd      )
+                      && (ret == BCPRG_PASSED)); i = i + ui32Gen5PgSize )
+    {
+      while( (iSkipFlsPage( i ) != 0) && (i < verEnd) )
+        {
+          iSkipped = 1;
+          i = i + ui32Gen5PgSize;
+        }
+      if( i < verEnd )
+        {
+          if( iSkipped != 0 )
+            {
+              if( Gen5SetFlashPageAddr( i ) == 0 )
+                {
+                  ret = BCPRG_PROGRAM_FLS_ERROR;
+                }
+              iSkipped = 0;
+            }
+          if( ret == BCPRG_PASSED )
+            {
+              if( Gen5ReadFlashPage( pui8PgBuf ) == 0 )
+                {
+                  strcpy( infoMesBuf, flashReadErrMsg );
+                  ret = BCPRG_VERIFY_FLS_ERROR;
+                }
+            }
+          if( ret == BCPRG_PASSED )
+            {
+              if( memcmp( pui8PgBuf, &pFlsBuf[i], ui32Gen5PgSize ) != 0 )
+                {
+                  for( j = 0; j < ui32Gen5PgSize; j = j + 1 )
+                    {
+                      if( pui8PgBuf[j] != pFlsBuf[j+i] )
+                        {
+                          SPRINTF( infoMesBuf,
+                                   verifyInfoPat8L,
+                                   j+i, pFlsBuf[j+i], pui8PgBuf[j] );
+                          ret = BCPRG_VERIFY_FLS_ERROR;
+                        }
+                      j++;
+                    }
+                }
+            }
+        }          
+    }
+
+  if( ret == BCPRG_PASSED )
+    {
+      BcprgShowProgress( BCPRG_VERIFY_FLS_AFTER );
+    }
+ return( ret );
+}
+                                                                     //MOD021^
+
 
 static INT32 VerifyFls( void )
 {
@@ -2306,11 +2919,27 @@ static INT32 VerifyFls( void )
  UINT32 in;
  UINT32 out;
  UINT32 cnt;
- UINT32 verEnd;                                         //MOD006 MOD012
- UINT32 verStart;                                              //MOD012
+ UINT32 verEnd;                                               //MOD006 MOD012
+ UINT32 verStart;                                                    //MOD012
 
  if( (flags & BCPRG_FLS_PROG_REQ)  &&  !(flags & BCPRG_SKIP_VERIFY) )
    {
+                                                                     //MOD021v
+    /* When the design supports the extended AVR SPM commands then a faster
+     * verification procedure can be used.  Note!  The Tiva cBC bootblock
+     * firmware hangs as soon as it receives any other cBC command than the
+     * standard AVR SPM commands.  Therefore the check whether the extended AVR
+     * SPM commands are supported cannot be done by just executing one of them.
+     * Instead the BCPRG_SPM_EXT_SUPPORT flag is used first to see whether the
+     * running cBC can support them at all. */
+    if( (flags & BCPRG_SPM_EXT_SUPPORT) != 0 )
+      {
+       if( Gen5GetFlashCtlrSts( &ui32Gen5PgSize ) != CGBC_AVR_SPM_FLS_ERR )
+         {
+          return( Gen5VerifyFls() );
+         }
+      }
+                                                                     //MOD021^
     BcprgShowProgress( BCPRG_VERIFY_FLS_BEFORE );
                                                                      //MOD006v
     DetermineVerificationArea( &verStart, &verEnd );                 //MOD012
@@ -2647,10 +3276,13 @@ static INT32 CheckCompatibility( void )
  BCPRG_VERBOSE_PRINTF( verboseEndMes, NULL, NULL );
  BCPRG_VERBOSE_CLOSE
 
- if( (curCid != -1) && (curCid != cgbcCid) )
-   {
-    return( BCPRG_CHECK_COMPATIBILITY_ERROR );
-   }
+ if( (flags & BCPRG_CID_OVR_SWITCH) == 0 )                           //MOD023
+   {                                                                 //MOD023
+    if( (curCid != -1) && (curCid != cgbcCid) )
+      {
+       return( BCPRG_CHECK_COMPATIBILITY_ERROR );
+      }
+   }                                                                 //MOD023
 
  BcprgShowProgress( BCPRG_CHECK_COMPATIBILITY_AFTER );
  return( BCPRG_PASSED );
diff --git a/cgutlcmn/biosflsh.c b/cgutlcmn/biosflsh.c
index ff29775..3d88238 100644
--- a/cgutlcmn/biosflsh.c
+++ b/cgutlcmn/biosflsh.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2018, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -16,18 +16,24 @@
  *
  *---------------------------------------------------------------------------
  */
-
-/*---------------------------------------------------------------------------
- *
- * $Header:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/BIOSFLSH.C-arc   1.15   Sep 06 2016 15:42:24   congatec  $
- *
- * Contents: Congatec BIOS update common implementation module.
- *
- *---------------------------------------------------------------------------
- *
- *                      R E V I S I O N   H I S T O R Y
- *
- * $Log:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/BIOSFLSH.C-arc  $
+ 
+/*
+ * MOD019: Changed return values for DSAC GbE region recovery so that in case of
+ *         no GbE region present or recovery error bios update continues without
+ *         GbE region recovery
+ * 
+ * MOD018: Fixed EHL MAC address recovery when running non-extended update and also
+ *         prevent exit with error when GbE region could not be found.
+ * 
+ * MOD017: Fixed DSAC identification string
+ * 
+ * MOD016: Added EHL MAC address recovery
+ * 
+ * MOD015: Added DSAC MAC address recovery and preservation of LAN areas
+ * 
+ * MOD014: Added support for 512k block size BIOS update
+ * 
+ * MOD013: Added BIOS update data preservation
  * 
  *    Rev 1.15   Sep 06 2016 15:42:24   congatec
  * Added BSD header.
@@ -258,7 +264,7 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     UINT32	LANCTRL1Regionfile, LANCTRL1Regionflash;		
     UINT32  LANCTRL1RegionfileEnd, LANCTRL1RegionflashEnd;	
     UINT32  LANCTRL0Size, LANCTRL1Size;
-	
+    
  
     // -----------------------------
 
@@ -294,14 +300,14 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     {
 		// If we cannot read at all, we have a problem !
 		// However, we might still only face a flash unlock issue.
-		return CG_BFRET_OK; // CG_BFRET_ERROR;
+		return CG_BFRET_OK; //MOD019
 	}
     
     // Check flash descriptor signatures in flash part and in flash contents file 
 	if( (*((UINT32*)(pInputData+0x10)) != FLASH_DESCRIPTOR_SIGNATURE) ||  (data32 != FLASH_DESCRIPTOR_SIGNATURE))
 	{
 		// Invalid descriptor signature in flash or file -> Break.
-		return CG_BFRET_OK; 
+		return CG_BFRET_OK;  //MOD019
 	}
     
     // Get flash region base address from input file
@@ -313,17 +319,16 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     {
 		// If we cannot read at all, we have a problem !
 		// However, we might still only face a flash unlock issue.
-		return CG_BFRET_OK; // CG_BFRET_ERROR;
+		return CG_BFRET_OK; //MOD019
 	}
 	FRBAflash = (data32 & 0x00FF0000) >> 12;
-    
+
     // Check match
 	if(FRBAfile != FRBAflash)
 	{
 		// No match. Break 
-		return CG_BFRET_OK;
+		return CG_BFRET_OK; //MOD019
 	}
-
     // Now that we have the flash region base address, check whether
 	// there is a used flash region 11, which is dedicated to LAN CTRL0
 	FLREG11file	=   FRBAfile + FLREG11_OFFSET;
@@ -336,7 +341,7 @@ UINT16 CG_CheckPatchInputExtd_DSAC
 	if((data32 & 0x00001FFF) == 0x00001FFF)
 	{
 		// Region unused. Break.
-		return CG_BFRET_OK;
+		return CG_BFRET_OK; //MOD019
 	}
     LANCTRL0Regionfile = (data32 & 0x00007FFF) << 12;
     // Get LAN CTRL 0 region limit
@@ -347,13 +352,13 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     {
 		// If we cannot read at all, we have a problem !
 		// However, we might still only face a flash unlock issue.
-		return CG_BFRET_OK; // CG_BFRET_ERROR;
+		return CG_BFRET_OK; // MOD019
 	} 
 	// Check whether region is used
 	if((data32 & 0x00001FFF) == 0x00001FFF)
 	{
 		// Region unused. Break.
-		return CG_BFRET_OK;
+		return CG_BFRET_OK; //MOD019
 	}
     LANCTRL0Regionflash = (data32 & 0x00007FFF) << 12;
     // Get LAN CTRL 0 region limit
@@ -362,9 +367,8 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     if((LANCTRL0Regionfile != LANCTRL0Regionflash) || (LANCTRL0RegionfileEnd != LANCTRL0RegionflashEnd))
 	{
 		// No match. Break
-		return CG_BFRET_OK;
+		return CG_BFRET_OK; //MOD019
 	}
-    
     // Check whether
 	// there is a used flash region 11, which is dedicated to LAN CTRL1
 	FLREG12file	= FRBAfile + FLREG12_OFFSET;
@@ -376,7 +380,7 @@ UINT16 CG_CheckPatchInputExtd_DSAC
 	if((data32 & 0x00001FFF) == 0x00001FFF)
 	{
 		// Region unused. Break.
-		return CG_BFRET_OK;
+		return CG_BFRET_OK; //MOD019
 	}
 
     LANCTRL1Regionfile = (data32 & 0x00007FFF) << 12;
@@ -387,13 +391,13 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     {
 		// If we cannot read at all, we have a problem !
 		// However, we might still only face a flash unlock issue.
-		return CG_BFRET_OK; // CG_BFRET_ERROR;
+		return CG_BFRET_OK; //MOD019
 	}
 	// Check whether region is used
 	if((data32 & 0x00001FFF) == 0x00001FFF)
 	{
 		// Region unused. Break.
-		return CG_BFRET_OK;
+		return CG_BFRET_OK; //MOD019
 	}
     LANCTRL1Regionflash = (data32 & 0x00007FFF) << 12;
     // Get LAN CTRL 1 region limit
@@ -403,8 +407,8 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     if((LANCTRL1Regionfile != LANCTRL1Regionflash) || (LANCTRL1RegionfileEnd != LANCTRL1RegionflashEnd)) 
 	{
 		// No match. Break
-		return CG_BFRET_OK;
-	}
+		return CG_BFRET_OK; //MOD019
+	} 
      
     //There is a valid LANCTRL 1 section in the flash and in the file. 
     
@@ -423,19 +427,20 @@ UINT16 CG_CheckPatchInputExtd_DSAC
         {
             BiosFlashReportState(1, "FAILED!");
             free(lanBuffer);
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         }
 
         if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_EXTD, LANCTRL0Regionflash, lanBuffer, LANCTRL0Size))
         {
             BiosFlashReportState(1, "FAILED!");
             free(lanBuffer);
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         }
 
         for (i= 0; i < LANCTRL0Size; ++i)
         {
             *(pInputData+LANCTRL0Regionflash + i) = lanBuffer[i];
+            
         }
 
         free(lanBuffer);
@@ -447,16 +452,15 @@ UINT16 CG_CheckPatchInputExtd_DSAC
         {
             BiosFlashReportState(1, "FAILED!");
             free(lanBuffer);
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         }
         
         if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_EXTD, LANCTRL1Regionflash, lanBuffer, LANCTRL1Size))
         {
             BiosFlashReportState(1, "FAILED!");
             free(lanBuffer);
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         }
-
         for (i= 0; i < LANCTRL1Size; ++i)
         {
             *(pInputData+LANCTRL1Regionflash + i) = lanBuffer[i];
@@ -466,30 +470,30 @@ UINT16 CG_CheckPatchInputExtd_DSAC
     }
     else // preserve only the MAC addresses and overwrite the other parts of the LAN CTRL 0 and 1 areas
     {
+
         //Get first mac address with fixed offset
         if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_EXTD, LANCTRL0Regionflash + MAC_0_2_OFFSET, &macAddress[0][0], 6))
         {
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         } 
         
         //MAC address 1 is stored at offset 0x212
         if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_EXTD, LANCTRL0Regionflash + MAC_1_3_OFFSET, &macAddress[1][0], 6))
         {
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         }
         
-        
         //Try to recover MAC address 2 using offset 0x202
         
         if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_EXTD, LANCTRL1Regionflash + MAC_0_2_OFFSET, &macAddress[2][0], 6))
         {
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         }
         
         //MAC address 3 is stored at offset 0x212
         if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_EXTD, LANCTRL1Regionflash + MAC_1_3_OFFSET, &macAddress[3][0], 6))
         {
-            return CG_BFRET_ERROR;
+            return CG_BFRET_OK; //MOD019
         }
         
         // copy old mac address 0 to input bios buffer
@@ -533,6 +537,194 @@ UINT16 CG_CheckPatchInputExtd_DSAC
 
 //MOD015 ^
 
+
+//MOD016 v 
+
+/* ###################################
+ *  ELKHART LAKE MAC ADDRESS RECOVERY
+ * ###################################
+ * EHL GbE Region Layout:
+ * 
+ * GUID: 16 Bytes
+ * FFS Header: 12 Bytes
+ * Version: 4 Bytes
+ * Number of Ports: 4 Bytes
+ * 
+ * For each MAC address (see number of ports):
+ * BDF: 4 Bytes
+ * MAC Address Low: 4 Bytes
+ * MAC Address High: 4 Bytes
+ * 
+ */
+
+UINT16 CG_CheckPatchInputExtd_EHL
+(
+	unsigned char *pInputData,
+	UINT32 nInputDataSize,
+	UINT32 nProjID,	
+    UINT32 nFlags
+)
+{
+    UINT32 gbeguid[4] = {0x12E29FB4, 0x4172AA56, 0x5FDD4EB3, 0xA90A444B};
+    UINT32 guidData[4] = {0}; // buffer for storing the guid read from the bios file in order to compare
+    UINT32 gbeFlashOffset, gbeFileOffset, nIndex, i, j;
+    UINT8 guidFlashFound = FALSE;
+    UINT8 guidFileFound = FALSE;
+    UINT32 storageAreaSize;
+    UINT32 versionFlash, numberOfPortsFlash; //version number and number of ports stored from bios flash
+    unsigned char macEntryFlash[EHL_GBE_REGION_MAXNUM_PORTS][EHL_GBE_REGION_MAC_SIZE]; //array holding the mac entries stored from bios flash
+    
+    //##############################################
+    // BIOS Flash : Get MAC addresses
+    //##############################################
+    
+    BiosFlashReportState(0, "GbE Region recovery . . . . ");
+    
+    //get size of bios area (CG32_STORAGE_MPFA_ALL -> BIOS ROM part (comprises _STATIC, _USER, _DYNAMIC))
+    if ((storageAreaSize = CgosStorageAreaSize(hCgos, CG32_STORAGE_MPFA_ALL)) <1)
+    {
+        BiosFlashReportState(1, "\nERROR: Could not get flash size. Area locked??? Please try again with /ef flag");
+    }
+
+    nIndex = 0;
+        
+    //search bios flash for gbe guid
+    while(nIndex < (storageAreaSize)-sizeof(guidData))
+    {
+        if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_ALL, nIndex, (unsigned char*)&guidData, sizeof(guidData)))
+        {
+            BiosFlashReportState(1, "\nERROR: Could not get flash size. Area locked??? Please try again with /ef flag");
+            return CG_MPFARET_OK; // MOD018
+        }
+        //compare if 4 dwords read from the offset match the gbe guid.
+        else if((guidData[0] == gbeguid[0]) && (guidData[1] == gbeguid[1]) && (guidData[2] == gbeguid[2]) && (guidData[3] == gbeguid[3]))
+        {
+            //guid found!
+            guidFlashFound = TRUE;
+            gbeFlashOffset = nIndex; //this is the offset to GbE region (the first byte of its guid)
+            break;
+        }
+        else
+        {   //guid not found -> increase the index by 32 bits and keep searching
+            nIndex = nIndex + 4;
+        }
+    }
+    
+    if (guidFlashFound == FALSE)
+    {
+        // no GUID found in BIOS Flash -> exit with error
+        BiosFlashReportState(1, "\nERROR: Could not get flash size. Area locked??? Please try again with /ef flag\n");
+        printf("ERROR: Could not find GbE GUID in BIOS Flash!\n");
+        return CG_BFRET_OK; // MOD018 return OK, and flash BIOS anyway (GbE region will be written with default value)
+    }
+
+    // guidFlashFound == TRUE: A GbE GUID has been found in the BIOS file -> get the data
+    
+    // save the version dword
+    if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_ALL, (gbeFlashOffset+EHL_GBE_REGION_NUMPORTS_OFFSET), (unsigned char*)&versionFlash, sizeof(versionFlash)))
+    {
+        printf("ERROR: Could not get version from BIOS flash\n");
+        return CG_MPFARET_OK;  // MOD018 return OK, and flash BIOS anyway (GbE region will be written with default value)
+    }
+
+    // get the number of ports and the mac addresses
+    
+    // the number of Ports dword is at gbeFlashOffset + EHL_GBE_REGION_NUMPORTS_OFFSET
+    if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_ALL, (gbeFlashOffset+EHL_GBE_REGION_NUMPORTS_OFFSET), (unsigned char*)&numberOfPortsFlash, sizeof(numberOfPortsFlash)))
+    {
+        printf("ERROR: Could not get number of ports from BIOS flash\n");
+        return CG_MPFARET_OK;  // MOD018 return OK, and flash BIOS anyway (GbE region will be written with default value)
+    }
+            
+    //sanity check: the number of ports is higher than the array for the mac addresses can hold
+    if (numberOfPortsFlash > ((sizeof(macEntryFlash)/EHL_GBE_REGION_MAC_SIZE)))
+    {
+
+        printf("\nERROR: Number of MAC addresses found in BIOS flash exceeds buffer!\n");
+        return CG_BFRET_OK;   // MOD018 return OK, and flash BIOS anyway (GbE region will be written with default value)
+    }
+    
+    // print the mac addresses in the flash
+    
+    for (i = 0; i < numberOfPortsFlash; ++i)
+    {
+        if(!CgosStorageAreaRead(hCgos, CG32_STORAGE_MPFA_ALL, (gbeFlashOffset+EHL_GBE_REGION_MAC_OFFSET+(EHL_GBE_REGION_MAC_SIZE*i)), (unsigned char*)&macEntryFlash[i][0], EHL_GBE_REGION_MAC_SIZE))
+        {
+            printf("ERROR: Could not get MAC address %i from BIOS flash\n",i);
+            return CG_MPFARET_OK;  // MOD018 return OK, and flash BIOS anyway (GbE region will be written with default value)
+        }
+        
+    }
+    
+    //##############################################
+    // BIOS File: Get Gbe Region
+    //##############################################
+    
+    //search for GbE GUID in BIOS flash file
+
+    nIndex = 0;
+    
+    while(nIndex < nInputDataSize)
+    {
+
+        if ((*(UINT32*)(pInputData+nIndex) == gbeguid[0]) && (*(UINT32*)(pInputData+nIndex+4) == gbeguid[1]) && (*(UINT32*)(pInputData+nIndex+8) == gbeguid[2]) && (*(UINT32*)(pInputData+nIndex+12) == gbeguid[3]))
+        {
+            // GUID found! 
+            guidFileFound = TRUE;
+            gbeFileOffset = nIndex; //this is the offset to GbE region (the first byte of its guid)
+            break;
+        }
+        else
+        {
+            //GUID not found (yet) -> keep on searching
+            nIndex = nIndex + 4;
+        }
+    }
+    
+    //exit if GUID has not been found
+    if (guidFileFound == FALSE) 
+    {
+        // no GUID found in BIOS file -> exit with error
+        printf("\nERROR: Could not find GbE Region in BIOS File!");
+        return CG_BFRET_OK;   // MOD018 return OK, and flash BIOS anyway (GbE region will be written with default value)
+    }
+
+    // guidFileFound == TRUE here -> GUID has been found, now restore MAC addresses
+
+    //##############################################
+    // Save GbE region data from flash to file
+    //##############################################
+    
+    // The file has an empty Gbe Region, the only data present is the GUID and the FFS Header. Thus, skip the FFS header when restoring.
+    // The version, the number of ports and all the MAC entries have to be copied.
+    
+    
+    // copy version
+    
+    *(UINT32*)(pInputData + gbeFileOffset + EHL_GBE_REGION_VERSION_OFFSET) = versionFlash;
+
+    // copy number of ports
+    
+    *(UINT32*)(pInputData + gbeFileOffset + EHL_GBE_REGION_NUMPORTS_OFFSET) = numberOfPortsFlash;
+
+    for (i = 0; i < numberOfPortsFlash; ++i)
+    {
+        //restore MAC address for each port
+        for (j = 0; j < EHL_GBE_REGION_MAC_SIZE; ++j)
+        {
+             *(pInputData+gbeFileOffset+EHL_GBE_REGION_MAC_OFFSET + (EHL_GBE_REGION_MAC_SIZE*i) + j) = macEntryFlash[i][j];
+        }
+    }
+
+    printf("DONE!\n");
+
+    return CG_BFRET_OK; 
+    
+}
+
+//MOD016 ^
+
+
 /*---------------------------------------------------------------------------
  * Name: CG_CheckPatchInputExtd
  * Desc: Check whether input BIOS data modification is required and if yes
@@ -1106,6 +1298,24 @@ UINT16 CG_BiosFlash( _TCHAR* lpszBiosFile, UINT32 nFlags)
 
     fclose(fpBiosRomfile);
     BiosFlashReportState(1, "DONE!");
+    
+    //MOD018 v 
+    // Check if platform is Elkhart Lake (QA70, SA70, TA70, PA70, MA70). If yes, perform EHL MAC address recovery.
+    if ((memcmp(&szBoardBiosName,"QA70",4) == 0) || (memcmp(&szBoardBiosName,"SA70",4) == 0) || (memcmp(&szBoardBiosName,"TA70",4) == 0) || (memcmp(&szBoardBiosName,"PA70",4) == 0) || (memcmp(&szBoardBiosName,"MA70",4) == 0))
+        {
+                // EHL MAC address recovery
+                if(CG_CheckPatchInputExtd_EHL(pBuffer,nRomfileSize,*((UINT32 *)(&szBoardBiosName[0])),nFlags) != CG_BFRET_OK)
+                {
+                    // Failed to perform required input data patch or check. Quit.
+                    free(pBuffer);
+                    return CG_BFRET_ERROR;
+                }
+                if (nFlags & CG_BFFLAG_KEEP_LANAREAS)
+                {   // Restoring the LAN areas LAN CTRL 0 and LAN CTRL 1 is only available for DSAC
+                    BiosFlashReportState(0, "\nRestoring LAN areas is not available for this project!\n");  
+                }
+    } 
+    //MOD018 ^ 
 																				//MOD003 v
 	// For a real extended flash update special handling of the additional flash content might be required,
 	// like restoring the MAC address stored in the flash or other things. This can be handled here.
@@ -1113,7 +1323,7 @@ UINT16 CG_BiosFlash( _TCHAR* lpszBiosFile, UINT32 nFlags)
 	{
         //MOD015 v
         //Check if we want to flash a DSAC. If yes, use the special handling for DSAC.
-        if (memcmp(&szBoardBiosName,"DSAC",4) == 0)
+        if (memcmp(&szBoardBiosName,"DSA",3) == 0) //MOD017
         {
                 // keep MAC addresses only
                 if(CG_CheckPatchInputExtd_DSAC(pBuffer,nRomfileSize,*((UINT32 *)(&szBoardBiosName[0])),nFlags) != CG_BFRET_OK)
@@ -1123,6 +1333,23 @@ UINT16 CG_BiosFlash( _TCHAR* lpszBiosFile, UINT32 nFlags)
                     return CG_BFRET_ERROR;
                 }
         }
+        /*MOD018 v  
+        // Check if platform is Elkhart Lake (QA70, SA70, TA70, PA70, MA70). If yes, perform EHL MAC address recovery.
+        else if ((memcmp(&szBoardBiosName,"QA70",4) == 0) || (memcmp(&szBoardBiosName,"SA70",4) == 0) || (memcmp(&szBoardBiosName,"TA70",4) == 0) || (memcmp(&szBoardBiosName,"PA70",4) == 0) || (memcmp(&szBoardBiosName,"MA70",4) == 0))
+        {
+                // EHL MAC address recovery
+                if(CG_CheckPatchInputExtd_EHL(pBuffer,nRomfileSize,*((UINT32 *)(&szBoardBiosName[0])),nFlags) != CG_BFRET_OK)
+                {
+                    // Failed to perform required input data patch or check. Quit.
+                    free(pBuffer);
+                    return CG_BFRET_ERROR;
+                }
+                if (nFlags & CG_BFFLAG_KEEP_LANAREAS)
+                {   // Restoring the LAN areas LAN CTRL 0 and LAN CTRL 1 is only available for DSAC
+                    BiosFlashReportState(0, "\nRestoring LAN areas is not available for this project!\n");  
+                }
+        } MOD018 ^*/
+       
         else // Use the standard handling for all other projects.
         {
             if(CG_CheckPatchInputExtd(pBuffer,nRomfileSize,*((UINT32 *)(&szBoardBiosName[0]))) != CG_BFRET_OK)
@@ -1148,8 +1375,6 @@ UINT16 CG_BiosFlash( _TCHAR* lpszBiosFile, UINT32 nFlags)
         }
     }
     //MOD015 ^
-    
-
 
     																			//MOD003 ^
 																	
@@ -1409,7 +1634,7 @@ UINT16 CG_BiosFlash( _TCHAR* lpszBiosFile, UINT32 nFlags)
 		BiosFlashReportState(0, "Please reboot the system!");
 		BiosFlashReportState(0, " ");	//MOD007
 	}
-                                                                        //MOD003 ^    
+                                                                //MOD003 ^    
 	return CG_BFRET_OK;
 }
 
@@ -1651,7 +1876,7 @@ UINT16 CgBfGetBiosInfoRomfile
         {
             *(lpszBiosVersion + nCount) = CgBiosInfoRomfile.biosVersion[nCount];
         }
-        retVal = CG_BFRET_OK; 
+        retVal = CG_BFRET_OK;
     }
     else
     {
diff --git a/cgutlcmn/biosflsh.h b/cgutlcmn/biosflsh.h
index 2aab262..ec32636 100644
--- a/cgutlcmn/biosflsh.h
+++ b/cgutlcmn/biosflsh.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2018, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -91,7 +91,6 @@ extern "C" {
 #define CG_BFFLAG_AUTO_OFFON	0x0800	// Perform immediate/auto off-on cycle for BIOS unlock.	//MOD006
 #define CG_BFFLAG_PRESERVE		0x1000	// Preserve pre-defined NVRAM settings (e.g. PASSWORD)	//MOD007
 #define CG_BFFLAG_KEEP_LANAREAS 0x2000  // Save LAN CTRL 0 and LAN CTRL 1 areas (DSAC)          //MOD008
-#define CG_BFFLAG_KEEP_LANAREAS 0x2000  // Save LAN CTRL 0 and LAN CTRL 1 areas (DSAC)          //MOD008
 
 //-------------------------
 // BIOS flash return codes
@@ -159,6 +158,35 @@ extern UINT16 CgBfGetBiosInfoFlash(void);										//MOD002
 #define X550_FW_POINTER 0x0F
 
 // MOD008 ^
+
+//MOD009 v
+
+/*
+ * EHL GbE Region Layout:
+ * 
+ * GUID: 16 Bytes
+ * FFS Header: 12 Bytes
+ * Version: 4 Bytes
+ * Number of Ports: 4 Bytes
+ * 
+ * For each MAC address (see number of ports):
+ * BDF: 4 Bytes
+ * MAC Address Low: 4 Bytes
+ * MAC Address High: 4 Bytes
+ * 
+ */
+
+#define EHL_GBE_REGION_MAXNUM_PORTS 3 // there should not be more than 3 mac address entries, otherwise we have a problem 
+
+#define EHL_GBE_REGION_VERSION_SIZE 0x04
+#define EHL_GBE_REGION_NUMPORTS_SIZE 0x04
+#define EHL_GBE_REGION_MAC_SIZE 0x0C // Size of a MAC address entry 4 Bytes BDF + 4 Bytes MAC Address Low + 4 Bytes MAC Address High = 12 = 0x0C
+
+#define EHL_GBE_REGION_VERSION_OFFSET 0x1C //16 Bytes GUID + 12 Bytes FFS Header = 28 = 1C
+#define EHL_GBE_REGION_NUMPORTS_OFFSET 0x20 // 16 Bytes GUID + 12 Bytes FFS Header + 4 Bytes Version = 32 = 0x20
+#define EHL_GBE_REGION_MAC_OFFSET 0x24 // Offset to first MAC address (EHL_GBE_REGION_NUMPORTS_OFFSET + 4 Bytes Number of ports)
+
+//MOD009 ^
                                                                             
 // Restore previous packing rules
 #pragma pack(pop)																//MOD005 ^
diff --git a/cgutlcmn/cgbc.h b/cgutlcmn/cgbc.h
index db2834a..ef2db28 100644
--- a/cgutlcmn/cgbc.h
+++ b/cgutlcmn/cgbc.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -18,8 +18,6 @@
  */
 
 /*---------------------------------------------------------------------------
- *
- * $Header:   S:/CG/archives/CGTOOLS/INC/CGBC.H-arc   1.28   Sep 06 2016 15:45:56   congatec  $
  *
  * Contents: Board controller common definitions.
  *
@@ -27,7 +25,70 @@
  *
  *                      R E V I S I O N   H I S T O R Y
  *
- * $Log:   S:/CG/archives/CGTOOLS/INC/CGBC.H-arc  $
+ * MOD070: Revised the definition and usage of standard data types to support
+ *         64-bit environments properly.
+ * MOD069: Added logical pin function for BRD_PWR_EN.
+ * MOD068: Added missing logical pin functions for SUSPWRDNACK, SLP_M#,
+ *         SLP_LAN# and SLP_WLAN#.
+ * MOD067: Added support for logging special system events such as eSPI events.
+ * MOD066: Added CGBC_POST_SEC_DISPLAY_DIS bit definition.
+ *
+ * MOD065: Added support for dedicated SPD SMBuses CGBC_I2C_BUS_DDR0 and
+ *         CGBC_I2C_BUS_DDR1.
+ * MOD064: Added support for a power control event logging group and for event
+ *         logging of virtual pins, eSPI virtual wires and HWM values.
+ * MOD063: Added support for general purpose SPI (GSPI).
+ *
+ * MOD062: Changed congatec board controller type name for the MEC170x based
+ *         congatec Board Controllers.
+ * MOD061: Added new CGBC API command CGBC_CMD_AVR_SPM_EXT.
+ * MOD060: Added support for the new pin function CGBC_PIN_FNC_SPD_SMB_MUX.
+ * MOD059: Added support for extended cBC I2C API.
+ * MOD058: Added the ui8Usage field in the HWM control unit configuration
+ *         parameters used to identify specific HWM control units.
+ * MOD057: Improved definitions of the HWM unit configuration parameter
+ *         structures
+ * MOD056: Added support for MCU GPIO pins being used as binary HWM sensors and
+ *         actuators.
+ * MOD055: Added support for UART_MUX_PCH pin.
+ * MOD054: Added support for a voltage tolerant open-drain output pin mode.
+ * MOD053: Added support for enabling/disabling DHCC.
+ * MOD052: Added support for COM-HPC (new I2C/SMBuses I2C1, IPMB, UPDB, new
+ *         pin functions CGBC_PIN_FNC_PMBUS_MUX, CGBC_PIN_FNC_TESTn,
+ *         CGBC_PIN_FNC_VIN_PWROK, CGBC_PIN_FNC_RAPID_SHUTDOWN
+ *         CGBC_PIN_FNC_UART_MUX_PCHn, CGBC_PIN_FNC_THRMn and
+ *         CGBC_PIN_FNC_PROCHOTn, new logical HWM sensor types.
+ *
+ * MOD051: Changes to allow a clear identification of two DIMM temperature
+ *         sensors on the top side of the PCB.
+ *
+ * MOD050: Added Support for MEC1705 battery mode
+ *
+ * MOD049: Added support for G781 temperature sensor
+ *
+ * *    Rev 1.35   Feb 12 2020 13:40:16   ess
+ * MOD048: Added new pin functions V5A_CTL and HOST_RST_ACK.
+ * 
+ *    Rev 1.34   Dec 12 2019 15:46:40   ess
+ * MOD047: Added support for POST code event logging and repeated trigger
+ *         mode.
+ * 
+ *    Rev 1.33   Dec 10 2019 09:51:20   ess
+ * MOD046: Update to latest GEN5 cBC functionality and minor cleanup.
+ * 
+ *    Rev 1.32   Mar 18 2019 15:56:12   ess
+ * MOD045: added latest CM41 enhancments and corrected actuator stepping
+ *         width parameters
+ * 
+ *    Rev 1.31   Mar 18 2019 13:07:34   ess
+ * MOD044: Update to latest GEN5 cBC functionality
+ * 
+ *    Rev 1.30   Sep 18 2018 14:42:52   ess
+ * MOD043: put CGBC_HWM_DATA type definition back in which had been commented
+ *         out by mistake in rev 1.28 and rev 1.29
+ * 
+ *    Rev 1.29   Apr 03 2018 08:53:28   ess
+ * MOD042: added support for MEC1705
  * 
  *    Rev 1.28   Sep 06 2016 15:45:56   congatec
  * Added BSD header.
@@ -150,6 +211,8 @@
 #ifndef __AVR__                                                      //MOD013
 #pragma pack(1)                                                      //MOD001
 #endif //!__AVR__                                                    //MOD013
+
+#ifdef _MSC_VER                                                    /*MOD070 */
                                                                    /*MOD039v*/
 #ifndef  SINT16
 #define  SINT16 signed short
@@ -182,115 +245,192 @@
 #define  uint32_t unsigned long
 #endif /*uint32_t*/
                                                                    /*MOD035^*/
+                                                                   /*MOD046v*/
+#ifndef  int8_t
+#define  int8_t signed char
+#endif /*int8_t*/
+
+#ifndef  int16_t
+#define  int16_t signed short
+#endif /*int16_t*/
+
+#ifndef  int32_t
+#define  int32_t signed long
+#endif /*int32_t*/
+                                                                   /*MOD070v*/
+#else //#ifdef _MSC_VER
+#include <stdint.h>              
+#endif //#ifdef _MSC_VER
+                                                                   /*MOD070^*/ 
+                                                                   /*MOD046v*/
+/*------------------------------------
+ * congatec Board Controller families
+ *------------------------------------
+ */
 
+#define CGBC_FAMILY_AVR1 1                   /* Atmel AVR  / ATmega48/88/168 */
+#define CGBC_FAMILY_AVR2 2                   /* Atmel AVR  / ATmega165P/325P */
+#define CGBC_FAMILY_CM31 3                   /* Cortex-M3  / STM32F100R8     */
+#define CGBC_FAMILY_CM41 4                   /* Cortex-M4F / TM4E1231H6ZRB   */
+#define CGBC_FAMILY_GEN5 5                   /* Cortex-M4F / MEC170x         */
 
-/*--------------
- * SPI commands
- *--------------
- */
-
-#define CGBC_CMD_GET_STATUS    0x00
-#define CGBC_CMD_GET_DATA_1    0x01
-#define CGBC_CMD_GET_DATA_2    0x02
-#define CGBC_CMD_GET_DATA_3    0x03
-#define CGBC_CMD_GET_DATA_4    0x04
-#define CGBC_CMD_GET_DATA_5    0x05
-#define CGBC_CMD_GET_DATA_6    0x06
-#define CGBC_CMD_GET_DATA_7    0x07
-#define CGBC_CMD_GET_DATA_8    0x08
-#define CGBC_CMD_GET_DATA_9    0x09
-#define CGBC_CMD_GET_DATA_10   0x0A
-#define CGBC_CMD_GET_DATA_11   0x0B
-#define CGBC_CMD_GET_DATA_12   0x0C
-#define CGBC_CMD_GET_DATA_13   0x0D
-#define CGBC_CMD_GET_DATA_14   0x0E
-#define CGBC_CMD_GET_DATA_15   0x0F
-#define CGBC_CMD_GET_DATA_16   0x10
-#define CGBC_CMD_GET_DATA_17   0x11
-#define CGBC_CMD_GET_DATA_18   0x12
-#define CGBC_CMD_GET_DATA_19   0x13
-#define CGBC_CMD_GET_DATA_20   0x14
-#define CGBC_CMD_GET_DATA_21   0x15
-#define CGBC_CMD_GET_DATA_22   0x16
-#define CGBC_CMD_GET_DATA_23   0x17
-#define CGBC_CMD_GET_DATA_24   0x18
-#define CGBC_CMD_GET_DATA_25   0x19
-#define CGBC_CMD_GET_DATA_26   0x1A
-#define CGBC_CMD_GET_DATA_27   0x1B
-#define CGBC_CMD_GET_DATA_28   0x1C
-#define CGBC_CMD_GET_DATA_29   0x1D
-#define CGBC_CMD_GET_DATA_30   0x1E
-#define CGBC_CMD_GET_DATA_31   0x1F
-#define CGBC_CMD_GET_DATA_32   0x20
-#define CGBC_CMD_GET_FW_REV    0x21
-#define CGBC_CMD_AUX_INIT      0x22
-#define CGBC_CMD_AUX_OUT       0x23
-#define CGBC_CMD_AUX_IN        0x24
-#define CGBC_CMD_AUX_STAT      0x25
-#define CGBC_CMD_WD_EVENT      0x26
-#define CGBC_CMD_WD_TRIGGER    0x27
-#define CGBC_CMD_WD_INIT       0x28
-#define CGBC_CMD_WD_INIT_POST  0x29
-#define CGBC_CMD_WD_INIT_EARLY 0x2A
-#define CGBC_CMD_SYS_FLAGS_1   0x2B
-#define CGBC_CMD_SCI_EVT_QUERY 0x2C
-#define CGBC_CMD_STACK_INFO    0x2D
-#define CGBC_CMD_INFO_1        0x2E
-#define CGBC_CMD_LFP_CONTROL   0x2F                                  //MOD040
-#define CGBC_CMD_VID_CONTROL   0x2F /* Deprecated */                 //MOD040
-#define CGBC_CMD_TEST_COUNTER  0x30
-#define CGBC_CMD_BOOT_TIME     0x31
-#define CGBC_CMD_SPI_TIMING    0x32
-#define CGBC_CMD_DUMP          0x33                                  //MOD002
-#define CGBC_CMD_RESET_INFO    0x34                                  //MOD002
-#define CGBC_CMD_POST_CODE     0x35                                  //MOD002
-#define CGBC_CMD_PERFORMANCE   0x36                                  //MOD002
-#define CGBC_CMD_POWER_LOSS    0x37                                  //MOD003
-#define CGBC_CMD_XINT_CONTROL  0x38                                  //MOD004
-#define CGBC_CMD_USER_LOCK     0x39                                  //MOD004
-#define CGBC_CMD_OSCCAL        0x3A                                  //MOD005
-#define CGBC_CMD_CPU_TEMP      0x3B                                  //MOD009
-#define CGBC_CMD_SBSM_DATA     0x3C                           //MOD004 MOD005
-#define CGBC_CMD_I2C_START     0x40
-#define CGBC_CMD_I2C_STAT      0x48
-#define CGBC_CMD_I2C_DATA      0x50
-#define CGBC_CMD_I2C_SPEED     0x58                                  //MOD002
-#define CGBC_CMD_SCI_STOP      0x60                                  //MOD010
-#define CGBC_CMD_BTN_CONTROL   0x61                                  //MOD017
-#define CGBC_CMD_FAN_CONTROL   0x62                                  //MOD020
-#define CGBC_CMD_RTC           0x63                                  //MOD022
-#define CGBC_CMD_GPIO_DAT_RD   0x64                                  //MOD016
-#define CGBC_CMD_GPIO_DAT_WR   0x65                                  //MOD016
-#define CGBC_CMD_GPIO_CFG_RD   0x66                                  //MOD016
-#define CGBC_CMD_GPIO_CFG_WR   0x67                                  //MOD016
-#define CGBC_CMD_I2C_COMBINED  0x68                                  //MOD014
-#define CGBC_CMD_PECI          0x70                                  //MOD023
-#define CGBC_CMD_I2C_GATE      0x71                                  //MOD024
-#define CGBC_CMD_CFG_PINS      0x72                                  //MOD025
-#define CGBC_CMD_AVR_SPM       0x73                                  //MOD029
-#define CGBC_CMD_COMX_CFG      0x74                                  //MOD031
-#define CGBC_CMD_BLT_PWM       0x75                                  //MOD036
-#define CGBC_CMD_DEVICE_ID     0x76                                  //MOD038
-#define CGBC_CMD_HWM_SENSOR    0x77                                  //MOD038
-#define CGBC_CMD_POST_CFG      0x78                                  //MOD040
-#define CGBC_CMD_LFP_DELAY     0x79                                  //MOD040
-#define CGBC_CMD_TEST_MODE     0x7A                                  //MOD040
-#define CGBC_CMD_HWM_CONFIG    0x7B                                  //MOD040
-#define CGBC_CMD_LF2_CONTROL   0x7C                                  //MOD041
-#define CGBC_CMD_LF2_DELAY     0x7D                                  //MOD041
-#define CGBC_CMD_BL2_PWM       0x7E                                  //MOD041
-#define CGBC_CMD_DIAG_CFG      0x7F                                  //MOD041
-#define CGBC_CMD_GPIO_IER_RD   0x80                                  //MOD041
-#define CGBC_CMD_GPIO_IER_WR   0x81                                  //MOD041
-#define CGBC_CMD_GPIO_IRQ_RD   0x82                                  //MOD041
-#define CGBC_CMD_GPIO_IRQ_WR   0x83                                  //MOD041
-#define CGBC_CMD_SYNC          0xFE                                  //MOD014
-
+                                                                   /*MOD044^*/
 
+/*--------------------
+ * CGBC host commands
+ *--------------------
+ */
 
-/*------------------
- * CGBC status byte
- *------------------
+#define CGBC_CMD_GET_STATUS      0x00
+#define CGBC_CMD_GET_DATA_1      0x01
+#define CGBC_CMD_GET_DATA_2      0x02
+#define CGBC_CMD_GET_DATA_3      0x03
+#define CGBC_CMD_GET_DATA_4      0x04
+#define CGBC_CMD_GET_DATA_5      0x05
+#define CGBC_CMD_GET_DATA_6      0x06
+#define CGBC_CMD_GET_DATA_7      0x07
+#define CGBC_CMD_GET_DATA_8      0x08
+#define CGBC_CMD_GET_DATA_9      0x09
+#define CGBC_CMD_GET_DATA_10     0x0A
+#define CGBC_CMD_GET_DATA_11     0x0B
+#define CGBC_CMD_GET_DATA_12     0x0C
+#define CGBC_CMD_GET_DATA_13     0x0D
+#define CGBC_CMD_GET_DATA_14     0x0E
+#define CGBC_CMD_GET_DATA_15     0x0F
+#define CGBC_CMD_GET_DATA_16     0x10
+#define CGBC_CMD_GET_DATA_17     0x11
+#define CGBC_CMD_GET_DATA_18     0x12
+#define CGBC_CMD_GET_DATA_19     0x13
+#define CGBC_CMD_GET_DATA_20     0x14
+#define CGBC_CMD_GET_DATA_21     0x15
+#define CGBC_CMD_GET_DATA_22     0x16
+#define CGBC_CMD_GET_DATA_23     0x17
+#define CGBC_CMD_GET_DATA_24     0x18
+#define CGBC_CMD_GET_DATA_25     0x19
+#define CGBC_CMD_GET_DATA_26     0x1A
+#define CGBC_CMD_GET_DATA_27     0x1B
+#define CGBC_CMD_GET_DATA_28     0x1C
+#define CGBC_CMD_GET_DATA_29     0x1D
+#define CGBC_CMD_GET_DATA_30     0x1E
+#define CGBC_CMD_GET_DATA_31     0x1F
+#define CGBC_CMD_GET_DATA_32     0x20
+#define CGBC_CMD_GET_FW_REV      0x21
+#define CGBC_CMD_AUX_INIT        0x22
+#define CGBC_CMD_AUX_OUT         0x23
+#define CGBC_CMD_AUX_IN          0x24
+#define CGBC_CMD_AUX_STAT        0x25
+#define CGBC_CMD_WDOG_EVENT      0x26                                //MOD046
+#define CGBC_CMD_WD_EVENT        0x26 /* Deprecated */
+#define CGBC_CMD_WDOG_TRIGGER    0x27                                //MOD046
+#define CGBC_CMD_WD_TRIGGER      0x27 /* Deprecated */
+#define CGBC_CMD_WDOG_INIT       0x28                                //MOD046
+#define CGBC_CMD_WD_INIT         0x28 /* Deprecated */
+#define CGBC_CMD_WDOG_INIT_POST  0x29                                //MOD046
+#define CGBC_CMD_WD_INIT_POST    0x29 /* Deprecated */
+#define CGBC_CMD_WDOG_INIT_EARLY 0x2A                                //MOD046
+#define CGBC_CMD_WD_INIT_EARLY   0x2A /* Deprecated */
+#define CGBC_CMD_SYS_FLAGS_1     0x2B
+#define CGBC_CMD_SCI_EVT_QUERY   0x2C
+#define CGBC_CMD_STACK_INFO      0x2D
+#define CGBC_CMD_INFO_1          0x2E
+#define CGBC_CMD_LFP0_CONTROL    0x2F                                //MOD044
+#define CGBC_CMD_LFP_CONTROL     0x2F /* Deprecated */        //MOD040 MOD044
+#define CGBC_CMD_VID_CONTROL     0x2F /* Deprecated */               //MOD040
+#define CGBC_CMD_TEST_COUNTER    0x30
+#define CGBC_CMD_BOOT_TIME       0x31
+#define CGBC_CMD_SPI_TIMING      0x32
+#define CGBC_CMD_DUMP            0x33                                //MOD002
+#define CGBC_CMD_RESET_INFO      0x34                                //MOD002
+#define CGBC_CMD_POST_CODE       0x35                                //MOD002
+#define CGBC_CMD_PERFORMANCE     0x36                                //MOD002
+#define CGBC_CMD_POWER_LOSS      0x37                                //MOD003
+#define CGBC_CMD_XINT_CONTROL    0x38                                //MOD004
+#define CGBC_CMD_USER_LOCK       0x39                                //MOD004
+#define CGBC_CMD_OSCCAL          0x3A                                //MOD005
+#define CGBC_CMD_CPU_TEMP        0x3B                                //MOD009
+#define CGBC_CMD_SBSM_DATA       0x3C                         //MOD004 MOD005
+#define CGBC_CMD_I2C_START       0x40
+#define CGBC_CMD_I2C_STAT        0x48
+#define CGBC_CMD_I2C_DATA        0x50
+#define CGBC_CMD_I2C_SPEED       0x58                                //MOD002
+#define CGBC_CMD_SCI_STOP        0x60                                //MOD010
+#define CGBC_CMD_BTN_CONTROL     0x61                                //MOD017
+#define CGBC_CMD_CPU_FAN_CONTROL 0x62                                //MOD046
+#define CGBC_CMD_FAN_CONTROL     0x62 /* Deprecated */               //MOD020
+#define CGBC_CMD_RTC             0x63                                //MOD022
+#define CGBC_CMD_GPIO_DAT_RD     0x64                                //MOD016
+#define CGBC_CMD_GPIO_DAT_WR     0x65                                //MOD016
+#define CGBC_CMD_GPIO_CFG_RD     0x66                                //MOD016
+#define CGBC_CMD_GPIO_CFG_WR     0x67                                //MOD016
+#define CGBC_CMD_I2C_COMBINED    0x68                                //MOD014
+#define CGBC_CMD_PECI            0x70                                //MOD023
+#define CGBC_CMD_I2C_GATE        0x71                                //MOD024
+#define CGBC_CMD_CFG_PINS        0x72                                //MOD025
+#define CGBC_CMD_AVR_SPM         0x73                                //MOD029
+#define CGBC_CMD_COMX_CFG        0x74                                //MOD031
+#define CGBC_CMD_BLT0_PWM        0x75                                //MOD044
+#define CGBC_CMD_BLT_PWM         0x75 /* Deprecated */        //MOD036 MOD044
+#define CGBC_CMD_DEVICE_ID       0x76                                //MOD038
+#define CGBC_CMD_HWM_SENSOR      0x77                                //MOD038
+#define CGBC_CMD_POST_CFG        0x78                                //MOD040
+#define CGBC_CMD_LFP0_DELAY      0x79                                //MOD044
+#define CGBC_CMD_LFP_DELAY       0x79 /* Deprecated */        //MOD040 MOD044
+#define CGBC_CMD_TEST_MODE       0x7A                                //MOD040
+#define CGBC_CMD_HWM_CONFIG      0x7B                                //MOD040
+#define CGBC_CMD_LFP1_CONTROL    0x7C                                //MOD044
+#define CGBC_CMD_LF2_CONTROL     0x7C /* Deprecated */      //MOD041 MOD044
+#define CGBC_CMD_LFP1_DELAY      0x7D                                //MOD044
+#define CGBC_CMD_LF2_DELAY       0x7D /* Deprecated */        //MOD041 MOD044
+#define CGBC_CMD_BLT1_PWM        0x7E                                //MOD044
+#define CGBC_CMD_BL2_PWM         0x7E /* Deprecated */        //MOD041 MOD044
+#define CGBC_CMD_DIAG_CFG        0x7F                                //MOD041
+#define CGBC_CMD_GPIO_IER_RD     0x80                                //MOD041
+#define CGBC_CMD_GPIO_IER_WR     0x81                                //MOD041
+#define CGBC_CMD_GPIO_IRQ_RD     0x82                                //MOD041
+#define CGBC_CMD_GPIO_IRQ_WR     0x83                                //MOD041
+                                                                     //MOD044v
+#define CGBC_CMD_GPIO_ENA_RD     0x84
+#define CGBC_CMD_GPIO_ENA_WR     0x85
+#define CGBC_CMD_PWROK_DELAY     0x86
+#define CGBC_CMD_LOG_CFG         0x87
+#define CGBC_CMD_LOG_DUMP        0x88
+#define CGBC_CMD_LOG_READ        0x89
+#define CGBC_CMD_LOG_WRITE       0x8A
+#define CGBC_CMD_LOG_GPIO        0x8B
+#define CGBC_CMD_API_CONFIG      0x8C
+#define CGBC_CMD_COND_RTM        0x8D
+#define CGBC_CMD_BLT0_PWM_DELAY  0x8E
+#define CGBC_CMD_BLT1_PWM_DELAY  0x8F
+#define CGBC_CMD_PIN_FEAT        0x90
+#define CGBC_CMD_DIAG_MODE       0x91
+#define CGBC_CMD_ACCESS_LOCK     0x92                                //MOD046
+#define CGBC_CMD_ADV_USER_LOCK   0x92 /* Deprecated */
+                                                                     //MOD044^
+                                                                     //MOD046v
+#define CGBC_CMD_BAT_DYN         0x93                                //MOD050
+#define CGBC_CMD_BAT_STA         0x94                                //MOD050
+#define CGBC_CMS_SYS_FAN_CONTROL 0x95
+#define CGBC_CMD_GPIO_PIN_RD     0x96
+#define CGBC_CMD_GPIO_PIN_WR     0x97
+#define CGBC_CMD_WDOG_RD         0x98
+#define CGBC_CMD_GPIO_IRQ_TBL    0x99
+                                                                     //MOD046^
+                                                                     //MOD059v
+#define CGBC_CMD_I2C_START_EXT   0x9A
+#define CGBC_CMD_I2C_STAT_EXT    0x9B
+#define CGBC_CMD_I2C_DATA_EXT    0x9C
+#define CGBC_CMD_I2C_SPEED_EXT   0x9D
+#define CGBC_CMD_I2C_COMBI_EXT   0x9E
+                                                                     //MOD059^
+#define CGBC_CMD_AVR_SPM_EXT     0x9F                                //MOD061
+#define CGBC_CMD_GSPI_CFG        0xA0                                //MOD063
+#define CGBC_CMD_SYNC            0xFE                                //MOD014
+
+
+
+/*---------------------------------------------------
+ * CGBC status byte / AVR1, AVR2 and CM31 cBC family
+ *---------------------------------------------------
  */
 
 #define CGBC_BSY_BIT     7                             /* busy flag         */
@@ -311,10 +451,11 @@
 
 
                                                                     /*MOD027v*/
-/*-------------------------------------------
- * CGBC command status byte / CM41 BC family
- *-------------------------------------------
+/*-----------------------------------------------------
+ * CGBC command status byte / CM41 and GEN5 cBC family
+ *-----------------------------------------------------
  */
+typedef uint8_t CGBC_STATUS;                                         //MOD046
 
 #define CGBC_ERR_BIT     7                                     /* error flag */
 /*efine CGBC_RDY_BIT     6                                        ready flag */
@@ -346,6 +487,10 @@
 #define CGBC_ERR_TIMEOUT       0x0D     /* timeout condition       */ //MOD002
 #define CGBC_ERR_ABORT         0x0E     /* command aborted         */ //MOD032
 #define CGBC_ERR_BAD_CHECKSUM  0x0F     /* checksum error          */ //MOD040
+                                                                    /*MOD044v*/
+#define CGBC_ERR_INACTIVE      0x10     /* device or service inactive        */
+#define CGBC_ERR_WRITE         0x11     /* write operation failed            */
+                                                                    /*MOD044^*/
                                                                     /*MOD027v*/
 #define CGBC_ERR_HIF_RESET     0x1E     /* host interface was reset          */
 #define CGBC_ERR_HIF_DOWN      0x1F     /* host interface is down            */
@@ -420,7 +565,7 @@ typedef struct CGBC_CMD_INFO_1_OUT_STRUCT
 #define CGBC_ATMEGA325P    5                                         //MOD015
 #define CGBC_STM32F100R8   6                                         //MOD018
 #define CGBC_TM4E1231H6ZRB 7                                         //MOD030
-#define CGBC_MEC1705QSZ    8                                         //MOD0042
+#define CGBC_MEC170x       8                                  //MOD042 MOD062
 
 /* watchdog information */
 
@@ -475,8 +620,8 @@ typedef struct CGBC_CMD_INFO_1_OUT_STRUCT
 typedef struct CGBC_CMD_BOOT_TIME_OUT_STRUCT
    {
     unsigned char  sts;                         /* command status           */
-    UINT16 systemUpTime;                /* system up time in ms     */
-    UINT16 lastBootTime;                /* last boot time in ms     */
+    uint16_t       systemUpTime;                /* system up time in ms     */ //MOD070
+    uint16_t       lastBootTime;                /* last boot time in ms     */ //MOD070
    } CGBC_CMD_BOOT_TIME_OUT, *P_CGBC_CMD_BOOT_TIME_OUT;
 
 #endif /*!__ASSEMBLER__*/
@@ -505,10 +650,17 @@ typedef struct CGBC_CMD_SYS_FLAGS_1_OUT_STRUCT  // response packet structure
 
 #endif //!__ASSEMBLER__
                                                                      //MOD021^
-#define CGBC_SYS_PWR_AT         0x08    /* 1 = AT power supply */    //MOD003
-#define CGBC_SYS_POST_END       0x04    /* 1 = POST complete */
-#define CGBC_SYS_POST_START     0x02    /* 1 = system has started POST */
-#define CGBC_SYS_PWR_ON         0x01    /* 1 = system power is on */
+                                                                     //MOD044v
+#define CGBC_SYS_S5E_ENABLE_MASK    0xE0  /* S5e enabled when non-zero */
+#define CGBC_SYS_S5E_SLPBTNn_WAKE   0x80  /* 1 - S5e enabled, SLEEP# wake */
+#define CGBC_SYS_S5E_SMBALERTn_WAKE 0x40  /* 1 - S5e enabled, SMBALERT# wake */
+#define CGBC_SYS_S5E_PWRBTNn_WAKE   0x20  /* 1 - S5e enabled, PWRBTN# wake */
+#define CGBC_SYS_S5E_SUPPORT        0x10  /* 1 - S5e supported */
+                                                                     //MOD044^
+#define CGBC_SYS_PWR_AT             0x08  /* 1 = AT power supply */  //MOD003
+#define CGBC_SYS_POST_END           0x04  /* 1 = POST complete */
+#define CGBC_SYS_POST_START         0x02  /* 1 = system has started POST */
+#define CGBC_SYS_PWR_ON             0x01  /* 1 = system power is on */
 
 
 
@@ -588,22 +740,34 @@ typedef struct CGBC_CMD_VID_CONTROL_OUT_STRUCT  // response packet structure
  *-----------------
  */
 
-#define CGBC_I2C_BUS_MSK      0x07  /* I2C bus mask for SPI commands        */
+#define CGBC_I2C_BUS_MSK      0x07  /* bus mask for CGBC commands           */
+#define CGBC_I2C_BUS_I2C0     0x00  /* primary I2C-bus 0                    */ //MOD044
 #define CGBC_I2C_BUS_EXTERNAL 0x00  /* physical 400kHz multi-master I2C bus */
+                                                                               //MOD052 MOD059
 #define CGBC_I2C_BUS_SMB1     0x01  /* secondary SMBus                      */ //MOD033
 #define CGBC_I2C_BUS_SMB0     0x02  /* primary SMBus                        */ //MOD033
 #define CGBC_I2C_BUS_SMB      0x02  /* system management bus                */
 #define CGBC_I2C_BUS_ASM      0x02  /* auxiliary system management bus      */ //MOD004
+#define CGBC_I2C_BUS_I2CV     0x03  /* virtual I2C-bus                      */ //MOD044
 #define CGBC_I2C_BUS_INTERNAL 0x03  /* virtual I2C bus for internal devices */
+#define CGBC_I2C_BUS_DDC0     0x04  /* display data channel 0               */ //MOD044
 #define CGBC_I2C_BUS_DDC      0x04  /* video DDC bus                        */
 #define CGBC_I2C_BUS_EPI      0x04  /* embedded panel interface bus         */ //MOD004
+#define CGBC_I2C_BUS_EOOB     0x05  /* eSPI OOB channel                     */ //MOD046
+#define CGBC_I2C_BUS_IPMB     0x06  /* intelligent platform management bus  */ //MOD052
+                                                                               //MOD052 MOD059
 #define CGBC_I2C_BUS_SMB2     0x07  /* auxiliary SMBus                      */ //MOD033
+#define CGBC_I2C_BUS_I2C1     0x08  /* secondary I2C-bus 1                  */ //MOD059
+#define CGBC_I2C_BUS_UPDB     0x09  /* USB PD controller bus                */ //MOD059
+#define CGBC_I2C_BUS_DDR0     0x0A  /* dedicated DDR SMBus 0                */ //MOD065
+#define CGBC_I2C_BUS_DDR1     0x0B  /* dedicated DDR SMBus 1                */ //MOD065
+#define CGBC_I2C_BUS_MAX      CGBC_I2C_BUS_DDR1                                //MOD065
                                                                      //MOD002^
 
 
-/*-------------------------
- * I2C_START command flags
- *-------------------------
+/*--------------------------------------
+ * I2C_START/I2C_COMBINED command flags
+ *--------------------------------------
  */
                                                                      //MOD014v
 #ifndef __ASSEMBLER__
@@ -624,7 +788,11 @@ typedef struct CGBC_CMD_I2C_START_IN_STRUCT
 #define CGBC_I2C_SEND_LAST_ACK  0x80    /* send ACK on last read byte */
 #define CGBC_I2C_SEND_ALL_NAK   0x40    /* send NAK on all read bytes */
 #define CGBC_I2C_CNT_MSK        0x3F    /* write/read count mask */  //MOD014
-
+                                                                     //MOD044v
+/* I2C_COMBINED flag for SMBus block protocol in the device address field
+ * (i2cData[0]) */
+#define CGBC_I2C_SMBUS_BLK     0x01
+                                                                     //MOD044^
 
 
 /*-----------------------
@@ -677,6 +845,56 @@ typedef struct CGBC_CMD_I2C_SPEED_OUT_STRUCT
 #endif //!__ASSEMBLER__
                                                                      //MOD021^
 
+                                                                     //MOD059v
+/* -----------------------------------------------------------------------
+ * CGBC_CMD_I2C_START_EXT/CGBC_CMD_I2C_COMBINED_EXT command definitions
+ * -------------------------------------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_START_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                   unsigned char wrCnt;
+                   unsigned char rdCnt;
+                   unsigned char i2cData[35];
+                  } CGBC_CMD_I2C_START_EXT_IN,
+                 *P_CGBC_CMD_I2C_START_EXT_IN;
+
+/* --------------------------------------------
+ * CGBC_CMD_I2C_STAT_EXT command definitions
+ * ----------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_STAT_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                  } CGBC_CMD_I2C_STAT_EXT_IN,
+                 *P_CGBC_CMD_I2C_STAT_EXT_IN;
+
+/* --------------------------------------------
+ * CGBC_CMD_I2C_DATA_EXT command definitions
+ * ----------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_DATA_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                  } CGBC_CMD_I2C_DATA_EXT_IN,
+                 *P_CGBC_CMD_I2C_DATA_EXT_IN;
+
+/* -----------------------------------------
+ * CGBC_CMD_I2C_SPEED_EXT command definitions
+ * -------------------------------------- */
+
+typedef struct CGBC_CMD_I2C_SPEED_EXT_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char bus;
+                   unsigned char speed;
+                  } CGBC_CMD_I2C_SPEED_EXT_IN,
+                 *P_CGBC_CMD_I2C_SPEED_EXT_IN;
+                                                                     //MOD059^
+
 
 /*--------------------
  * I2C device numbers
@@ -703,12 +921,12 @@ typedef struct CGBC_CMD_I2C_SPEED_OUT_STRUCT
 typedef struct CG_BC_EEP_STRUCT
    {
     unsigned char  i2cExtSpeed;       /* I2C-bus power-up default frequency */
-    UINT16 i2cExtTimeout;     /* I2C-bus power-up default timeout   */
+    uint16_t       i2cExtTimeout;     /* I2C-bus power-up default timeout   */ //MOD070
     unsigned char  i2cSmbSpeed;       /* ASM-bus power-up default frequency */
-    UINT16 i2cSmbTimeout;     /* ASM-bus power-up default timeout   */
+    uint16_t       i2cSmbTimeout;     /* ASM-bus power-up default timeout   */ //MOD070
     unsigned char  i2cDdcSpeed;       /* EPI-bus power-up default frequency */
-    UINT16 i2cDdcTimeout;     /* EPI-bus power-up default timeout   */
-    unsigned char  postCodeEnable;    /* POST code relay enable             */
+    uint16_t       i2cDdcTimeout;     /* EPI-bus power-up default timeout   */ //MOD070
+    unsigned char  s5eDelay250;       /* default S5e delay       */  //MOD044
                                                                      //MOD004v
     unsigned char  vidControl;        /* video control power-up default     */
     unsigned char  vidResetDelay;     /* video signal suppression time      */
@@ -733,7 +951,7 @@ typedef struct CG_BC_EEP_STRUCT
 typedef struct CG_BC_RAM_STRUCT
    {
     unsigned char  reserved[4];                         /* reserved         */
-    unsigned char  postCodeEnable;                      /* POST code enable */
+    unsigned char  unused;                                           //MOD044
                                                                      //MOD017v
     unsigned char  flagsByte1;                          /* flags byte 1     */
     unsigned char  padding[2];
@@ -783,13 +1001,13 @@ typedef struct CGBC_WD_PARMS_STRUCT
     unsigned char  wdInitCmd;                /* CGBC_CMD_WD_INIT             */
     unsigned char  wdMode;                   /* watchdog mode                */
     unsigned char  wdCtrl;                   /* watchdog control byte        */
-    UINT16 wdSt1TimL;                /* watchdog stage 1 time (msec) */ //MOD008
+    uint16_t       wdSt1TimL;                /* watchdog stage 1 time (msec) */ //MOD008 MOD070
     unsigned char  wdSt1TimH;
-    UINT16 wdSt2TimL;                /* watchdog stage 2 time (msec) */ //MOD008
+    uint16_t       wdSt2TimL;                /* watchdog stage 2 time (msec) */ //MOD008 MOD070
     unsigned char  wdSt2TimH;
-    UINT16 wdSt3TimL;                /* watchdog stage 3 time (msec) */ //MOD008
+    uint16_t       wdSt3TimL;                /* watchdog stage 3 time (msec) */ //MOD008 MOD070
     unsigned char  wdSt3TimH;
-    UINT16 wdDlyTimL;                /* watchdog delay time   (msec) */ //MOD008
+    uint16_t       wdDlyTimL;                /* watchdog delay time   (msec) */ //MOD008 MOD070
     unsigned char  wdDlyTimH;
    } CGBC_WD_PARMS, *P_CGBC_WD_PARMS;
                                                                      //MOD002^
@@ -937,6 +1155,7 @@ typedef struct CGBC_CMD_AUX_INIT_IN_STRUCT
 #define CGBC_SCI_EVT_LID_OPEN           8                            //MOD017
 #define CGBC_SCI_EVT_LID_CLOSE          9                            //MOD017
 #define CGBC_SCI_EVT_SLP_BTN            10                           //MOD017
+#define CGBC_SCI_EVT_PWR_BTN            11                           //MOD045
 
 
 
@@ -1060,7 +1279,11 @@ typedef struct CGBC_CMD_POST_CODE_IN_STRUCT     // command packet structure
 #define  CGBC_POWER_LOSS_LAST  0x02
                                                                      //MOD003^
 #define CGBC_RTC_PRESENT      0x80                                   //MOD011
-
+                                                                     //MOD044v
+#define CGBC_BATLOWn_INIT_MSK 0x80
+#define  CGBC_BATLOWn_INIT_LOW 0x00
+#define  CGBC_BATLOWn_INIT_TRI 0x80
+                                                                     //MOD044^
 
                                                                      //MOD004v
 /*----------------------------------
@@ -1142,7 +1365,23 @@ typedef struct CGBC_CMD_BTN_CONTROL_IN_STRUCT   // command packet structure
     unsigned char cmd;                          // CGBC_CMD_BTN_CONTROL
     unsigned char parm;                         // button control parameter
    } CGBC_CMD_BTN_CONTROL_IN, *P_CGBC_CMD_BTN_CONTROL_IN;
+                                                                      //MOD044v
+#endif //!__ASSEMBLER__
+
+/* button control parameter bit mapping */
+#define CGBC_RST_BTN_DESELECT 0x01   /* reset button control update disabled */
+#define CGBC_LID_BTN_DESELECT 0x02   /*   LID button control update disabled */
+#define CGBC_SLP_BTN_DESELECT 0x04   /* sleep button control update disabled */
+#define CGBC_PWR_BTN_DESELECT 0x08   /* power button control update disabled */
+#if 0                                           /* same as in feature byte 1 */
+#define CGBC_RST_BTN_INHIBIT  0x10              /* 1 = reset button disabled */
+#define CGBC_LID_BTN_INHIBIT  0x20              /* 1 = LID button disabled   */
+#define CGBC_SLP_BTN_INHIBIT  0x40              /* 1 = sleep button disabled */
+#define CGBC_PWR_BTN_INHIBIT  0x80              /* 1 = power button disabled */
+#endif
 
+#ifndef __ASSEMBLER__
+                                                                      //MOD044^
 typedef struct CGBC_CMD_BTN_CONTROL_OUT_STRUCT  // response packet structure
    {
     unsigned char sts;                          // command status
@@ -1183,7 +1422,7 @@ typedef struct CGBC_CMD_FAN_CONTROL_IN_STRUCT   // command packet structure
 typedef struct CGBC_CMD_FAN_CONTROL_OUT_STRUCT  // response packet structure
    {
     unsigned char  sts;                         // command status
-    UINT16 speed;                       // current fan speed count
+    uint16_t       speed;                       // current fan speed count MOD070
    } CGBC_CMD_FAN_CONTROL_OUT, *P_CGBC_CMD_FAN_CONTROL_OUT;
 
 #endif //!__ASSEMBLER__
@@ -1228,7 +1467,7 @@ typedef struct CGBC_CMD_FAN_CONTROL_OUT_STRUCT  // response packet structure
 typedef struct CGBC_CMD_RTC_IN_STRUCT           // command packet structure
    {
     unsigned char  cmd;                         // CGBC_CMD_RTC
-    UINT16 year;                        // year to be set or 0
+    uint16_t       year;                        // year to be set or 0 MOD070
     unsigned char  month;                       // month to be set
     unsigned char  day;                         // day to be set
     unsigned char  hour;                        // hour to be set
@@ -1239,7 +1478,7 @@ typedef struct CGBC_CMD_RTC_IN_STRUCT           // command packet structure
 typedef struct CGBC_CMD_RTC_OUT_STRUCT          // response packet structure
    {
     unsigned char  sts;                         // command status
-    UINT16 yearSts;                     // current year and flags
+    uint16_t       yearSts;                     // current year and flags MOD070
     unsigned char  month;                       // current month
     unsigned char  day;                         // current day
     unsigned char  hour;                        // current hour
@@ -1337,6 +1576,7 @@ typedef struct CGBC_CMD_SBSM_DATA_OUT_STRUCT
  *------------------------------------
  */
 
+/* HWM data header structure */
 typedef struct CGBC_HWM_DATA_HDR_STRUCT
     {
      uint8_t sts;                       /* hardware monitoring status byte  */
@@ -1345,18 +1585,22 @@ typedef struct CGBC_HWM_DATA_HDR_STRUCT
      uint8_t res;                       /* reserved                         */
     } CGBC_HWM_DATA_HDR, *P_CGBC_HWM_DATA_HDR;
 
+/* sensor info structure */
 typedef struct CGBC_HWM_SENSOR_STRUCT
     {
      uint8_t typ;                       /* hardware monitoring sensor type  */
-     SINT16  val;                       /* hardware monitoring sensor value */
+     int16_t val;                       /* hardware monitoring sensor value */ //MOD070
      uint8_t res;                       /* reserved                         */
     } CGBC_HWM_SENSOR, *P_CGBC_HWM_SENSOR;
 
-//typedef struct CGBC_HWM_DATA_STRUCT
-//    {
-//     CGBC_HWM_DATA_HDR hdr;             /* HWM data space header            */
-//     CGBC_HWM_SENSOR   sensorTbl[];     /* hardware monitoring sensor table */
-//    } CGBC_HWM_DATA, *P_CGBC_HWM_DATA;
+                                                                   /*MOD043v*/
+/* complete HWM data space  */
+typedef struct CGBC_HWM_DATA_STRUCT
+    {
+     CGBC_HWM_DATA_HDR hdr;             /* HWM data space header            */
+     CGBC_HWM_SENSOR   sensorTbl[];     /* hardware monitoring sensor table */
+    } CGBC_HWM_DATA, *P_CGBC_HWM_DATA;
+                                                                   /*MOD043^*/
                                                                    /*MOD038^*/
 
                                                                      //MOD014v
@@ -1406,7 +1650,18 @@ typedef struct CGBC_HWM_SENSOR_STRUCT
  #define CGBC_TEMP_VIDEO         0x07
  #define CGBC_TEMP_OTHER         0x08
  #define CGBC_TEMP_DIMM_TOP      0x09
+ #define CGBC_TEMP_DIMM_TOP_0    0x09                              /* MOD051 v*/
  #define CGBC_TEMP_DIMM_BOTTOM   0x0A
+ #define CGBC_TEMP_DIMM_BOT_0    0x0A                              /* MOD052 */
+ #define CGBC_TEMP_BOARD_ALT     0x0B                              /* MOD049 */
+ #define CGBC_TEMP_DIMM_TOP_1    0x0C                              /* MOD051 ^*/
+ #define CGBC_TEMP_DIMM_TOP_2    0x0D                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_3    0x0E                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_4    0x0F                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_5    0x10                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_6    0x11                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_TOP_7    0x12                              /* MOD052 */
+ #define CGBC_TEMP_DIMM_BOT_1    0x13                              /* MOD052 */
 
  #define CGBC_VOLTAGE_CPU        0x01
  #define CGBC_VOLTAGE_DC         0x02
@@ -1474,7 +1729,7 @@ CGBC_HU_CFG, *P_CGBC_HU_CFG;
 #define CGBC_HU_RUNTIME           0x40   /* S0 runtime power state supported */
 #define CGBC_HU_STANDBY           0x20   /* Sx standby power state supported */
 #define CGBC_HU_HOST_CONTROLLED   0x10   /* host controlled, no auto-on      */
-#define CGBC_HU_FILTER_DEPTH_MASK 0x07   /* sensor/actuator I/O filter depth */
+#define CGBC_HU_FILTER_DEPTH_MASK 0x07   /* sensor input filter depth        */
 #define CGBC_HU_FILTER_DEPTH_128  0x07
 #define CGBC_HU_FILTER_DEPTH_64   0x06
 #define CGBC_HU_FILTER_DEPTH_32   0x05
@@ -1483,7 +1738,19 @@ CGBC_HU_CFG, *P_CGBC_HU_CFG;
 #define CGBC_HU_FILTER_DEPTH_4    0x02
 #define CGBC_HU_FILTER_DEPTH_2    0x01
 #define CGBC_HU_FILTER_OFF        0x00
-
+                                                                      //MOD044v
+#define CGBC_HU_STEP_WIDTH_MASK   0x07   /* maximum actuator set point       */
+                                                                      //MOD045v
+#define CGBC_HU_STEP_WIDTH_1      0x07   /* stepping width in percentage of  */
+#define CGBC_HU_STEP_WIDTH_2      0x06   /* the actuator set point range     */
+#define CGBC_HU_STEP_WIDTH_4      0x05   /* (ui16SetMax - ui16SetMin)        */
+#define CGBC_HU_STEP_WIDTH_8      0x04
+#define CGBC_HU_STEP_WIDTH_16     0x03
+#define CGBC_HU_STEP_WIDTH_32     0x02
+#define CGBC_HU_STEP_WIDTH_64     0x01
+#define CGBC_HU_STEP_WIDTH_100    0x00
+                                                                      //MOD045^
+                                                                      //MOD044^
 typedef struct
 CGBC_HWM_SENSOR_UNIT_CONFIG_STRUCT /* This is the structure of the config
  * parameters for HWM sensor units. */
@@ -1493,7 +1760,7 @@ CGBC_HWM_SENSOR_UNIT_CONFIG_STRUCT /* This is the structure of the config
   uint8_t   ui8PhyType;                   /* physical sensor type            */
   uint8_t   ui8BusNum;                    /* bus on which the sensor resides */
   uint8_t   ui8DevAddr;                   /* sensor device address           */
-  uint32_t ui32Reserved;                  /* reserved for future extensions  */
+  uint8_t  aui8Reserved[0];               /* reserved for extensions  MOD057 */
 }
 CGBC_HSU_CFG, *P_CGBC_HSU_CFG;
 
@@ -1507,6 +1774,8 @@ CGBC_HSU_CFG, *P_CGBC_HSU_CFG;
 #define CGBC_HSU_MCU_INT    0x03
 #define CGBC_HSU_DIMM_SMB   0x04
 #define CGBC_HSU_ISL28022   0x05
+#define CGBC_HSU_G781_SMB   0x06                                      //MOD044
+#define CGBC_HSU_INTEL_ESPI 0x07                                      //MOD046
 #define CGBC_HSU_NONE       0xFF
 
 typedef struct
@@ -1522,13 +1791,14 @@ CGBC_HWM_ACTUATOR_UNIT_CONFIG_STRUCT /* This is the structure of the config
   uint16_t ui16SetMax;                  /* set point maximum                 */
   uint16_t ui16SetDflt;                 /* default set point                 */
   uint16_t ui16SetCur;                  /* current set point                 */
-  uint32_t ui32Reserved;                /* reserved for future extensions    */
+  uint8_t  aui8Reserved[0];             /* reserved for extensions    MOD057 */
 }
 CGBC_HAU_CFG, *P_CGBC_HAU_CFG;
 
 /* Values for the logical actuator type (CGBC_HAU_CFG.ui8LogType) */
 #define CGBC_HAU_RESERVED 0x00
 #define CGBC_HAU_FAN_CPU  0x01
+#define CGBC_HAU_FAN_SYS  0x02                                        //MOD046
 
 /* Values for the physical actuator type (CGBC_HAU_CFG.ui8PhyType) */
 #define CGBC_HAU_UNKNOWN    0x00
@@ -1549,7 +1819,10 @@ CGBC_HWM_CONTROL_UNIT_CONFIG_STRUCT /* This is the structure of the config
   uint8_t   ui8SetLo;           /* set point when sensor below lower limit   */
   uint8_t   ui8SenSel;          /* HWM sensor selector                       */
   uint8_t   ui8ActSel;          /* HWM actuator selector                     */
-  uint32_t ui32Reserved;        /* reserved for future extensions            */
+  uint8_t   ui8SenPin;          /* pin number of MCU pin sensor       MOD056 */
+  uint8_t   ui8ActPin;          /* pin number of MCU pin actuator     MOD056 */
+  uint8_t   ui8Usage;           /* intended HWM control unit usage    MOD058 */
+  uint8_t  aui8Reserved[0];     /* reserved for future extensions     MOD057 */
 }
 CGBC_HCU_CFG, *P_CGBC_HCU_CFG;
 
@@ -1561,6 +1834,7 @@ CGBC_HWM_UNIT_CONFIG_UNION /* This is the overall union of config parameters
   CGBC_HSU_CFG xSen;           /* HWM sensor unit config parameters          */
   CGBC_HAU_CFG xAct;           /* HWM actuator unit config parameters        */
   CGBC_HCU_CFG xCtl;           /* HWM control unit config parameters         */
+  uint8_t aui8RawData[24];     /* maximum structure size              MOD057 */
 }
 CGBC_HWM_UNIT_CFG, *P_CGBC_HWM_UNIT_CFG;
 
@@ -1592,6 +1866,21 @@ CGBC_CMD_HWM_CFG_OUT_STRUCT /* response data structure for CGBC_CMD_HWM_CFG */
 
 #define CGBC_HUN_MASK     0x1F  /* HWM unit number */
                                                                      //MOD040^
+                                                                     //MOD056v
+/* Special HWM unit selectors */
+#define CGBC_HUS_RESERVED_1F  (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 0))
+#define CGBC_HUS_MCU_GPIL_SEN (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 1))
+#define CGBC_HUS_MCU_GPIH_SEN (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 2))
+#define CGBC_HUS_MCU_GPOL_ACT (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 3))
+#define CGBC_HUS_MCU_GPOH_ACT (CGBC_HUT_RESERVED | (CGBC_HUN_MASK - 4))
+                                                                     //MOD056^
+                                                                     //MOD058v
+/* intended HWM control unit usage codes */
+#define CGBC_HCU_USAGE_GENERAL  0x00               /* general purpose        */
+#define CGBC_HCU_USAGE_CPU_TEMP 0x01               /* CPU thermal control    */
+#define CGBC_HCU_USAGE_SYS_TEMP 0x02               /* system thermal control */
+#define CGBC_HCU_USAGE_CPU_THRT 0x03               /* CPU throttling control */
+                                                                     //MOD058^
                                                                      //MOD023v
 /*----------------------------------------
  * CGBC_CMD_PECI command/response packets
@@ -1895,9 +2184,9 @@ typedef struct CGBC_CMD_HWM_SENSOR_OUT_STRUCT   /* response packet structure */
 typedef struct
 CGBC_POST_CFG_PARMS_STRUCT         /* POST Code Feature parameter structure  */
 {
-  uint8_t  ctrl;                                /* control parameter         */
-  uint16_t ch1Addr;                             /* channel 1 I/O address     */
-  uint8_t  relayDevAddr;                        /* relay device address      */
+  uint8_t  ctrl;                             /* control parameter            */
+  uint16_t ch1Addr;                          /* debug port address parameter */
+  uint8_t  relayDevAddr;                     /* relay device address         */
 } CGBC_POST_CFG_PARMS, *P_CGBC_POST_CFG_PARMS;
 
 typedef struct
@@ -1930,6 +2219,20 @@ CGBC_CMD_POST_CFG_OUT_STRUCT                    /* response packet structure */
 #define CGBC_POST_CH3_ENABLE    0x04   /* 3rd POST code input channel enable */
 #define CGBC_POST_CH2_ENABLE    0x02   /* 2nd POST code input channel enable */
 #define CGBC_POST_CH1_ENABLE    0x01   /* 1st POST code input channel enable */
+                                                                      //MOD044v
+/* debug port address parameter bit mapping */
+#define CGBC_POST_CH1_ADDR_MSK 0xFFF8       /* primary debug port address    */
+#define CGBC_POST_CH2_ADDR_MSK 0x0003       /* secondary debug port decoding */
+#define  CGBC_POST_CH2_ADDR_4   0x0000      /*   - primary port address + 4  */
+#define  CGBC_POST_CH2_ADDR_1   0x0001      /*   - primary port address + 1  */
+#define  CGBC_POST_CH2_ADDR_2   0x0010      /*   - primary port address + 2  */
+                                                                      //MOD044^
+                                                                      //MOD066v
+#define CGBC_POST_SEC_DISPLAY_DIS 0x0004 /* Actively disable the secondary POST
+                                          * code display which are the lower
+										  * two digits. */
+                                                                      //MOD066^
+
 
 /*-------------------------------
  * CGBC_CMD_LFP_DELAY parameters
@@ -1989,15 +2292,1064 @@ CGBC_CMD_DIAG_CFG_OUT_STRUCT                    /* response packet structure */
 #define CGBC_DIAG_CFG_UPDATE    0x80   /* current config update request      */
 #define CGBC_DIAG_EEP_UPDATE    0x40   /* EEPROM parameter update request    */
 
-#define CGBC_DIAG_RES_MSK       0x38   /* reserved / must be zero            */
+#define CGBC_DIAG_UART_MUX_M    0x20     /* UART mux config bit     */ //MOD055
+#define  CGBC_DIAG_UART_MUX_cBC  0x00    /*  - cBC UART selected    */ //MOD055
+#define  CGBC_DIAG_UART_MUX_SoC  0x20    /*  - SoC UART selected    */ //MOD055
+
+#define CGBC_DIAG_DHCC_ENA      0x10     /* DHCC enable             */ //MOD053
 
-#define CGBC_DIAG_IF_MSK        0x07   /* diagnostic console I/F select      */
-#define  CGBC_DIAG_CON_OFF       0x00  /*   - diagnostic console disabled    */
-#define  CGBC_DIAG_CON_AUX       0x01  /*   - auxiliary system serial port   */
-#define  CGBC_DIAG_CON_SER0      0x02  /*   - system COM port 0              */
-#define  CGBC_DIAG_CON_SER1      0x03  /*   - system COM port 1              */
+#define CGBC_DIAG_IF_MSK        0x0F     /* diag console I/F select */ //MOD044
+#define  CGBC_DIAG_CON_OFF       0x00    /*   - diagnostic console disabled  */
+#define  CGBC_DIAG_CON_AUX       0x01    /*   - auxiliary serial port        */
+#define  CGBC_DIAG_CON_SER0      0x02    /*   - system serial port 0         */
+#define  CGBC_DIAG_CON_SER1      0x03    /*   - system serial port 1         */
+#define  CGBC_DIAG_CON_I2C0      0x08    /*   - primary I2C-bus     */ //MOD044
+#define  CGBC_DIAG_CON_SMB0      0x0A    /*   - primary SMBus       */ //MOD044
                                                                    /*      ^ */
                                                                    /* MOD041 */
+                                                                      //MOD045v
+/*-------------------------------
+ * CGBC_CMD_PWROK_DELAY parameters
+ *-------------------------------
+ */
+typedef struct
+CGBC_CMD_PWROK_DELAY_IN_STRUCT                  /* command packet structure  */
+{
+  uint8_t cmd;                                  /* CGBC_CMD_PWROK_DELAY      */
+  uint8_t ui8PwrokDelay25ms;                    /* delay in units of 25ms    */
+} CGBC_CMD_PWROK_DELAY_IN, *P_CGBC_CMD_PWROK_DELAY_IN;
+
+typedef struct
+CGBC_CMD_PWROK_DELAY_OUT_STRUCT                 /* response packet structure */
+{
+  uint8_t sts;                                  /* command status            */
+  uint8_t ui8PwrokDelay25ms;                    /* delay in units of 25ms    */
+} CGBC_CMD_PWROK_DELAY_OUT, *P_CGBC_CMD_PWROK_DELAY_OUT;
+
+#define CGBC_PWROK_DELAY_READ 0xFF /* reserved delay value for read function */
+                                                                      //MOD045^
+
+                                                                      //MOD044v
+/* --------------------------------------------
+ * Event logging tags and log buffer entries
+ * ----------------------------------------- */
+
+#define CGBC_LOG_TAG_SYST   0x10        /* log entry with system time stamp  */
+#define CGBC_LOG_TAG_LOGT   0x08        /* log entry with logging time stamp */
+#define CGBC_LOG_TAG_NOTS   0x00        /* log entry without time stamp      */
+#define CGBC_LOG_TAG_SIZE_M 0x07        /* log entry data size mask          */
+
+/* single tag entries */
+#define CGBC_LOG_TAG_HOST_EV0    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 0) /* no additional data */
+
+/* tags for events with one data byte */
+#define CGBC_LOG_TAG_HOST_EV1    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by event byte */
+#define CGBC_LOG_TAG_PIN_HI      (( 1 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by pin # */
+#define CGBC_LOG_TAG_PIN_LO      (( 2 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by pin # */
+                                                                   /* MOD047 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_POST_CH1    (( 3 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by POST code */
+#define CGBC_LOG_TAG_POST_CH2    (( 4 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by POST code */
+#define CGBC_LOG_TAG_POST_CH3    (( 5 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by POST code */
+                                                                   /*      ^ */
+                                                                   /* MOD047 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_VIR_HI      (( 6 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by logical pin function */
+#define CGBC_LOG_TAG_VIR_LO      (( 7 << 5) | CGBC_LOG_TAG_NOTS | 1) /* followed by logical pin function */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+/* tags for events with two data bytes */
+#define CGBC_LOG_TAG_HOST_EV2    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 2) /* followed by event word */
+#define CGBC_LOG_TAG_ANALOG      (( 1 << 5) | CGBC_LOG_TAG_NOTS | 2) /* followed by ADC channel/value */
+                                                                   /* MOD067 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_SYS_EV      (( 2 << 5) | CGBC_LOG_TAG_NOTS | 2) /* followed by group/event */
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
+/* tags for events with three data bytes */
+#define CGBC_LOG_TAG_HOST_EV3    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 3) /* followed by three event bytes */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_HWM_EV      (( 1 << 5) | CGBC_LOG_TAG_NOTS | 3) /* followed by HWM log ID/value */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+/* tags for events with four data bytes */
+#define CGBC_LOG_TAG_HOST_EV4    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 4) /* followed by event dword */
+#define CGBC_LOG_TAG_HOST_EV0_ST (( 0 << 5) | CGBC_LOG_TAG_SYST | 4) /* followed by system time stamp */
+#define CGBC_LOG_TAG_HOST_EV0_LT (( 0 << 5) | CGBC_LOG_TAG_LOGT | 4) /* followed by logging time stamp */
+
+/* tags for events with five data bytes */
+#define CGBC_LOG_TAG_HOST_EV5    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 5) /* followed by five event bytes */
+#define CGBC_LOG_TAG_HOST_EV1_ST (( 0 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by event byte and system time stamp */
+#define CGBC_LOG_TAG_HOST_EV1_LT (( 0 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by event byte and logging time stamp */
+#define CGBC_LOG_TAG_PIN_HI_ST   (( 1 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by pin # and system time stamp */
+#define CGBC_LOG_TAG_PIN_HI_LT   (( 1 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by pin # and logging time stamp */
+#define CGBC_LOG_TAG_PIN_LO_ST   (( 2 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by pin # and system time stamp */
+#define CGBC_LOG_TAG_PIN_LO_LT   (( 2 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by pin # and logging time stamp */
+                                                                   /* MOD047 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_POST_CH1_ST (( 3 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by POST code and system time stamp */
+#define CGBC_LOG_TAG_POST_CH1_LT (( 3 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by POST code and logging time stamp */
+#define CGBC_LOG_TAG_POST_CH2_ST (( 4 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by POST code and system time stamp */
+#define CGBC_LOG_TAG_POST_CH2_LT (( 4 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by POST code and logging time stamp */
+#define CGBC_LOG_TAG_POST_CH3_ST (( 5 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by POST code and system time stamp */
+#define CGBC_LOG_TAG_POST_CH3_LT (( 5 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by POST code and logging time stamp */
+                                                                   /*      ^ */
+                                                                   /* MOD047 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_VIR_HI_ST   (( 6 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by ogical pin function and system time stamp */
+#define CGBC_LOG_TAG_VIR_HI_LT   (( 6 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by ogical pin function and logging time stamp */
+#define CGBC_LOG_TAG_VIR_LO_ST   (( 7 << 5) | CGBC_LOG_TAG_SYST | 5) /* followed by ogical pin function and system time stamp */
+#define CGBC_LOG_TAG_VIR_LO_LT   (( 7 << 5) | CGBC_LOG_TAG_LOGT | 5) /* followed by ogical pin function and logging time stamp */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+/* tags for events with six data bytes */
+#define CGBC_LOG_TAG_HOST_EV6    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 6) /* followed by six event bytes */
+#define CGBC_LOG_TAG_HOST_EV2_ST (( 0 << 5) | CGBC_LOG_TAG_SYST | 6) /* followed by event word and system time stamp */
+#define CGBC_LOG_TAG_HOST_EV2_LT (( 0 << 5) | CGBC_LOG_TAG_LOGT | 6) /* followed by event word and logging time stamp */
+#define CGBC_LOG_TAG_ANALOG_ST   (( 1 << 5) | CGBC_LOG_TAG_SYST | 6) /* followed by ADC channel/value and system time stamp */
+#define CGBC_LOG_TAG_ANALOG_LT   (( 1 << 5) | CGBC_LOG_TAG_LOGT | 6) /* followed by ADC channel/value and logging time stamp */
+                                                                   /* MOD067 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_SYS_EV_ST   (( 2 << 5) | CGBC_LOG_TAG_SYST | 6) /* followed by group/event and logging time stamp */
+#define CGBC_LOG_TAG_SYS_EV_LT   (( 2 << 5) | CGBC_LOG_TAG_LOGT | 6) /* followed by group/event and logging time stamp */
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
+/* tags for events with seven data bytes */
+#define CGBC_LOG_TAG_HOST_EV7    (( 0 << 5) | CGBC_LOG_TAG_NOTS | 7) /* followed by seven event bytes */
+#define CGBC_LOG_TAG_HOST_EV3_ST (( 0 << 5) | CGBC_LOG_TAG_SYST | 7) /* followed by three event bytes and system time stamp */
+#define CGBC_LOG_TAG_HOST_EV3_LT (( 0 << 5) | CGBC_LOG_TAG_LOGT | 7) /* followed by three event bytes and logging time stamp */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_TAG_HWM_EV_ST   (( 1 << 5) | CGBC_LOG_TAG_SYST | 7) /* followed by HWM log ID/value and system time stamp */
+#define CGBC_LOG_TAG_HWM_EV_LT   (( 1 << 5) | CGBC_LOG_TAG_LOGT | 7) /* followed by HWM log ID/value and logging time stamp */
+
+/* HWM log IDs */
+#define CGBC_LOG_HWM_VIN 0 /* voltage on the runtime power input rail */
+#define CGBC_LOG_HWM_VSB 1 /* voltage on the standby power input rail */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+                                                                   /* MOD067 */
+                                                                   /*      v */
+/* system event groups */
+#define CGBC_LOG_ESPI_EV 0
+
+/* eSPI events */
+#define CGBC_LOG_ESPI_RST_HI       0x00
+#define CGBC_LOG_ESPI_RST_LO       0x01
+#define CGBC_LOG_ESPI_VW_ON        0x02
+#define CGBC_LOG_ESPI_OOB_OFF      0x03
+#define CGBC_LOG_ESPI_OOB_ON       0x04
+#define CGBC_LOG_ESPI_FLS_OFF      0x05
+#define CGBC_LOG_ESPI_FLS_ON       0x06
+#define CGBC_LOG_ESPI_PC_OFF       0x07
+#define CGBC_LOG_ESPI_PC_ON        0x08
+#define CGBC_LOG_ESPI_OOBRSTWRN_HI 0x09
+#define CGBC_LOG_ESPI_OOBRSTWRN_LO 0x0A
+#define CGBC_LOG_ESPI_OOBRSTACK_HI 0x0B
+#define CGBC_LOG_ESPI_OOBRSTACK_LO 0x0C
+#define CGBC_LOG_ESPI_HSTRSTWRN_HI 0x0D
+#define CGBC_LOG_ESPI_HSTRSTWRN_LO 0x0E
+#define CGBC_LOG_ESPI_HSTRSTACK_HI 0x0F
+#define CGBC_LOG_ESPI_HSTRSTACK_LO 0x10
+#define CGBC_LOG_ESPI_LPCPDn_HI    0x11
+#define CGBC_LOG_ESPI_LPCPDn_LO    0x12
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
+/* log buffer entry structures */
+typedef struct
+CGBC_EVENT_B_STRUCT   { uint8_t   ui8Tag;
+                        uint8_t   ui8Dat;     } cgbc_event_b_t;
+typedef struct
+CGBC_EVENT_W_STRUCT   { uint8_t   ui8Tag;
+                        uint16_t ui16Dat;     } cgbc_event_w_t;
+                                                                   /* MOD067 */
+                                                                   /*      v */
+typedef struct
+CGBC_EVENT_B2_STRUCT  { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[2];  } cgbc_event_b2_t;
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+typedef struct
+CGBC_EVENT_B3_STRUCT  { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[3];  } cgbc_event_b3_t;
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+typedef struct
+CGBC_EVENT_D_STRUCT   { uint8_t   ui8Tag; 
+                        uint32_t ui32Dat;     } cgbc_event_d_t;
+typedef struct
+CGBC_EVENT_B7_STRUCT  { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[7];  } cgbc_event_b7_t;
+typedef struct
+CGBC_EVENT_BT_STRUCT  { uint8_t   ui8Tag;
+                        uint8_t   ui8Dat;
+                        uint32_t ui32Tim;     } cgbc_event_bt_t;
+typedef struct
+CGBC_EVENT_WT_STRUCT  { uint8_t   ui8Tag;
+                        uint16_t ui16Dat;
+                        uint32_t ui32Tim;     } cgbc_event_wt_t;
+                                                                   /* MOD067 */
+                                                                   /*      v */
+typedef struct
+CGBC_EVENT_B2T_STRUCT { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[2];
+                        uint32_t ui32Tim;     } cgbc_event_b2t_t;
+                                                                   /*      ^ */
+                                                                   /* MOD067 */
+typedef struct
+CGBC_EVENT_B3T_STRUCT { uint8_t   ui8Tag;
+                        uint8_t  aui8Dat[3];
+                        uint32_t ui32Tim;     } cgbc_event_b3t_t;
+typedef union
+CGBC_EVENT_UNION      { cgbc_event_b_t   b;
+                        cgbc_event_w_t   w;
+                        cgbc_event_d_t   d;
+                        cgbc_event_b7_t  b7;
+                        cgbc_event_bt_t  bt;
+                        cgbc_event_wt_t  wt;
+                        cgbc_event_b3t_t b3t; } cgbc_event_t;
+
+/* ---------------------------------------
+ * CGBC_CMD_LOG_CFG command definitions
+ * ------------------------------------ */
+
+/* event logging configuration structure */
+typedef struct
+CGBC_LOG_CFG_STRUCT
+{
+  uint8_t   ui8CtlSts;                  /* event logging control/status byte */
+  uint32_t ui32EventSelect;             /* event selection flags             */
+  uint32_t ui32SysTimEna;               /* system time stamp enable flags    */
+  uint32_t ui32LogTimEna;               /* logging time stamp enable flags   */
+  uint32_t ui32StartTriggerSelect;      /* start trigger selection flags     */
+  uint32_t ui32StopTriggerSelect;       /* stop trigger selection flags      */
+  uint32_t ui32LogTimFrq;               /* logging timer frequency in Hz     */
+} CGBC_LOG_CFG, *P_CGBC_LOG_CFG;
+
+/* command package structure */
+typedef struct
+CGBC_CMD_LOG_CFG_IN_STRUCT
+{
+  uint8_t    ui8Cmd;                          /* CGBC_CMD_LOG_CFG            */
+  CGBC_LOG_CFG xCfg;                          /* event logging configuration */
+} CGBC_CMD_LOG_CFG_IN, *P_CGBC_CMD_LOG_CFG_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_LOG_CFG_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                      /* CGBC status byte            */
+  CGBC_LOG_CFG  xCfg;                         /* event logging configuration */
+} CGBC_CMD_LOG_CFG_OUT, *P_CGBC_CMD_LOG_CFG_OUT;
+
+/* Event logging control byte bit mapping */
+#define CGBC_LOG_CFG_UPDATE 0x80         /* current config update request    */
+#define CGBC_LOG_EEP_UPDATE 0x40         /* EEPROM parameter update request  */
+#define CGBC_LOG_START_TRIG 0x20         /* start logging upon start trigger */
+                                                                   /* MOD047 */
+                                                                   /*      v */
+#define CGBC_LOG_RETAIN_BUF 0x10      /* retain buffer upon repeated trigger */
+                                                                   /*      ^ */
+                                                                   /* MOD047 */
+#define CGBC_LOG_REP_MODE   0x08         /* repeat mode                      */
+#define CGBC_LOG_CIR_MODE   0x04         /* circular mode                    */
+#define CGBC_LOG_RES_M      0x02         /* reserved / must be zero          */
+#define CGBC_LOG_ENABLE     0x01         /* event logging enable switch      */
+
+/* Event logging status byte bit mapping */
+#define CGBC_LOG_STS_RES_M     0xFC           /* reserved / must be ignored  */
+#define CGBC_LOG_STATE_M       0x03           /* event logging state mask    */
+#define  CGBC_LOG_STATE_OFF     0x00          /*   - off                     */
+#define  CGBC_LOG_STATE_ARMED   0x01          /*   - armed, awaiting trigger */
+#define  CGBC_LOG_STATE_STOPPED 0x02          /*   - stopped                 */
+#define  CGBC_LOG_STATE_ON      0x03          /*   - on, recording events    */
+
+/* Event logging flag parameter bit mapping */
+                                                                   /* MOD047 */
+                                                                   /*      v */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_FLG_RES_M   0xFF000030    /* reserved / must be zero        */
+
+#define CGBC_LOG_VIRT_SIG_M  0x00FF0000    /* specific virtual signal mask   */
+#define CGBC_LOG_VIRT_SIG_S  16            /* specific virt. signal shft cnt */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+#define CGBC_LOG_POST_CODE_M 0x0000FF00    /* specific POST code mask        */
+#define CGBC_LOG_POST_CODE_S 8             /* specific POST code shift count */
+
+#define CGBC_LOG_POST_SEL_M  0x00000080    /* POST code select mask          */
+#define CGBC_LOG_POST_SEL_ALL 0x00000000   /* select all POST codes          */
+#define CGBC_LOG_POST_SEL_ONE 0x00000080   /* select a specific POST code    */
+                                                                   /*      ^ */
+                                                                   /* MOD047 */
+                                                                   /* MOD064 */
+                                                                   /*      v */
+#define CGBC_LOG_VIRT_SEL_M  0x00000040    /* virtual signal select mask     */
+#define CGBC_LOG_VIRT_SEL_ALL 0x00000000   /* select all virtual signals     */
+#define CGBC_LOG_VIRT_SEL_ONE 0x00000040   /* select a specific virt. signal */
+
+#define CGBC_LOG_VIRT_ENABLE 0x00000008    /* virtual signals logging enable */
+                                                                   /*      ^ */
+                                                                   /* MOD064 */
+#define CGBC_LOG_PCTL_ENABLE 0x00000004    /* power control logging enable   */ /* MOD064 */
+#define CGBC_LOG_POST_ENABLE 0x00000002    /* POST code logging enable       */
+#define CGBC_LOG_GPIO_ENABLE 0x00000001    /* MCU pin logging enable         */
+
+/* ----------------------------------------
+ * CGBC_CMD_LOG_READ command definitions
+ * ------------------------------------- */
+
+/* command package structure */
+typedef struct
+CGBC_CMD_LOG_READ_IN_STRUCT
+{
+  uint8_t ui8Cmd;                            /* CGBC_CMD_LOG_READ            */
+  uint8_t ui8First;                          /* 1 = 1st read / 0 = next read */
+} CGBC_CMD_LOG_READ_IN, *P_CGBC_CMD_LOG_READ_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_LOG_READ_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                                 /* CGBC status byte */
+  uint8_t    aui8Data[8];                                /* log entry        */
+} CGBC_CMD_LOG_READ_OUT, *P_CGBC_CMD_LOG_READ_OUT;
+
+/* -----------------------------------------
+ * CGBC_CMD_LOG_WRITE command definitions
+ * -------------------------------------- */
+
+/* command package structure */
+typedef struct
+CGBC_CMD_LOG_WRITE_IN_STRUCT
+{
+  uint8_t ui8Cmd;                                  /* CGBC_CMD_LOG_WRITE     */
+  uint8_t ui8Ctrl;                                 /* log write control byte */
+  uint8_t aui8Data[7];                             /* log write data         */
+} CGBC_CMD_LOG_WRITE_IN, *P_CGBC_CMD_LOG_WRITE_IN;
+                                                                      //MOD046v
+/* log write control byte bit mapping */
+#define CGBC_LOG_WRITE_RES_M    0xE0      /* reserved / must be zero         */
+
+#define CGBC_LOG_WRITE_TSE_M    0x18      /* time stamp enable mask          */
+#define  CGBC_LOG_WRITE_TSE_NONE 0x00     /* no time stamp                   */
+#define  CGBC_LOG_WRITE_TSE_LOG  0x08     /* logging time stamp              */
+#define  CGBC_LOG_WRITE_TSE_SYS  0x10     /* system time stamp               */
+
+#define CGBC_LOG_WRITE_SIZE_M   0x07      /* log write data size mask        */
+#define CGBC_LOG_WRITE_SIZE_S   0         /* log write data size shift count */
+                                                                      //MOD046^
+/* ----------------------------------------
+ * CGBC_CMD_LOG_GPIO command definitions
+ * ------------------------------------- */
+
+/* command package structure */
+typedef struct
+CGBC_CMD_LOG_GPIO_IN_STRUCT
+{
+  uint8_t ui8Cmd;                    /* CGBC_CMD_LOG_GPIO                    */
+  uint8_t ui8CtlSts;                 /* GPIO pin logging control/status byte */
+  uint8_t ui8PinNum;                 /* target GPIO pin number (0-255)       */
+} CGBC_CMD_LOG_GPIO_IN, *P_CGBC_CMD_LOG_GPIO_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_LOG_GPIO_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;             /* CGBC status byte                     */
+  uint8_t     ui8CtlSts;             /* GPIO pin logging control/status byte */
+  uint8_t     ui8PinNum;             /* target GPIO pin number (0-255)       */
+} CGBC_CMD_LOG_GPIO_OUT, *P_CGBC_CMD_LOG_GPIO_OUT;
+
+/* GPIO pin logging control/status byte bit mapping */
+#define CGBC_LOG_GPIO_CUP   0x80          /* current config update request   */
+#define CGBC_LOG_GPIO_EUP   0x40          /* EEPROM parameter update request */
+#define CGBC_LOG_GPIO_RES_M 0x20          /* reserved / must be zero         */
+#define CGBC_LOG_GPIO_ENA   0x10          /* logging enable                  */
+#define CGBC_LOG_GPIO_STT   0x08          /* logging start trigger           */
+#define CGBC_LOG_GPIO_SPT   0x04          /* logging stop trigger            */
+#define CGBC_LOG_GPIO_FEE   0x02          /* falling edge enable             */
+#define CGBC_LOG_GPIO_REE   0x01          /* rising edge enable              */
+
+/* ------------------------------------------
+ * CGBC_CMD_API_CONFIG command definitions
+ * --------------------------------------- */
+
+/* command package structure */
+typedef struct
+CGBC_CMD_API_CONFIG_IN_STRUCT
+{    
+  uint8_t ui8Cmd;                                   /* CGBC_CMD_API_CONFIG   */
+  uint8_t ui8SubCmd;                                /* sub-command           */
+  uint8_t ui8Parm;                                  /* sub-command parameter */
+} CGBC_CMD_API_CONFIG_IN, *P_CGBC_CMD_API_CONFIG_IN;
+
+/* CGBC_CMD_API_CONFIG sub-commands */
+#define CGBC_CMD_API_CMD_DISABLE     0x00
+#define CGBC_CMD_API_SET_RESET_EVENT 0x01
+
+/* CGBC_CMD_API_SET_RESET_EVENT sub-command parameter */
+#define CGBC_API_RESET_MSK     0x03
+#define CGBC_API_RESET_SYS_RST  0x00
+#define CGBC_API_RESET_S5       0x01
+#define CGBC_API_RESET_G3       0x02
+#define CGBC_API_RESET_NEVER    0x03
+
+/*---------------------------------------
+ * CGBC_CMD_COND_RTM command definitions
+ *---------------------------------------
+ */
+                                                                      //MOD045v
+#ifndef __ASSEMBLER__
+
+typedef struct
+CON_RTM_PARAM_STRUCT          /* conditional parameter structure             */
+{
+ uint32_t conRunTimMaxTemp;   /* conditional running time meter max temp     */
+ uint32_t conRunTimMinTemp;   /* conditional running time meter min temp     */
+ uint32_t conRunTimMaxVolt;   /* conditional running time meter max volt     */
+ uint32_t conRunTimMinVolt;   /* conditional running time meter min volt     */
+ uint32_t conRunTimBiosSet;   /* conditional running time meter BIOS setting */
+}CON_RTM_PARAM;
+ 
+typedef struct
+CGBC_CMD_CON_RTM_IN_STRUCT           /* command in packet structure          */
+{
+  uint8_t cmd;                       /* CGBC_CMD_CON_RTM                     */
+  uint8_t subCmd;                    /* Sub command:
+                                      * Stop:  0x00
+                                      * Start: 0x01
+                                      * Read:  0x02
+                                      * Reset: 0x03                          
+                                      * Burn:  0x04                          */
+  CON_RTM_PARAM param;               /* parameters under which condition the
+                                      * running time should be logged        */
+} CGBC_CMD_CON_RTM_IN, *P_CGBC_CMD_CON_RTM_IN;
+
+typedef struct
+CGBC_CMD_CON_RTM_OUT_STRUCT                  /* command out packet structure */
+{
+  uint8_t  sts;                              /* CGBC_CMD_CON_RTM             */
+  uint8_t  conRunTimSts;                     /* Timer status                 */
+  uint16_t conRunTimVolt;                    /* running time over under volt */
+  uint16_t conRunTimTemp;                    /* running time over under temp */
+  uint16_t conRunTimSet;                     /* running time setup node act  */
+  CON_RTM_PARAM param;                       /* parameter out                */
+} CGBC_CMD_CON_RTM_OUT, *P_CGBC_CMD_CON_RTM_OUT;
+
+#endif //!__ASSEMBLER__
+                                                                      //MOD045^
+
+
+/* ----------------------------------------------
+ * CGBC_CMD_BLTx_PWM_DELAY command definitions
+ * ------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_BLT_PWM_DELAY_IN_STRUCT
+{
+  uint8_t ui8Cmd;                                 /* CGBC_CMD_BLTx_PWM_DELAY */
+  int8_t   i8Dly5ms;                              /* delay in units of 5ms   */
+} CGBC_CMD_BLT_PWM_DELAY_IN, *P_CGBC_CMD_BLT_PWM_DELAY_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_BLT_PWM_DELAY_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                          /* CGBC status byte        */
+   int8_t      i8Dly5ms;                          /* delay in units of 5ms   */
+} CGBC_CMD_BLT_PWM_DELAY_OUT, *P_CGBC_CMD_BLT_PWM_DELAY_OUT;
+
+#define CGBC_BLT_PWM_DELAY_READ -128     /* reserved value for read function */
+
+/* ----------------------------------------
+ * CGBC_CMD_PIN_FEAT command definitions
+ * ------------------------------------- */
+                                                                      //MOD046v
+/* command package structure  */
+typedef struct
+CGBC_CMD_PIN_FEAT_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                   /* CGBC_CMD_PIN_FEAT                   */
+  uint8_t   ui8PhyPinVirSta;          /* phys. pin number or virt. pin state */
+  uint16_t ui16PinCfgLogFnc;          /* pin config and/or logical pin func  */
+} CGBC_CMD_PIN_FEAT_IN, *P_CGBC_CMD_PIN_FEAT_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_PIN_FEAT_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;              /* CGBC status byte                    */
+  uint8_t     ui8PhyPinVirSta;        /* phys. pin number or virt. pin state */
+  uint16_t   ui16PinCfgLogFnc;        /* pin config and/or logical pin func  */
+} CGBC_CMD_PIN_FEAT_OUT, *P_CGBC_CMD_PIN_FEAT_OUT;
+
+/* pin configuration / detailed physical pin characteristics */
+#define CGBC_PIN_CFG_MSK 0xFF00
+#define CGBC_PIN_CFG_S   8
+                                                                      //MOD046^
+#define CGBC_PIN_PWR_MSK 0xC000
+#define  CGBC_PIN_PWR_DSW 0xC000 /* deep standby powered */
+#define  CGBC_PIN_PWR_STB 0x8000 /* standby powered */
+#define  CGBC_PIN_PWR_S0  0x4000 /* runtime powered */
+#define  CGBC_PIN_PWR_RES 0x0000 /* reserved */
+
+#define CGBC_PIN_TYP_MSK 0x3000
+#define  CGBC_PIN_TYP_RES 0x3000 /* reserved */
+#define  CGBC_PIN_TYP_ANA 0x2000 /* analog pad */
+#define  CGBC_PIN_TYP_DIG 0x1000 /* digital pad */
+#define  CGBC_PIN_TYP_OFF 0x0000 /* pad off or tri-stated */
+
+#define CGBC_PIN_LOW_MSK 0x0800
+#define  CGBC_PIN_LOW_ENA 0x0800 /* output pin driven low upon logical 0 */
+#define  CGBC_PIN_LOW_DIS 0x0000 /* output pin tri-stated upon logical 0 */
+
+#define CGBC_PIN_PUP_MSK 0x0800
+#define  CGBC_PIN_PUP_ENA 0x0800 /* pull-up enabled */
+#define  CGBC_PIN_PUP_DIS 0x0000 /* pull-up disabled */
+                                                                      //MOD054v
+#define CGBC_PIN_ODV_MSK 0x0800
+#define CGBC_PIN_ODV_FIX  0x0800 /* fixed voltage open-drain output pin */
+#define CGBC_PIN_ODV_TOL  0x0000 /* voltage tolerant open-drain output pin */
+                                                                      //MOD054^
+#define CGBC_PIN_MOD_MSK 0x0400
+#define  CGBC_PIN_MOD_OD  0x0400 /* open-drain mode */
+#define  CGBC_PIN_MOD_PP  0x0000 /* push-pull mode */
+
+#define CGBC_PIN_PDN_MSK 0x0400
+#define  CGBC_PIN_PDN_ENA 0x0400 /* pull-down enabled */
+#define  CGBC_PIN_PDN_DIS 0x0000 /* pull-down disabled */
+
+#define CGBC_PIN_DIR_MSK 0x0200
+#define  CGBC_PIN_DIR_OUT 0x0200 /* output pin */
+#define  CGBC_PIN_DIR_INP 0x0000 /* input pin */
+
+#define CGBC_PIN_LVL_MSK 0x0100
+#define  CGBC_PIN_LVL_HI  0x0100 /* initial output level high */
+#define  CGBC_PIN_LVL_LO  0x0000 /* initial output level low */
+                                                                      //MOD046v
+/* pin configuration / logical pin functions */
+#define CGBC_PIN_FNC_MSK 0x00FF
+#define CGBC_PIN_FNC_S   0
+#define  CGBC_PIN_FNC_NONE           0x00 /* unused pin                      */
+#define  CGBC_PIN_FNC_EC_NMIn        0x01 /* EC NMI output                   */
+#define  CGBC_PIN_FNC_EC_SMIn        0x02 /* EC SMI output                   */
+#define  CGBC_PIN_FNC_EC_SCIn        0x03 /* EC SCI output                   */
+#define  CGBC_PIN_FNC_SER0_RXD       0x04 /* system serial port 0 RXD        */
+#define  CGBC_PIN_FNC_SER0_TXD       0x05 /* system serial port 0 TXD        */
+#define  CGBC_PIN_FNC_SER0_RTS       0x06 /* system serial port 0 RTS        */
+#define  CGBC_PIN_FNC_SER0_CTS       0x07 /* system serial port 0 CTS        */
+#define  CGBC_PIN_FNC_SER1_RXD       0x08 /* system serial port 1 RXD        */
+#define  CGBC_PIN_FNC_SER1_TXD       0x09 /* system serial port 1 TXD        */
+#define  CGBC_PIN_FNC_SER1_RTS       0x0A /* system serial port 1 RTS        */
+#define  CGBC_PIN_FNC_SER1_CTS       0x0B /* system serial port 1 CTS        */
+#define  CGBC_PIN_FNC_SERA_RXD       0x0C /* auxiliary serial port RXD       */
+#define  CGBC_PIN_FNC_SERA_TXD       0x0D /* auxiliary serial port TXD       */
+#define  CGBC_PIN_FNC_SERA_RTS       0x0E /* auxiliary serial port RTS       */
+#define  CGBC_PIN_FNC_SERA_CTS       0x0F /* auxiliary serial port CTS       */
+#define  CGBC_PIN_FNC_USER_GPIO_0    0x10 /* user GPIO pin 0                 */
+#define  CGBC_PIN_FNC_USER_GPIO_1    0x11 /* user GPIO pin 1                 */
+#define  CGBC_PIN_FNC_USER_GPIO_2    0x12 /* user GPIO pin 2                 */
+#define  CGBC_PIN_FNC_USER_GPIO_3    0x13 /* user GPIO pin 3                 */
+#define  CGBC_PIN_FNC_USER_GPIO_4    0x14 /* user GPIO pin 4                 */
+#define  CGBC_PIN_FNC_USER_GPIO_5    0x15 /* user GPIO pin 5                 */
+#define  CGBC_PIN_FNC_USER_GPIO_6    0x16 /* user GPIO pin 6                 */
+#define  CGBC_PIN_FNC_USER_GPIO_7    0x17 /* user GPIO pin 7                 */
+#define  CGBC_PIN_FNC_USER_GPIO_8    0x18 /* user GPIO pin 8                 */
+#define  CGBC_PIN_FNC_USER_GPIO_9    0x19 /* user GPIO pin 9                 */
+#define  CGBC_PIN_FNC_USER_GPIO_10   0x1A /* user GPIO pin 10                */
+#define  CGBC_PIN_FNC_USER_GPIO_11   0x1B /* user GPIO pin 11                */
+#define  CGBC_PIN_FNC_USER_GPIO_12   0x1C /* user GPIO pin 12                */
+#define  CGBC_PIN_FNC_USER_GPIO_13   0x1D /* user GPIO pin 13                */
+#define  CGBC_PIN_FNC_USER_GPIO_14   0x1E /* user GPIO pin 14                */
+#define  CGBC_PIN_FNC_USER_GPIO_15   0x1F /* user GPIO pin 15                */
+#define  CGBC_PIN_FNC_USER_GPIO_16   0x20 /* user GPIO pin 16                */
+#define  CGBC_PIN_FNC_USER_GPIO_17   0x21 /* user GPIO pin 17                */
+#define  CGBC_PIN_FNC_USER_GPIO_18   0x22 /* user GPIO pin 18                */
+#define  CGBC_PIN_FNC_USER_GPIO_19   0x23 /* user GPIO pin 19                */
+#define  CGBC_PIN_FNC_USER_GPIO_20   0x24 /* user GPIO pin 20                */
+#define  CGBC_PIN_FNC_USER_GPIO_21   0x25 /* user GPIO pin 21                */
+#define  CGBC_PIN_FNC_USER_GPIO_22   0x26 /* user GPIO pin 22                */
+#define  CGBC_PIN_FNC_USER_GPIO_23   0x27 /* user GPIO pin 23                */
+#define  CGBC_PIN_FNC_USER_GPIO_24   0x28 /* user GPIO pin 24                */
+#define  CGBC_PIN_FNC_USER_GPIO_25   0x29 /* user GPIO pin 25                */
+#define  CGBC_PIN_FNC_USER_GPIO_26   0x2A /* user GPIO pin 26                */
+#define  CGBC_PIN_FNC_USER_GPIO_27   0x2B /* user GPIO pin 27                */
+#define  CGBC_PIN_FNC_USER_GPIO_28   0x2C /* user GPIO pin 28                */
+#define  CGBC_PIN_FNC_USER_GPIO_29   0x2D /* user GPIO pin 29                */
+#define  CGBC_PIN_FNC_USER_GPIO_30   0x2E /* user GPIO pin 30                */
+#define  CGBC_PIN_FNC_USER_GPIO_31   0x2F /* user GPIO pin 31                */
+#define  CGBC_PIN_FNC_DDC0_SDA       0x30 /* display data channel 0 data     */
+#define  CGBC_PIN_FNC_DDC0_SCL       0x31 /* display data channel 0 clock    */
+#define  CGBC_PIN_FNC_DDC0_ALERTn    0x32 /* display data channel 0 alert    */
+#define  CGBC_PIN_FNC_I2C0_SDA       0x33 /* primary I2C-bus 0 data          */
+#define  CGBC_PIN_FNC_I2C0_SCL       0x34 /* primary I2C-bus 0 clock         */
+#define  CGBC_PIN_FNC_I2C0_ALERTn    0x35 /* primary I2C-bus 0 alert         */
+#define  CGBC_PIN_FNC_SMB0_SDA       0x36 /* primary SMBus 0 data            */
+#define  CGBC_PIN_FNC_SMB0_SCL       0x37 /* primary SMBus 0 clock           */
+#define  CGBC_PIN_FNC_SMB0_ALERTn    0x38 /* primary SMBus 0 alert           */
+#define  CGBC_PIN_FNC_SMB1_SDA       0x39 /* secondary SMBus 1 data          */
+#define  CGBC_PIN_FNC_SMB1_SCL       0x3A /* secondary SMBus 1 clock         */
+#define  CGBC_PIN_FNC_SMB1_ALERTn    0x3B /* secondary SMBus 1 alert         */
+#define  CGBC_PIN_FNC_SMB2_SDA       0x3C /* auxiliary SMBus 2 data          */
+#define  CGBC_PIN_FNC_SMB2_SCL       0x3D /* auxiliary SMBus 2 clock         */
+#define  CGBC_PIN_FNC_SMB2_ALERTn    0x3E /* auxiliary SMBus 2 alert         */
+#define  CGBC_PIN_FNC_SMB_ISOn       0x3F /* SMBus isolation control         */
+#define  CGBC_PIN_FNC_LIDBTNn        0x40 /* lid button                      */
+#define  CGBC_PIN_FNC_PWRBTNn_INP    0x41 /* power button input              */
+#define  CGBC_PIN_FNC_PWRBTNn_OUT    0x42 /* power button output             */
+#define  CGBC_PIN_FNC_RSTBTNn_INP    0x43 /* reset button input              */
+#define  CGBC_PIN_FNC_RSTBTNn_OUT    0x44 /* reset button output             */
+#define  CGBC_PIN_FNC_SLPBTNn        0x45 /* sleep button                    */
+#define  CGBC_PIN_FNC_FP_LED_0       0x46 /* front panel LED 0               */
+#define  CGBC_PIN_FNC_FP_LED_1       0x47 /* front panel LED 1               */
+#define  CGBC_PIN_FNC_IINA_INP       0x48 /* analog current sensor input     */
+#define  CGBC_PIN_FNC_HI_TEMPA_INP   0x49 /* analog high temp. sensor input  */
+#define  CGBC_PIN_FNC_LO_TEMPA_INP   0x4A /* analog low temp. sensor input   */
+#define  CGBC_PIN_FNC_VINA_INP       0x4B /* analog runtime voltage input    */
+#define  CGBC_PIN_FNC_VSBA_INP       0x4C /* analog standby voltage input    */
+#define  CGBC_PIN_FNC_GPA_INP        0x4D /* general purpose analog input    */
+#define  CGBC_PIN_FNC_WDG_EVENT      0x4E /* watchdog event output pin       */
+#define  CGBC_PIN_FNC_WDG_STROBEn    0x4F /* watchdog strobe input pin       */
+#define  CGBC_PIN_FNC_LFP0_BLT_INP   0x50 /* LFP0 backlight ctrl input pin   */
+#define  CGBC_PIN_FNC_LFP0_BLT_OUT   0x51 /* LFP0 backlight ctrl output pin  */
+#define  CGBC_PIN_FNC_LFP0_PWM_OUT   0x52 /* LFP0 backlight PWM output pin   */
+#define  CGBC_PIN_FNC_LFP0_VDD_INP   0x53 /* LFP0 power ctrl input pin       */
+#define  CGBC_PIN_FNC_LFP0_VDD_OUT   0x54 /* LFP0 power ctrl output pin      */
+#define  CGBC_PIN_FNC_LFP1_BLT_INP   0x55 /* LFP1 backlight ctrl input pin   */
+#define  CGBC_PIN_FNC_LFP1_BLT_OUT   0x56 /* LFP1 backlight ctrl output pin  */
+#define  CGBC_PIN_FNC_LFP1_PWM_OUT   0x57 /* LFP1 backlight PWM output pin   */
+#define  CGBC_PIN_FNC_LFP1_VDD_INP   0x58 /* LFP1 power ctrl input pin       */
+#define  CGBC_PIN_FNC_LFP1_VDD_OUT   0x59 /* LFP1 power ctrl output pin      */
+#define  CGBC_PIN_FNC_SYS_CFG0       0x5A /* system configuration pin 0      */
+#define  CGBC_PIN_FNC_SYS_CFG1       0x5B /* system configuration pin 1      */
+#define  CGBC_PIN_FNC_SYS_CFG2       0x5C /* system configuration pin 2      */
+#define  CGBC_PIN_FNC_SYS_CFG3       0x5D /* system configuration pin 3      */
+#define  CGBC_PIN_FNC_SYS_CFG4       0x5E /* system configuration pin 4      */
+#define  CGBC_PIN_FNC_SYS_CFG5       0x5F /* system configuration pin 5      */
+#define  CGBC_PIN_FNC_CPU_FAN_TACH   0x60 /* CPU fan tachometer input        */
+#define  CGBC_PIN_FNC_CPU_FAN_PWM    0x61 /* CPU fan PWM output              */
+#define  CGBC_PIN_FNC_SYS_FAN_TACH   0x62 /* system fan tachometer input     */
+#define  CGBC_PIN_FNC_SYS_FAN_PWM    0x63 /* system fan PWM output           */
+#define  CGBC_PIN_FNC_PECI_DAT       0x64 /* bidirectional PECI pin          */
+#define  CGBC_PIN_FNC_PECI_RXD       0x65 /* PECI input pin                  */
+#define  CGBC_PIN_FNC_PECI_TXD       0x66 /* PECI output pin                 */
+#define  CGBC_PIN_FNC_VREF_VTT       0x67 /* CPU VTT voltage reference pin   */
+#define  CGBC_PIN_FNC_CHARGINGn      0x68 /* battery charging                */
+#define  CGBC_PIN_FNC_CHARGER_PRSNTn 0x69 /* charger present                 */
+#define  CGBC_PIN_FNC_BATLOWn        0x6A /* BATLOW# pin                     */
+#define  CGBC_PIN_FNC_ACPRESENT      0x6B /* ACPRESENT pin                   */
+#define  CGBC_PIN_FNC_SLP_SUSn       0x6C /* SLP_SUS# pin                    */
+#define  CGBC_PIN_FNC_SUS_PGD        0x6D /* SUS_PGD pin                     */
+#define  CGBC_PIN_FNC_SUSWARNn       0x6E /* SUSWARN# pin                    */
+#define  CGBC_PIN_FNC_SUSACKn        0x6F /* SUSACK# pin                     */
+#define  CGBC_PIN_FNC_RSMRSTn        0x70 /* RSMRST# pin                     */
+#define  CGBC_PIN_FNC_SLP_S5n        0x71 /* SLP_S3# pin                     */
+#define  CGBC_PIN_FNC_SLP_S4n        0x72 /* SLP_S4# pin                     */
+#define  CGBC_PIN_FNC_SLP_S3n        0x73 /* SLP_S5# pin                     */
+#define  CGBC_PIN_FNC_SYS_PGD_INP    0x74 /* SYS_PGD_INP pin                 */
+#define  CGBC_PIN_FNC_SYS_PGD_OUT    0x75 /* SYS_PGD_OUT pin                 */
+#define  CGBC_PIN_FNC_PLTRSTn        0x76 /* PLTRST# pin                     */
+                                                                      //MOD048v
+#define  CGBC_PIN_FNC_V5A_CTL        0x77 /* V5A_CTL pin                     */
+#define  CGBC_PIN_FNC_HOST_RST_ACK   0x78 /* HOST_RST_ACK pin                */
+                                                                      //MOD052v
+#define  CGBC_PIN_FNC_I2C1_SDA       0x79 /* secondary I2C-bus 1 data        */
+#define  CGBC_PIN_FNC_I2C1_SCL       0x7A /* secondary I2C-bus 1 clock       */
+#define  CGBC_PIN_FNC_I2C1_ALERTn    0x7B /* secondary I2C-bus 1 alert       */
+#define  CGBC_PIN_FNC_IPMB_SDA       0x7C /* int. platform mgmt bus data     */
+#define  CGBC_PIN_FNC_IPMB_SCL       0x7D /* int. platform mgmt bus clock    */
+#define  CGBC_PIN_FNC_IPMB_ALERTn    0x7E /* int. platform mgmt bus alert    */
+#define  CGBC_PIN_FNC_UPDB_SDA       0x7F /* USB PD controller bus data      */
+#define  CGBC_PIN_FNC_UPDB_SCL       0x80 /* USB PD controller bus clock     */
+#define  CGBC_PIN_FNC_UPDB_ALERTn    0x81 /* USB PD controller bus alert     */
+#define  CGBC_PIN_FNC_PMBUS_MUX      0x82 /* PMBUS multiplexer control pin   */
+#define  CGBC_PIN_FNC_TESTn          0x83 /* system test mode pin            */
+#define  CGBC_PIN_FNC_VIN_PWROK      0x84 /* VIN power good pin              */
+#define  CGBC_PIN_FNC_RAPID_SHUTDOWN 0x85 /* rapid shutdown pin              */
+#define  CGBC_PIN_FNC_UART_MUX_PCHn  0x86 /* cBC/PCH UART mux control pin    */
+#define  CGBC_PIN_FNC_THRMn          0x87 /* THRM# pin                       */
+#define  CGBC_PIN_FNC_PROCHOTn       0x88 /* PROCHOT# pin                    */
+                                                                      //MOD060v
+#define  CGBC_PIN_FNC_SPD_SMB_MUX    0x89 /* SPD_SMB_MUX pin                 */
+                                                                      //MOD063v
+#define  CGBC_PIN_FNC_GSPI_INTn      0x8A /* GSPI client interrupt pin       */
+#define  CGBC_PIN_FNC_GSPI_DSEL      0x8B /* GSPI device selection pin       */
+                                                                      //MOD068v
+#define  CGBC_PIN_FNC_SUSPWRDNACK    0x8C /* SUSPWRDNACK pin                 */
+#define  CGBC_PIN_FNC_SLP_Mn         0x8D /* SLP_M# pin                      */
+#define  CGBC_PIN_FNC_SLP_LANn       0x8E /* SLP_LAN# pin                    */
+#define  CGBC_PIN_FNC_SLP_WLANn      0x8F /* SLP_WLAN# pin                   */
+                                                                      //MOD068^
+                                                                      //MOD069v
+#define  CGBC_PIN_FNC_BRD_PWR_EN     0x90 /* Board power enable pin          */
+#define  CGBC_PIN_FNC_MAX            CGBC_PIN_FNC_BRD_PWR_EN
+                                          //MOD048 MOD052 MOD060 MOD063 MOD069^
+/* reserved logical pin functions */
+#define  CGBC_PIN_FNC_RES0           0xE0 /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES1           0xE1 /* reserved logical pin function 1 */
+#define  CGBC_PIN_FNC_RES2           0xE2 /* reserved logical pin function 2 */
+#define  CGBC_PIN_FNC_RES3           0xE3 /* reserved logical pin function 3 */
+#define  CGBC_PIN_FNC_RES4           0xE4 /* reserved logical pin function 4 */
+#define  CGBC_PIN_FNC_RES5           0xE5 /* reserved logical pin function 5 */
+#define  CGBC_PIN_FNC_RES6           0xE6 /* reserved logical pin function 6 */
+#define  CGBC_PIN_FNC_RES7           0xE7 /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES8           0xE8 /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES9           0xE9 /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES10          0xEA /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES11          0xEB /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES12          0xEC /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES13          0xED /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES14          0xEE /* reserved logical pin function 0 */
+#define  CGBC_PIN_FNC_RES15          0xEF /* reserved logical pin function 0 */
+
+/* logical pin function groups */
+#define  CGBC_PIN_FNC_LPC            0xF0 /* LPC pin function group          */
+#define  CGBC_PIN_FNC_ESPI           0xF1 /* eSPI pin function group         */
+#define  CGBC_PIN_FNC_GPSPI_0        0xF2 /* GPSPI 0 function group          */
+#define  CGBC_PIN_FNC_QSPI_PVT       0xF3 /* private QSPI pin function group */
+#define  CGBC_PIN_FNC_QSPI_SHD       0xF4 /* shared QSPI pin function group  */
+
+/* virtual pin states */
+#define  CGBC_PIN_VW_LOW             0xFA /* eSPI virtual wire in low state  */
+#define  CGBC_PIN_VW_HIGH            0xFB /* eSPI virtual wire in high state */
+#define  CGBC_PIN_VP_LOW             0xFC /* virtual pin in low state        */
+#define  CGBC_PIN_VP_HIGH            0xFD /* virtual pin in high state       */
+#define  CGBC_PIN_NONE               0xFF /* unavailable pin                 */
+                                                                      //MOD046^
+/* combined pin features */
+                                                                      //MOD054v
+#define CGBC_PIN_PAD_MSK        (CGBC_PIN_TYP_MSK|CGBC_PIN_ODV_MSK|CGBC_PIN_LOW_MSK|CGBC_PIN_PUP_MSK|CGBC_PIN_PDN_MSK|CGBC_PIN_DIR_MSK|CGBC_PIN_MOD_MSK|CGBC_PIN_LVL_MSK)
+#define CGBC_PIN_TRI            (CGBC_PIN_TYP_OFF|        0       |        0       |        0       |        0       |        0       |        0       |        0       )
+#define CGBC_PIN_ANA_INP        (CGBC_PIN_TYP_ANA|        0       |        0       |        0       |        0       |        0       |        0       |        0       )
+#define CGBC_PIN_DIG_INP_FLOAT  (CGBC_PIN_TYP_DIG|        0       |        0       |CGBC_PIN_PUP_DIS|CGBC_PIN_PDN_DIS|CGBC_PIN_DIR_INP|        0       |        0       )
+#define CGBC_PIN_DIG_INP_PD     (CGBC_PIN_TYP_DIG|        0       |        0       |CGBC_PIN_PUP_DIS|CGBC_PIN_PDN_ENA|CGBC_PIN_DIR_INP|        0       |        0       )
+#define CGBC_PIN_DIG_INP_PU     (CGBC_PIN_TYP_DIG|        0       |        0       |CGBC_PIN_PUP_ENA|CGBC_PIN_PDN_DIS|CGBC_PIN_DIR_INP|        0       |        0       )
+#define CGBC_PIN_DIG_OUT_OD_HI  (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_FIX|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_OD_LO  (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_FIX|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_LO )
+#define CGBC_PIN_DIG_OUT_ODT_HI (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_TOL|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_ODT_LO (CGBC_PIN_TYP_DIG|CGBC_PIN_ODV_TOL|        0       |        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_OD |CGBC_PIN_LVL_LO )
+#define CGBC_PIN_DIG_OUT_PP_HI  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_PP_LO  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_ENA|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_LO )
+#define CGBC_PIN_DIG_OUT_LZ_HI  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_DIS|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_HI )
+#define CGBC_PIN_DIG_OUT_LZ_LO  (CGBC_PIN_TYP_DIG|        0       |CGBC_PIN_LOW_DIS|        0       |        0       |CGBC_PIN_DIR_OUT|CGBC_PIN_MOD_PP |CGBC_PIN_LVL_LO )
+                                                                      //MOD054^
+                                                                      //MOD063v
+/* ----------------------------------------
+ * CGBC_CMD_GSPI_CFG command definitions
+ * ------------------------------------- */
+
+/* command package structure */
+typedef struct
+CGBC_CMD_GSPI_CFG_IN_STRUCT
+{
+  uint8_t   ui8Cmd;         /* CGBC_CMD_GSPI_CFG                             */
+  uint8_t   ui8Cfg;         /* GSPI configuration byte. Including byte order,
+                             * operation mode, and duplex                    */
+  uint8_t   ui8SerIrqNum;   /* SERIRQ number which shall be allocated for the
+                             * GSPI transfer finished or GSPI client interrupt
+                             * SERIRQ to the host.                           */
+  uint32_t ui32Freq;        /* GSPI clock frequency to be configured. Any
+                             * frequency in Hz can be used. The configuration
+                             * routine automatically configures the next lowest
+                             * frequency which is supported by the controller*/
+  uint32_t ui32GspiSramBar;
+} CGBC_CMD_GSPI_CFG_IN, *P_CGBC_CMD_GSPI_CFG_IN;
+
+#define CGBC_GSPI_CFG_DUPLEX_POS                       0
+#define CGBC_GSPI_CFG_DUPLEX_MASK                   0x03
+#define CGBC_GSPI_CFG_DUPLEX_FULL                   0x00
+#define CGBC_GSPI_CFG_DUPLEX_HALF                   0x01
+#define CGBC_GSPI_CFG_DUPLEX_DUAL                   0x02
+
+#define CGBC_GSPI_GFG_MODE_POS                         2
+#define CGBC_GSPI_GFG_MODE_MASK                     0x0C
+#define CGBC_GSPI_CFG_MODE_00                       0x00
+#define CGBC_GSPI_CFG_MODE_01                       0x04
+#define CGBC_GSPI_CFG_MODE_10                       0x08
+#define CGBC_GSPI_CFG_MODE_11                       0x0C
+
+#define CGBC_GSPI_CFG_ENDIAN_POS                       4
+#define CGBC_GSPI_CFG_ENDIAN_MASK                   0x10
+#define CGBC_GSPI_CFG_ENDIAN_LIT                    0x00
+#define CGBC_GSPI_CFG_ENDIAN_BIG                    0x10
+
+#define CGBC_GSPI_CFG_UPD_POS                          5
+#define CGBC_GSPI_CFG_UPD_MASK                      0x20
+
+/* result package structure */
+typedef struct
+CGBC_CMD_GSPI_CFG_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;    /* CGBC status byte                              */
+  uint8_t   ui8Cfg;         /* Actually configured byte order, operation mode
+                             * and duplex in the GSPI controller             */
+  uint8_t   ui8SerIrqNum;   /* SERIRQ number allocated for the GSPI support  */
+  uint32_t ui32Freq;        /* Actually configured GSPI frequency in the GSPI
+                             * controller. It can deviate from the value in
+                             * the command because the controller only supports
+                             * certain frequencies. The configuration routine
+                             * will configure the next lowest frequency to the
+                             * desired one and returns iter_swap             */
+  uint32_t ui32GspiSramBar;
+} CGBC_CMD_GSPI_CFG_OUT, *P_CGBC_CMD_GSPI_CFG_OUT;
+
+#define CGBC_GSPI_CFG_MASK                          0x3F
+
+#define CGBC_GSPI_CLK_FREQ_MASK                     0x0F
+#define CGBC_GSPI_CLK_FREQ_15_9kHz                  0x00
+#define CGBC_GSPI_CLK_FREQ_333kHz                   0x01
+#define CGBC_GSPI_CLK_FREQ_500kHz                   0x02
+#define CGBC_GSPI_CLK_FREQ_1MHz                     0x03
+#define CGBC_GSPI_CLK_FREQ_381kHz                   0x04
+#define CGBC_GSPI_CLK_FREQ_6MHz                     0x05
+#define CGBC_GSPI_CLK_FREQ_12MHz                    0x06
+#define CGBC_GSPI_CLK_FREQ_24MHz                    0x07
+#define CGBC_GSPI_CLK_FREQ_48MHz                    0x08
+
+#define CGBC_GSPI_BYTE_ORDER_MASK                   0x10
+#define CGBC_GSPI_BYTE_ORDER_LITTLE_ENDIAN          0x00
+#define CGBC_GSPI_BYTE_ORDER_BIG_ENDIAN             0x10
+
+#define CGBC_GSPI_MODE_MASK                         0x20
+#define CGBC_GSPI_MODE_00                           0x00
+#define CGBC_GSPI_MODE_11                           0x20
+                                                                      //MOD063^
+/* -----------------------------------------
+ * CGBC_CMD_DIAG_MODE command definitions
+ * -------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_DIAG_MODE_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                /* CGBC_CMD_DIAG_MODE                     */
+  uint8_t   ui8DiagMode;           /* desired diagnostic console output mode */
+  uint16_t ui16Res;                /* reserved / must be 0                   */
+  uint32_t ui32FeatId;             /* BC firmware feature ID                 */
+} CGBC_CMD_DIAG_MODE_IN, *P_CGBC_CMD_DIAG_MODE_IN;
+
+/* diagnostic console output mode settings */
+#define CGBC_DIAG_MODE_OFF     0
+#define CGBC_DIAG_MODE_SPECIAL 1
+#define CGBC_DIAG_MODE_NORMAL  2
+#define CGBC_DIAG_MODE_VERBOSE 3
+                                                                      //MOD044^
+                                                                      //MOD046 
+                                                                      //MOD045v
+/*--------------------------------------
+ * CGBC_CMD_ADV_USER_LOCK return status
+ *--------------------------------------
+ */
+
+/* This is done to reuse the definition of the standard user lock if it is
+ * de-featured and completely replaced by the advanced user lock.
+ */
+#ifndef CGBC_USER_LOCK_KEY_SIZE
+#define CGBC_USER_LOCK_KEY_SIZE 6
+#endif /* CGBC_USER_LOCK_KEY_SIZE */
+
+#ifndef __ASSEMBLER__
+
+typedef struct CGBC_CMD_ADV_USER_LOCK_IN_STRUCT
+                  {
+                   unsigned char cmd;
+                   unsigned char subCmd;        /* Can configure if read, write
+                                                 * or both shall be locked,
+                                                 * unlocked or tested
+                                                 */
+                   unsigned char key[CGBC_USER_LOCK_KEY_SIZE];
+                  } CGBC_CMD_ADV_USER_LOCK_IN, *P_CGBC_CMD_ADV_USER_LOCK_IN;
+
+#endif //!__ASSEMBLER__
+
+#ifndef  CGBC_LOCKED
+#define  CGBC_LOCKED                0x01        // user lock write is closed
+#endif /* !CGBC_LOCKED */
+
+#ifndef  CGBC_TAMPERED
+#define  CGBC_TAMPERED              0x02        // someone tampered with lock
+#endif /* !CGBC_TAMPERED */
+
+#define CGBC_USER_WRITE_LOCKED      CGBC_LOCKED // redefined for better readability
+#define CGBC_USER_READ_LOCKED       0x04        // user lock read is closed
+
+/* Bit mask to store only read and write lock bits in EEPROM but no tampered bit */
+#define USER_LOCK_STATUS_EEP_MASK   0x05
+
+
+                                                                      //MOD046v
+/* ------------------------------------------------------------
+ * CGBC_CMD_BAT_DYN and CGBC_CMD_BAT_STA command definitions
+ * --------------------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_BAT_IN_STRUCT
+{
+    uint8_t     ui8Cmd;                                 /* cmd               */
+    uint8_t     ui8Battery;                             /* battery to select */
+} CGBC_CMD_BAT_IN, *P_CGBC_CMD_BAT_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_BAT_DYN_DATA_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                         /* CGBC status byte         */
+   int16_t      i16Current;                      /* Current                  */
+  uint16_t     ui16Voltage;                      /* Voltage                  */
+  uint16_t     ui16RemainingCapacity;            /* Remaining Capacity       */
+  uint16_t     ui16FullChargeCapacity;           /* Full Charge Capacity     */
+  uint16_t     ui16Temperature;
+  uint16_t     ui16RelStateOfCharge;
+  uint16_t     ui16AbsStateOfCharge;
+} CGBC_CMD_BAT_DYN_DATA_OUT, *P_CGBC_CMD_BAT_DYN_DATA_OUT;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_BAT_STA_DATA_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                /* CGBC status byte                  */
+  uint16_t     ui16StaticValue;         /* Design Cap./Voltage/serialn0      */
+  uint16_t     ui16StaticValue2;        /* second value                      */
+  char         caStringName[32];        /* Chemistry/Manufacturer/DeviceName */
+} CGBC_CMD_BAT_STA_DATA_OUT, *P_CGBC_CMD_BAT_STA_DATA_OUT;
+
+
+
+/* ---------------------------------------
+ * CGBC_CMD_WDOG_RD command definitions
+ * ------------------------------------ */
+
+typedef struct
+CGBC_CMD_WDOG_RD_IN_STRUCT
+{
+  uint8_t ui8Cmd;                   /* CGBC_CMD_WDOG_RD                      */
+  uint8_t ui8WdgType;               /* type of watchdog which should be read */
+} CGBC_CMD_WDOG_RD_IN, *P_CGBC_CMD_WDOG_RD_IN;
+
+#define CGBC_WDOG                   0x01
+#define CGBC_WDOG_POST              0x02
+#define CGBC_WDOG_EARLY             0x03
+
+
+
+/* --------------------------------------------
+ * CGBC_CMD_GPIO_IRQ_TBL command definitions
+ * ----------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_GPIO_IRQ_TBL_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                        /* CGBC_CMD_GPIO_IRQ_TBL          */
+  uint8_t   aui8Tbl[32];                   /* user GPIO IRQ table (32 bytes) */
+} CGBC_CMD_GPIO_IRQ_TBL_IN, *P_CGBC_CMD_GPIO_IRQ_TBL_IN;
+
+/* special user GPIO IRQ table entries */
+#define CGBC_GPIO_IRQ_NONE 0x00
+#define CGBC_GPIO_IRQ_READ 0xFF
+
+/* result package structure */
+typedef struct
+CGBC_CMD_GPIO_IRQ_TBL_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                   /* CGBC status byte               */
+  uint8_t   aui8Tbl[32];                   /* user GPIO IRQ table (32 bytes) */
+} CGBC_CMD_GPIO_IRQ_TBL_OUT, *P_CGBC_CMD_GPIO_IRQ_TBL_OUT;
+                                                                      //MOD046^
+
+                                                                      //MOD061v
+/* ------------------------------------
+ * CGBC_CMD_AVR_SPM_EXT sub-commands
+ * --------------------------------- */
+
+#define CGBC_CMD_AVR_SPM_FLS_ADDR 0x00
+#define CGBC_CMD_AVR_SPM_FLS_STAT 0x01
+#define CGBC_CMD_AVR_SPM_FLS_RD32 0x02
+#define CGBC_CMD_AVR_SPM_FLS_WR32 0x03
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_ADDR command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_ADDR_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                             /* CGBC_CMD_AVR_SPM_EXT      */
+  uint8_t   ui8ExtCmd;                          /* CGBC_CMD_AVR_SPM_FLS_ADDR */
+  uint32_t ui32FlsAddr;                         /* target flash page address */
+} CGBC_CMD_AVR_SPM_FLS_ADDR_IN, *P_CGBC_CMD_AVR_SPM_FLS_ADDR_IN;
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_STAT command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_STAT_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                             /* CGBC_CMD_AVR_SPM_EXT      */
+  uint8_t   ui8ExtCmd;                          /* CGBC_CMD_AVR_SPM_FLS_STAT */
+} CGBC_CMD_AVR_SPM_FLS_STAT_IN, *P_CGBC_CMD_AVR_SPM_FLS_STAT_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_STAT_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                      /* CGBC status byte            */
+  uint8_t     ui8FlsCtlrSts;                  /* cBC flash controller status */
+  uint32_t   ui32FlsPageSiz;                  /* flash page size             */
+} CGBC_CMD_AVR_SPM_FLS_STAT_OUT, *P_CGBC_CMD_AVR_SPM_FLS_STAT_OUT;
+
+/* flash controller status definitions */
+#define CGBC_AVR_SPM_FLS_IDL 0x00      /* cBC flash controller is idle.      */
+#define CGBC_AVR_SPM_FLS_BSY 0x01      /* cBC flash controller is busy.      */
+#define CGBC_AVR_SPM_FLS_ERR 0x02      /* cBC flash controller has an error. */
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_RD32 command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_RD32_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                             /* CGBC_CMD_AVR_SPM_EXT      */
+  uint8_t   ui8ExtCmd;                          /* CGBC_CMD_AVR_SPM_FLS_RD32 */
+} CGBC_CMD_AVR_SPM_FLS_RD32_IN, *P_CGBC_CMD_AVR_SPM_FLS_RD32_IN;
+
+/* result package structure */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_RD32_OUT_STRUCT
+{
+  CGBC_STATUS stsCmdSts;                                 /* CGBC status byte */
+  uint8_t    aui8RdDat[32];                              /* read data        */
+} CGBC_CMD_AVR_SPM_FLS_RD32_OUT, *P_CGBC_CMD_AVR_SPM_FLS_RD32_OUT;
+
+/* ------------------------------------------------
+ * CGBC_CMD_AVR_SPM_FLS_WR32 command definitions
+ * --------------------------------------------- */
+
+/* command package structure  */
+typedef struct
+CGBC_CMD_AVR_SPM_FLS_WR32_IN_STRUCT
+{
+  uint8_t   ui8Cmd;                           /* CGBC_CMD_AVR_SPM_EXT        */
+  uint8_t   ui8ExtCmd;                        /* CGBC_CMD_AVR_SPM_FLS_WR32 */
+  uint8_t  aui8WrDat[32];                     /* write data                  */
+} CGBC_CMD_AVR_SPM_FLS_WR32_IN, *P_CGBC_CMD_AVR_SPM_FLS_WR32_IN;
+                                                                      //MOD061^
+																	  
+
 /*-------------------
  * SYNC return codes
  *-------------------
@@ -2016,7 +3368,7 @@ typedef struct CGBC_CMD_SYNC_OUT_STRUCT
    } CGBC_CMD_SYNC_OUT, *P_CGBC_CMD_SYNC_OUT;
 
 #endif //!__ASSEMBLER__
-
+                                                                      //MOD045^
 
 
 /*--------------------
@@ -2030,95 +3382,133 @@ typedef struct CGBC_CMD_SYNC_OUT_STRUCT
 
 typedef union CGBC_CMD_STRUCT
                {
-                unsigned char             cmd;
-                unsigned char             sts;
-                unsigned char             cmdPkt[MAX_HST_CMD_SIZ];
-                unsigned char             resPkt[CGBC_DAT_CNT_MSK+2];
-                CGBC_CMD_FW_REV_OUT       revOut;
-                CGBC_CMD_AUX_INIT_IN      auxInitIn;
-                CGBC_WD_PARMS             wdParms;
-                CGBC_CMD_SYS_FLAGS_1_IN   sysFlags1In;               //MOD021
-                CGBC_CMD_SYS_FLAGS_1_OUT  sysFlags1Out;              //MOD021
-                CGBC_CMD_INFO_1_OUT       info1Out;
-                CGBC_CMD_LFP_CONTROL_IN   lfpControlIn;              //MOD040
-                CGBC_CMD_VID_CONTROL_IN   vidControlIn;              //MOD021
-                CGBC_CMD_LFP_CONTROL_OUT  lfpControlOut;             //MOD040
-                CGBC_CMD_VID_CONTROL_OUT  vidControlOut;             //MOD021
-                CGBC_CMD_TCNT_IN          tcntIn;                    //MOD021
-                CGBC_CMD_TCNT_OUT         tcntOut;                   //MOD021
-                CGBC_CMD_BOOT_TIME_OUT    btimOut;
-                CGBC_CMD_DUMP_IN          dumpParms;
-                CGBC_CMD_RESET_INFO_OUT   resetOut;                  //MOD021
-                CGBC_CMD_POST_CODE_IN     postCodeIn;                //MOD040
-                CGBC_CMD_XINT_CONTROL_IN  xintControlIn;             //MOD021
-                CGBC_CMD_XINT_CONTROL_OUT xintControlOut;            //MOD021
-                CGBC_CMD_USER_LOCK_IN     userLockIn;                //MOD021
-                CGBC_CMD_CPU_TEMP_OUT     cpuTempOut;                //MOD021
-                CGBC_CMD_SBSM_DATA_OUT    sbsmDataOut;               //MOD021
-                CGBC_CMD_I2C_START_IN     i2cStartIn;
-                CGBC_CMD_I2C_DATA_OUT     i2cDataOut;
-                CGBC_CMD_I2C_SPEED_IN     i2cSpeedIn;                //MOD021
-                CGBC_CMD_I2C_SPEED_OUT    i2cSpeedOut;               //MOD021
-                CGBC_CMD_BTN_CONTROL_IN   btnControlIn;              //MOD017
-                CGBC_CMD_BTN_CONTROL_OUT  btnControlOut;             //MOD017
-                CGBC_CMD_FAN_CONTROL_IN   fanControlIn;              //MOD020
-                CGBC_CMD_FAN_CONTROL_OUT  fanControlOut;             //MOD020
-                CGBC_CMD_RTC_IN           rtcIn;                     //MOD022
-                CGBC_CMD_RTC_OUT          rtcOut;                    //MOD022
-                CGBC_CMD_GPIO_IN          gpioIn;                    //MOD021
-                CGBC_CMD_GPIO_OUT         gpioOut;                   //MOD021
-                CGBC_CMD_PECI_IN          peciIn;                    //MOD023
-                CGBC_CMD_PECI_OUT         peciOut;                   //MOD023
-                CGBC_CMD_I2C_GATE_IN      i2cGateIn;                 //MOD024
-                CGBC_CMD_I2C_GATE_OUT     i2cGateOut;                //MOD024
-                CGBC_CMD_CFG_PINS_IN      cfgPinsIn;                 //MOD025
-                CGBC_CMD_CFG_PINS_OUT     cfgPinsOut;                //MOD025
-                CGBC_CMD_AVR_SPM_IN       avrSpmIn;                  //MOD038
-                CGBC_CMD_AVR_SPM_OUT      avrSpmOut;                 //MOD038
-                CGBC_CMD_COMX_CFG_IN      comxCfgIn;                 //MOD031
-                CGBC_CMD_COMX_CFG_OUT     comxCfgOut;                //MOD031
-                CGBC_CMD_BLT_PWM_IN       bltPwmIn;                  //MOD036
-                CGBC_CMD_BLT_PWM_OUT      bltPwmOut;                 //MOD036
-                CGBC_CMD_DEVICE_ID_OUT    deviceIdOut;               //MOD038
-                CGBC_CMD_HWM_SENSOR_IN    hwmSensorIn;               //MOD038
-                CGBC_CMD_HWM_SENSOR_OUT   hwmSensorOut;              //MOD038
-                CGBC_CMD_POST_CFG_IN      postCfgIn;                 //MOD040
-                CGBC_CMD_POST_CFG_OUT     postCfgOut;                //MOD040
-                CGBC_CMD_LFP_DELAY_IN     bltDelayIn;                //MOD040
-                CGBC_CMD_LFP_DELAY_OUT    bltDelayOut;               //MOD040
-                CGBC_CMD_HWM_CFG_IN       hwmCfgIn;                  //MOD040
-                CGBC_CMD_HWM_CFG_OUT      hwmCfgOut;                 //MOD040
-                CGBC_CMD_DIAG_CFG_IN      diagCfgIn;                 //MOD041
-                CGBC_CMD_DIAG_CFG_OUT     diagCfgOut;                //MOD041
-                CGBC_CMD_SYNC_OUT         sync;
+                unsigned char              cmd;
+                unsigned char              sts;
+                unsigned char              cmdPkt[MAX_HST_CMD_SIZ];
+                unsigned char              resPkt[CGBC_DAT_CNT_MSK+2];
+                CGBC_CMD_FW_REV_OUT        revOut;
+                CGBC_CMD_AUX_INIT_IN       auxInitIn;
+                CGBC_WD_PARMS              wdParms;
+                CGBC_CMD_SYS_FLAGS_1_IN    sysFlags1In;              //MOD021
+                CGBC_CMD_SYS_FLAGS_1_OUT   sysFlags1Out;             //MOD021
+                CGBC_CMD_INFO_1_OUT        info1Out;
+                CGBC_CMD_LFP_CONTROL_IN    lfpControlIn;             //MOD040
+                CGBC_CMD_VID_CONTROL_IN    vidControlIn;             //MOD021
+                CGBC_CMD_LFP_CONTROL_OUT   lfpControlOut;            //MOD040
+                CGBC_CMD_VID_CONTROL_OUT   vidControlOut;            //MOD021
+                CGBC_CMD_TCNT_IN           tcntIn;                   //MOD021
+                CGBC_CMD_TCNT_OUT          tcntOut;                  //MOD021
+                CGBC_CMD_BOOT_TIME_OUT     btimOut;
+                CGBC_CMD_DUMP_IN           dumpParms;
+                CGBC_CMD_RESET_INFO_OUT    resetOut;                 //MOD021
+                CGBC_CMD_POST_CODE_IN      postCodeIn;               //MOD040
+                CGBC_CMD_XINT_CONTROL_IN   xintControlIn;            //MOD021
+                CGBC_CMD_XINT_CONTROL_OUT  xintControlOut;           //MOD021
+                CGBC_CMD_USER_LOCK_IN      userLockIn;               //MOD021
+                CGBC_CMD_CPU_TEMP_OUT      cpuTempOut;               //MOD021
+                CGBC_CMD_SBSM_DATA_OUT     sbsmDataOut;              //MOD021
+                CGBC_CMD_I2C_START_IN      i2cStartIn;
+                CGBC_CMD_I2C_DATA_OUT      i2cDataOut;
+                CGBC_CMD_I2C_SPEED_IN      i2cSpeedIn;               //MOD021
+                CGBC_CMD_I2C_SPEED_OUT     i2cSpeedOut;              //MOD021
+                CGBC_CMD_BTN_CONTROL_IN    btnControlIn;             //MOD017
+                CGBC_CMD_BTN_CONTROL_OUT   btnControlOut;            //MOD017
+                CGBC_CMD_FAN_CONTROL_IN    fanControlIn;             //MOD020
+                CGBC_CMD_FAN_CONTROL_OUT   fanControlOut;            //MOD020
+                CGBC_CMD_RTC_IN            rtcIn;                    //MOD022
+                CGBC_CMD_RTC_OUT           rtcOut;                   //MOD022
+                CGBC_CMD_GPIO_IN           gpioIn;                   //MOD021
+                CGBC_CMD_GPIO_OUT          gpioOut;                  //MOD021
+                CGBC_CMD_PECI_IN           peciIn;                   //MOD023
+                CGBC_CMD_PECI_OUT          peciOut;                  //MOD023
+                CGBC_CMD_I2C_GATE_IN       i2cGateIn;                //MOD024
+                CGBC_CMD_I2C_GATE_OUT      i2cGateOut;               //MOD024
+                CGBC_CMD_CFG_PINS_IN       cfgPinsIn;                //MOD025
+                CGBC_CMD_CFG_PINS_OUT      cfgPinsOut;               //MOD025
+                CGBC_CMD_AVR_SPM_IN        avrSpmIn;                 //MOD038
+                CGBC_CMD_AVR_SPM_OUT       avrSpmOut;                //MOD038
+                CGBC_CMD_COMX_CFG_IN       comxCfgIn;                //MOD031
+                CGBC_CMD_COMX_CFG_OUT      comxCfgOut;               //MOD031
+                CGBC_CMD_BLT_PWM_IN        bltPwmIn;                 //MOD036
+                CGBC_CMD_BLT_PWM_OUT       bltPwmOut;                //MOD036
+                CGBC_CMD_DEVICE_ID_OUT     deviceIdOut;              //MOD038
+                CGBC_CMD_HWM_SENSOR_IN     hwmSensorIn;              //MOD038
+                CGBC_CMD_HWM_SENSOR_OUT    hwmSensorOut;             //MOD038
+                CGBC_CMD_POST_CFG_IN       postCfgIn;                //MOD040
+                CGBC_CMD_POST_CFG_OUT      postCfgOut;               //MOD040
+                CGBC_CMD_LFP_DELAY_IN      bltDelayIn;               //MOD040
+                CGBC_CMD_LFP_DELAY_OUT     bltDelayOut;              //MOD040
+                CGBC_CMD_HWM_CFG_IN        hwmCfgIn;                 //MOD040
+                CGBC_CMD_HWM_CFG_OUT       hwmCfgOut;                //MOD040
+                CGBC_CMD_DIAG_CFG_IN       diagCfgIn;                //MOD041
+                CGBC_CMD_DIAG_CFG_OUT      diagCfgOut;               //MOD041
+                CGBC_CMD_LOG_CFG_IN        xLogCfgIn;                //MOD044
+                CGBC_CMD_LOG_CFG_OUT       xLogCfgOut;               //MOD044
+                CGBC_CMD_LOG_READ_IN       xLogReadIn;               //MOD044
+                CGBC_CMD_LOG_READ_OUT      xLogReadOut;              //MOD044
+                CGBC_CMD_LOG_WRITE_IN      xLogWriteIn;              //MOD044
+                CGBC_CMD_LOG_GPIO_IN       xLogGpioIn;               //MOD044
+                CGBC_CMD_LOG_GPIO_OUT      xLogGpioOut;              //MOD044
+                CGBC_CMD_PWROK_DELAY_IN    xPwrokDelayIn;            //MOD045
+                CGBC_CMD_PWROK_DELAY_OUT   xPwrokDelayOut;           //MOD045
+                CGBC_CMD_API_CONFIG_IN     xApiConfigIn;             //MOD044
+                CGBC_CMD_CON_RTM_IN        xConRunTimIn;             //MOD045
+                CGBC_CMD_CON_RTM_OUT       xConRunTimOut;            //MOD045
+                CGBC_CMD_ADV_USER_LOCK_IN  xAdvUserLockIn;           //MOD045
+                CGBC_CMD_BLT_PWM_DELAY_IN  xBltPwmDelayIn;           //MOD044
+                CGBC_CMD_BLT_PWM_DELAY_OUT xBltPwmDelayOut;          //MOD044
+                CGBC_CMD_PIN_FEAT_IN       xPinFeatIn;               //MOD046
+                CGBC_CMD_PIN_FEAT_OUT      xPinFeatOut;              //MOD046
+                CGBC_CMD_DIAG_MODE_IN      xDiagModeIn;              //MOD044
+                CGBC_CMD_BAT_IN            xBatIn;                   //MOD046
+                CGBC_CMD_BAT_DYN_DATA_OUT  xBatDynData;              //MOD046
+                CGBC_CMD_BAT_STA_DATA_OUT  xBatStaData;              //MOD046
+                CGBC_CMD_WDOG_RD_IN        xWdogRdIn;                //MOD046
+                CGBC_CMD_GPIO_IRQ_TBL_IN   xGpioIrqTblIn;            //MOD046
+                CGBC_CMD_GPIO_IRQ_TBL_OUT  xGpioIrqTblOut;           //MOD046
+                CGBC_CMD_I2C_START_EXT_IN  xI2cStartExtIn;           //MOD059
+                CGBC_CMD_I2C_STAT_EXT_IN   xI2cStatExtIn;            //MOD059
+                CGBC_CMD_I2C_DATA_EXT_IN   xI2cDataExtIn;            //MOD059
+                CGBC_CMD_I2C_SPEED_EXT_IN  xI2cSpeedExtIn;           //MOD059
+                CGBC_CMD_AVR_SPM_FLS_ADDR_IN  xAvrSpmFlsAddr;        //MOD061
+                CGBC_CMD_AVR_SPM_FLS_STAT_IN  xAvrSpmFlsStatIn;      //MOD061
+                CGBC_CMD_AVR_SPM_FLS_STAT_OUT xAvrSpmFlsStatOut;     //MOD061
+                CGBC_CMD_AVR_SPM_FLS_RD32_IN  xAvrSpmFlsRd32In;      //MOD061
+                CGBC_CMD_AVR_SPM_FLS_RD32_OUT xAvrSpmFlsRd32Out;     //MOD061
+                CGBC_CMD_AVR_SPM_FLS_WR32_IN  xAvrSpmFlsWr32;        //MOD061
+                CGBC_CMD_GSPI_CFG_IN       xGspiCfgIn;               //MOD063
+                CGBC_CMD_GSPI_CFG_OUT      xGspiCfgOut;              //MOD063
+                CGBC_CMD_SYNC_OUT          sync;
                } CGBC_CMD, *P_CGBC_CMD;
 
 #endif //!__ASSEMBLER__
                                                                      //MOD014^
 
                                                                      /*MOD027v*/
-/*-----------------------------------------------
- * Host interface information structure HIF_INFO
- *-----------------------------------------------
+/*----------------------------------------------------
+ * CM41 host interface information structure HIF_INFO
+ *----------------------------------------------------
  */
 #ifndef __ASSEMBLER__
 
 typedef struct HIF_INFO_STRUCT
 {
-  UINT32      id;                  /* HIF_ID                                 */
-  UINT8       infoRev;             /* info structure revision                */
-  UINT8       infoSize;            /* structure size in bytes                */
-  UINT8       flags;               /* host interface control flags           */
-  UINT8       res7;                /* reserved (offset 0x07)                 */
-  UINT32      ctrlBase;            /* control block base address             */
-  UINT32      shBase;              /* shared command channel base address    */
-  UINT32      exBase;              /* exclusive command channel base address */
-  UINT8       shSize;              /* shared command channel size            */
-  UINT8       shIrq;               /* shared command channel IRQ control     */
-  UINT8       exSize;              /* exclusive command channel size         */
-  UINT8       exIrq;               /* exclusive command channel IRQ control  */
+                                                                     //MOD070v
+  uint32_t    id;                  /* HIF_ID                                 */
+  uint8_t     infoRev;             /* info structure revision                */
+  uint8_t     infoSize;            /* structure size in bytes                */
+  uint8_t     flags;               /* host interface control flags           */
+  uint8_t     res7;                /* reserved (offset 0x07)                 */
+  uint32_t    ctrlBase;            /* control block base address             */
+  uint32_t    shBase;              /* shared command channel base address    */
+  uint32_t    exBase;              /* exclusive command channel base address */
+  uint8_t     shSize;              /* shared command channel size            */
+  uint8_t     shIrq;               /* shared command channel IRQ control     */
+  uint8_t     exSize;              /* exclusive command channel size         */
+  uint8_t     exIrq;               /* exclusive command channel IRQ control  */
   CGBC_FW_REV fwRev;               /* CGBC firmware revision information     */
-  UINT32      res1C;               /* reserved (offset 0x1C)                 */
+  uint32_t    res1C;               /* reserved (offset 0x1C)                 */
+                                                                     //MOD070^
 } HIF_INFO, *P_HIF_INFO;
 
 #endif //!__ASSEMBLER__
diff --git a/cgutlcmn/cgbinfo.h b/cgutlcmn/cgbinfo.h
index e7df613..b8863f7 100644
--- a/cgutlcmn/cgbinfo.h
+++ b/cgutlcmn/cgbinfo.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgbmod.h b/cgutlcmn/cgbmod.h
index 7baa32e..4ae9022 100644
--- a/cgutlcmn/cgbmod.h
+++ b/cgutlcmn/cgbmod.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgepi.c b/cgutlcmn/cgepi.c
index 7e338b6..1d22ed3 100644
--- a/cgutlcmn/cgepi.c
+++ b/cgutlcmn/cgepi.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cginfo.c b/cgutlcmn/cginfo.c
index 441fbee..7f0be0c 100644
--- a/cgutlcmn/cginfo.c
+++ b/cgutlcmn/cginfo.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -18,8 +18,6 @@
  */
 
 /*---------------------------------------------------------------------------
- *
- * $Header:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/cginfo.c-arc   1.2   Sep 06 2016 15:52:02   congatec  $
  *
  * Contents: Congatec board/BIOS information module.
  *
@@ -27,7 +25,7 @@
  *
  *                      R E V I S I O N   H I S T O R Y
  *
- * $Log:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/cginfo.c-arc  $
+ * MOD001: Added support for MEC1706 based cBC.
  * 
  *    Rev 1.2   Sep 06 2016 15:52:02   congatec
  * Added BSD header.
@@ -128,7 +126,7 @@ UINT16 CgInfoGetInfo
 #ifndef BANDR
                     //MOD001 v 
                     //sprintf((char*)(&(pCgInfoStruct->FirmwareVersion)),"CGBCP%c%c%c",CgbcCmdReadBuf[0], CgbcCmdReadBuf[1],CgbcCmdReadBuf[2]);
-                    if(CgbcType == CGBC_MEC1705QSZ)
+                    if(CgbcType == CGBC_MEC170x)                   /* MOD001 */
                     {
                         sprintf((char*)(&(pCgInfoStruct->FirmwareVersion)),"GEN5P%c%c%c",CgbcCmdReadBuf[0], CgbcCmdReadBuf[1],CgbcCmdReadBuf[2]);
                     }
diff --git a/cgutlcmn/cginfo.h b/cgutlcmn/cginfo.h
index 4ed64f7..ef91163 100644
--- a/cgutlcmn/cginfo.h
+++ b/cgutlcmn/cginfo.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgmpfa.c b/cgutlcmn/cgmpfa.c
index 739d048..0d7da4b 100644
--- a/cgutlcmn/cgmpfa.c
+++ b/cgutlcmn/cgmpfa.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgmpfa.h b/cgutlcmn/cgmpfa.h
index 8b56886..e6d99eb 100644
--- a/cgutlcmn/cgmpfa.h
+++ b/cgutlcmn/cgmpfa.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgmpnv.h b/cgutlcmn/cgmpnv.h
index b98942a..2f67dd5 100644
--- a/cgutlcmn/cgmpnv.h
+++ b/cgutlcmn/cgmpnv.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgos.h b/cgutlcmn/cgos.h
index b647b85..dbfe010 100644
--- a/cgutlcmn/cgos.h
+++ b/cgutlcmn/cgos.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgospriv.h b/cgutlcmn/cgospriv.h
index 85dfb95..3ea8746 100644
--- a/cgutlcmn/cgospriv.h
+++ b/cgutlcmn/cgospriv.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgpanel.h b/cgutlcmn/cgpanel.h
index 6805b47..3bc61d5 100644
--- a/cgutlcmn/cgpanel.h
+++ b/cgutlcmn/cgpanel.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/cgutlcmn.c b/cgutlcmn/cgutlcmn.c
index c5aeff6..7ffdd88 100644
--- a/cgutlcmn/cgutlcmn.c
+++ b/cgutlcmn/cgutlcmn.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -16,20 +16,8 @@
  *
  *---------------------------------------------------------------------------
  */
-
-/*---------------------------------------------------------------------------
- *
- * $Header:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/CGUTLCMN.C-arc   1.5   Sep 06 2016 15:55:52   congatec  $
- *
- * Contents: Common congatec utility routines and data.
- *
- *---------------------------------------------------------------------------
- *
- *                      R E V I S I O N   H I S T O R Y
- *
- * $Log:   S:/CG/archives/CGTOOLS/CGUTIL/CGUTLCMN/CGUTLCMN.C-arc  $
- * 
- *    Rev 1.5   Sep 06 2016 15:55:52   congatec
+ 
+/*    Rev 1.5   Sep 06 2016 15:55:52   congatec
  * Added BSD header.
  * 
  *    Rev 1.4   May 31 2012 15:45:48   gartner
diff --git a/cgutlcmn/cgutlcmn.h b/cgutlcmn/cgutlcmn.h
index ffe1a2f..d4e10e8 100644
--- a/cgutlcmn/cgutlcmn.h
+++ b/cgutlcmn/cgutlcmn.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -181,7 +181,7 @@ void CgClearScreen(void);
 // Version definition
 //---------------------
 #define MAJOR_VERSION_NUMBER    1
-#define MINOR_VERSION_NUMBER    5
+#define MINOR_VERSION_NUMBER    6 
 
 //---------------------------
 // Access level definitions
diff --git a/cgutlcmn/dmstobin.c b/cgutlcmn/dmstobin.c
index 2ab039d..7b7eb4d 100644
--- a/cgutlcmn/dmstobin.c
+++ b/cgutlcmn/dmstobin.c
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/dmstobin.h b/cgutlcmn/dmstobin.h
index ffe98c0..c1c65da 100644
--- a/cgutlcmn/dmstobin.h
+++ b/cgutlcmn/dmstobin.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/history.txt b/cgutlcmn/history.txt
index 168d2b7..281b1f1 100644
--- a/cgutlcmn/history.txt
+++ b/cgutlcmn/history.txt
@@ -1,3 +1,66 @@
+-------------------------------------------------------------------------------
+# Version 1.6.1 #
+------------------
+COMMON:
+- Version updated to 1.6.1.
+- cgbc.h: Revised the definition and usage of standard data types to support
+  64-bit environments properly.
+- Added / extended support for various congatec Board Controller functions
+  (see cgbc.h MOD063-MOD070)
+- Added support for all MEC170x variants in the 144 pin WFBGA package
+
+==============
+Updated Files:
+==============
+/cgutlcmn/bcprg.h MOD012
+/cgutlcmn/bcprgcmn.c MOD024
+/cgutlcmn/cgbc.h MOD063-MOD070
+/cgutlcmn/mc17avr.h MOD002
+
+-------------------------------------------------------------------------------
+# Version 1.6.0 #
+------------------
+COMMON:
+- Version updated to 1.6.0.
+- Added support for Elkhart Lake MAC address recovery also when running a
+  normal (non-extended) BIOS update.
+- Fixed an issue when the Elkhart Lake BIOS update process got terminated 
+  when the GbE region could not be found. The BIOS update now continues with
+  an empty GbE region (for example when using an empty external SPI flash).
+- Changed return values for DSAC GbE region recovery so that in case of
+  no GbE region present or recovery error bios update continues without
+  GbE region recovery
+- Update to the latest CGBC API
+- Update of some copyright notes
+- Improved the performance of firmware updates on the GEN5 cBC
+- Added support for cBC based on MEC1706
+- Added support for the /!cidoverride switch
+
+==============
+Updated Files:
+==============
+/cgutlcmn/biosflsh.c MOD0018
+/cgutlcmn/bcprgcmn.c MOD022, MOD023
+/cgutlcmn/bcprg.h MOD010, MOD011
+/cgutlcmn/cgbc.h MOD062
+/cgutlcmn/cginfo.c MOD001
+/cgutlcmn/cgospriv.h MOD005
+/cgutlcmn/mc17avr.h MOD001
+
+-------------------------------------------------------------------------------
+# Version 1.5.9 #
+------------------
+COMMON:
+- Version updated to 1.5.9.
+- Implemented MAC address recovery for Elkhart Lake when running an extended update.
+- fix for DSAC MAC address recovery
+
+==============
+Updated Files:
+==============
+/cgutlcmn/biosflsh.c MOD0016, MOD017
+/cgutlcmn/biosflsh.h MOD009
+
 -------------------------------------------------------------------------------
 # Version 1.5.8 #
 ------------------
diff --git a/cgutlcmn/mc17avr.h b/cgutlcmn/mc17avr.h
index 3660006..7747bb7 100644
--- a/cgutlcmn/mc17avr.h
+++ b/cgutlcmn/mc17avr.h
@@ -1,6 +1,6 @@
 /* ----------------------------------------------------------------------------
  *
- * Copyright (c) 2018, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
@@ -17,8 +17,6 @@
  * ------------------------------------------------------------------------- */
 
 /* ----------------------------------------------------------------------------
- *
- * $Header:$
  *
  * Contents: MEC170x microcontroller declarations for AVR serial programming
  *           mode emulation
@@ -27,7 +25,11 @@
  *
  *                      R E V I S I O N   H I S T O R Y
  *
- * $Log$
+ * MOD002: Added AVR microcontroller signatures definitions for all MEC170x
+ *         variants in the 144 pin WFBGA package and corrected SRAM size of
+ *         MEC170xQ types.
+ *
+ * MOD001: Added support for MEC1706.
  *
  * ------------------------------------------------------------------------- */
 
@@ -54,6 +56,8 @@
 #define MC17_FAMILY_1701        0x001B00                   /* MEC1701x-C#-xx */
 #define MC17_FAMILY_1703        0x001C00                   /* MEC1703x-C#-xx */
 #define MC17_FAMILY_1705        0x002000                   /* MEC1705x-C#-xx */
+#define MC17_FAMILY_1706        0x002100                   /* MEC1706x-C#-xx */ /* MOD001 */
+#define MC17_FAMILY_1704        0x002200                   /* MEC1704x-C#-xx */ /* MOD002 */
 
 #define MC17_SRAM_SIZE_MSK      0x0F0000               /* MEC170x SRAM size  */
 #define MC17_SRAM_SIZE_256KB    0x010000                   /* MECxxxxH-C#-xx */
@@ -64,23 +68,205 @@
 #define MC17_PACKAGE_144_WFBGA  0x100000                   /* MECxxxxx-C#-SZ */
 #define MC17_PACKAGE_169_WFBGA  0x200000                   /* MECxxxxx-C#-TN */
 #define MC17_PACKAGE_169_XFBGA  0x300000                   /* MECxxxxx-C#-9S */
+                                                                   /* MOD002 */
+                                                                   /*      v */
+#define MEC1701HSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1701      \
+                              | MC17_SRAM_SIZE_256KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1701KSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1701      \
+                              | MC17_SRAM_SIZE_320KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1701QSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1701      \
+                              | MC17_SRAM_SIZE_480KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1703HSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1703      \
+                              | MC17_SRAM_SIZE_256KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1703KSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1703      \
+                              | MC17_SRAM_SIZE_320KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1703QSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1703      \
+                              | MC17_SRAM_SIZE_480KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1704HSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1704      \
+                              | MC17_SRAM_SIZE_256KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1704KSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1704      \
+                              | MC17_SRAM_SIZE_320KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1704QSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1704      \
+                              | MC17_SRAM_SIZE_480KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+
+#define MEC1705HSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1705      \
+                              | MC17_SRAM_SIZE_256KB  \
+                              | MC17_PACKAGE_144_WFBGA)
 
+#define MEC1705KSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1705      \
+                              | MC17_SRAM_SIZE_320KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+                                                                   /*      ^ */
+                                                                   /* MOD002 */
 #define MEC1705QSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
                               | MC17_FAMILY_1705      \
                               | MC17_SRAM_SIZE_480KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+                                                                   /* MOD002 */
+                                                                   /*      v */
+#define MEC1706HSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1706      \
+                              | MC17_SRAM_SIZE_256KB  \
                               | MC17_PACKAGE_144_WFBGA)
 
+#define MEC1706KSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1706      \
+                              | MC17_SRAM_SIZE_320KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+                                                                   /*      ^ */
+                                                                   /* MOD002 */
+                                                                   /* MOD001 */
+                                                                   /*      v */
+#define MEC1706QSZ_SIGNATURE (  MC17_MFG_ID_MICROCHIP \
+                              | MC17_FAMILY_1706      \
+                              | MC17_SRAM_SIZE_480KB  \
+                              | MC17_PACKAGE_144_WFBGA)
+                                                                   /*      ^ */
+                                                                   /* MOD001 */
 /* --------------------------------------------
  * External SPI flash, EEPROM and SRAM sizes
  * ----------------------------------------- */
+                                                                   /* MOD001 */
+                                                                   /*      v */
+#define MEC1706QSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1706QSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1706QSZ_FLASH_PAGE_SIZE  256
+#define MEC1706QSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1706QSZ_EEPROM_SIZE      (2*1024)
+#define MEC1706QSZ_SRAM_SIZE        (480*1024)                     /* MOD002 */
+                                                                   /*      ^ */
+                                                                   /* MOD001 */
+                                                                   /* MOD002 */
+                                                                   /*      v */
+#define MEC1706KSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1706KSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1706KSZ_FLASH_PAGE_SIZE  256
+#define MEC1706KSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1706KSZ_EEPROM_SIZE      (2*1024)
+#define MEC1706KSZ_SRAM_SIZE        (320*1024)
 
+#define MEC1706HSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1706HSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1706HSZ_FLASH_PAGE_SIZE  256
+#define MEC1706HSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1706HSZ_EEPROM_SIZE      (2*1024)
+#define MEC1706HSZ_SRAM_SIZE        (256*1024)
+                                                                   /*      ^ */
+                                                                   /* MOD002 */
 #define MEC1705QSZ_FLASH_SIZE       (2*1024*1024)
 #define MEC1705QSZ_FLASH_BLOCK_SIZE (4*1024)
 #define MEC1705QSZ_FLASH_PAGE_SIZE  256
 #define MEC1705QSZ_WRP_GRANULARITY  (4*1024)
 #define MEC1705QSZ_EEPROM_SIZE      (2*1024)
-#define MEC1705QSZ_SRAM_SIZE        (420*1024)
+#define MEC1705QSZ_SRAM_SIZE        (480*1024)                     /* MOD002 */
+                                                                   /* MOD002 */
+                                                                   /*      v */
+#define MEC1705KSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1705KSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1705KSZ_FLASH_PAGE_SIZE  256
+#define MEC1705KSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1705KSZ_EEPROM_SIZE      (2*1024)
+#define MEC1705KSZ_SRAM_SIZE        (320*1024)
+
+#define MEC1705HSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1705HSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1705HSZ_FLASH_PAGE_SIZE  256
+#define MEC1705HSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1705HSZ_EEPROM_SIZE      (2*1024)
+#define MEC1705HSZ_SRAM_SIZE        (256*1024)
+
+#define MEC1704QSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1704QSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1704QSZ_FLASH_PAGE_SIZE  256
+#define MEC1704QSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1704QSZ_EEPROM_SIZE      (2*1024) /* emulated in flash */
+#define MEC1704QSZ_SRAM_SIZE        (480*1024)
+
+#define MEC1704KSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1704KSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1704KSZ_FLASH_PAGE_SIZE  256
+#define MEC1704KSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1704KSZ_EEPROM_SIZE      (2*1024) /* emulated in flash */
+#define MEC1704KSZ_SRAM_SIZE        (320*1024)
+
+#define MEC1704HSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1704HSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1704HSZ_FLASH_PAGE_SIZE  256
+#define MEC1704HSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1704HSZ_EEPROM_SIZE      (2*1024) /* emulated in flash */
+#define MEC1704HSZ_SRAM_SIZE        (256*1024)
+
+#define MEC1703QSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1703QSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1703QSZ_FLASH_PAGE_SIZE  256
+#define MEC1703QSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1703QSZ_EEPROM_SIZE      (2*1024)
+#define MEC1703QSZ_SRAM_SIZE        (480*1024)
+
+#define MEC1703KSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1703KSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1703KSZ_FLASH_PAGE_SIZE  256
+#define MEC1703KSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1703KSZ_EEPROM_SIZE      (2*1024)
+#define MEC1703KSZ_SRAM_SIZE        (320*1024)
+
+#define MEC1703HSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1703HSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1703HSZ_FLASH_PAGE_SIZE  256
+#define MEC1703HSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1703HSZ_EEPROM_SIZE      (2*1024)
+#define MEC1703HSZ_SRAM_SIZE        (256*1024)
+
+#define MEC1701QSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1701QSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1701QSZ_FLASH_PAGE_SIZE  256
+#define MEC1701QSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1701QSZ_EEPROM_SIZE      (2*1024) /* emulated in flash */
+#define MEC1701QSZ_SRAM_SIZE        (480*1024)
+
+#define MEC1701KSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1701KSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1701KSZ_FLASH_PAGE_SIZE  256
+#define MEC1701KSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1701KSZ_EEPROM_SIZE      (2*1024) /* emulated in flash */
+#define MEC1701KSZ_SRAM_SIZE        (320*1024)
 
+#define MEC1701HSZ_FLASH_SIZE       (2*1024*1024)
+#define MEC1701HSZ_FLASH_BLOCK_SIZE (4*1024)
+#define MEC1701HSZ_FLASH_PAGE_SIZE  256
+#define MEC1701HSZ_WRP_GRANULARITY  (4*1024)
+#define MEC1701HSZ_EEPROM_SIZE      (2*1024) /* emulated in flash */
+#define MEC1701HSZ_SRAM_SIZE        (256*1024)
+                                                                   /*      ^ */
+                                                                   /* MOD002 */
 /* ------------------
  * Locks and fuses
  * --------------- */
diff --git a/cgutlcmn/stm32avr.h b/cgutlcmn/stm32avr.h
index 6176449..d0d58cb 100644
--- a/cgutlcmn/stm32avr.h
+++ b/cgutlcmn/stm32avr.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/cgutlcmn/tivaavr.h b/cgutlcmn/tivaavr.h
index cc57a96..51b49a3 100644
--- a/cgutlcmn/tivaavr.h
+++ b/cgutlcmn/tivaavr.h
@@ -1,6 +1,6 @@
 /*---------------------------------------------------------------------------
  *
- * Copyright (c) 2016, congatec AG. All rights reserved.
+ * Copyright (c) 2021, congatec GmbH. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the BSD 2-clause license which 
diff --git a/congatec_oem_smbios_sample.dms b/congatec_oem_smbios_sample.dms
index 15a4b59..bbfce17 100644
--- a/congatec_oem_smbios_sample.dms
+++ b/congatec_oem_smbios_sample.dms
@@ -6,46 +6,46 @@
 #############################################################################
 
 [BIOS]
-Vendor = NewBiosVendor
-Version = NewBiosVersion
-ReleaseDate = 12/31/2016
+Vendor=NewBiosVendor
+Version=NewBiosVersion
+ReleaseDate=12/31/2016
 
 [System]
-Manufacturer = NewSystemManufacturer
-Product = NewSystemProduct
-Version = NewSystemVersion
-SerialNum = NewSystemSerialNum
-UUID = 33221100554477668899aabbccddeeff
-SKU = NewSystemSKU
-Family = NewSystemFamily
+Manufacturer=NewSystemManufacturer
+Product=NewSystemProduct
+Version=NewSystemVersion
+SerialNum=NewSystemSerialNum
+UUID=33221100554477668899aabbccddeeff
+SKU=NewSystemSKU
+Family=NewSystemFamily
 
 [BaseBoard]
-Manufacturer = NewBaseBoardManufacturer
-Product = NewBaseBoardProduct
-Version = NewBaseBoardVersion
-SerialNum = NewBaseBoardSerialNum
-TagNum = NewBaseBoardAssetTag
+Manufacturer=NewBaseBoardManufacturer
+Product=NewBaseBoardProduct
+Version=NewBaseBoardVersion
+SerialNum=NewBaseBoardSerialNum
+TagNum=NewBaseBoardAssetTag
 
 [Chassis]
-Manufacturer = NewChassisManufacturer
-ChassisType = 01
-Version = NewChassisVersion
-SerialNum = NewChassisSerialNum
-TagNum = NewChassisAssetTag
-ChassisOEM = 00c0de00
+Manufacturer=NewChassisManufacturer
+ChassisType=01
+Version=NewChassisVersion
+SerialNum=NewChassisSerialNum
+TagNum=NewChassisAssetTag
+ChassisOEM=00c0de00
 
 [OemString]
-String = congatec AG
-String = http://www.congatec.de
-String = We simplify 
-String = the use 
-String = of embedded technology
+String=congatec AG
+String=http://www.congatec.de
+String=We simplify 
+String=the use 
+String=of embedded technology
 
 [SysConfigOptions]
-String = There are no jumpers
-String = or any other system controls
-String = on the module
-String = There are some jumpers
-String = on the baseboard
+String=There are no jumpers
+String=or any other system controls
+String=on the module
+String=There are some jumpers
+String=on the baseboard
 
 #############################################################################
diff --git a/version.txt b/version.txt
index a53e445..3490d6f 100644
--- a/version.txt
+++ b/version.txt
@@ -1,3 +1,54 @@
+==============================================================================
+        congatec System Utility Version 1.6.1 (01.12.2021)
+==============================================================================
+
+COMMON:
+- Version updated to 1.6.1.
+- cgbc.h: Revised the definition and usage of standard data types to support
+  64-bit environments properly.
+- Added / extended support for various congatec Board Controller functions
+  (see cgbc.h MOD063-MOD070)
+- Added support for all MEC170x variants in the 144 pin WFBGA package
+
+CGUTLCMD:  
+- Added support for all MEC170x variants in the 144 pin WFBGA package
+
+
+==============================================================================
+        congatec System Utility Version 1.6.0  (13.08.2021)
+==============================================================================
+
+COMMON:
+- Version updated to 1.6.0.
+- Added support for Elkhart Lake MAC address recovery also when running a
+  normal (non-extended) BIOS update.
+- Fixed an issue when the Elkhart Lake BIOS update process got terminated 
+  when the GbE region could not be found. The BIOS update now continues with
+  an empty GbE region (for example when using an empty external SPI flash).
+- Fix for a bug which caused a hangpup when running a firmware update on a 
+  Tiva cBC based design without the /f switch.
+- Update to the latest CGBC API.
+- Update of some copyright notes.
+- Improved the performance of firmware updates on the GEN5 cBC.
+- Added support for cBC based on MEC1706.
+- Added support for the /!cidoverride switch.
+
+CGUTLCMD:  
+- Added new /!cidoverride switch for bcprog command
+- updated smbios sample file to fix EFI Shell parsing issue with spaces
+  before and after '='
+
+
+==============================================================================
+        congatec System Utility Version 1.5.9  (28.01.2021)
+==============================================================================
+
+COMMON:
+- Version updated to 1.5.9.
+- Added support for Elkhart Lake MAC address recovery when running an extended
+  update.
+- Fix for DSAC MAC address recovery
+
 ==============================================================================
         congatec System Utility Version 1.5.8_2	(02.07.2020)
 ==============================================================================
